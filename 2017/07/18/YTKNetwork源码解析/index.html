<!doctype html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS,Objective-C,源码解析," />





  <link rel="alternate" href="/atom.xml" title="J_Knight_" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="对于iOS开发来说，就算是没有用过YTKNetwork框架，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。
在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。
1. 架构
先上图：


在这里简单说明一下：

YTKNe">
<meta property="og:type" content="article">
<meta property="og:title" content="YTKNetwork源码解析">
<meta property="og:url" content="https://github.com/knightsj/knightsj.github.io/2017/07/18/YTKNetwork源码解析/index.html">
<meta property="og:site_name" content="J_Knight_">
<meta property="og:description" content="对于iOS开发来说，就算是没有用过YTKNetwork框架，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。
在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。
1. 架构
先上图：


在这里简单说明一下：

YTKNe">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-07-18T05:35:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YTKNetwork源码解析">
<meta name="twitter:description" content="对于iOS开发来说，就算是没有用过YTKNetwork框架，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。
在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。
1. 架构
先上图：


在这里简单说明一下：

YTKNe">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/knightsj/knightsj.github.io/2017/07/18/YTKNetwork源码解析/"/>





  <title> YTKNetwork源码解析 | J_Knight_ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?46e6f54887b680a685201da90f1b9384";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">J_Knight_</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天进步一点点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/07/18/YTKNetwork源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight_">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight_">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                YTKNetwork源码解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T13:35:08+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  13,038 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  54 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对于iOS开发来说，就算是没有用过<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork框架</a>，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。</p>
<p>在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。</p>
<h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h1><hr>
<p>先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKRequest架构图"></p>
<blockquote>
<p>在这里简单说明一下：</p>
<ol>
<li>YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 </li>
<li>YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。</li>
<li>我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。</li>
<li>YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。</li>
</ol>
</blockquote>
<p>OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。</p>
<a id="more"></a>
<h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h1><hr>
<p>YTKNetwork框架采用的设计模式是<strong>命令模式（Command Pattern）</strong>。</p>
<p>首先看一下命令模式的定义：</p>
<blockquote>
<p>命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>摘自：<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a></p>
</blockquote>
<p>看一下命令模式的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令模式类图.png"></p>
<p>图中英文的含义：</p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td>抽象命令类    </td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>命令类的实现类（子类）</td>
</tr>
<tr>
<td>Invoker</td>
<td>调用者    </td>
</tr>
<tr>
<td>Receiver</td>
<td>命令接收者（执行者)</td>
</tr>
<tr>
<td>Client</td>
<td>客户端</td>
</tr>
</tbody>
</table>
<p>详细介绍一下：</p>
<ol>
<li>命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
</ol>
<p>可能还是觉得有点抽象，在这里举一个<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a>里的例子，一个客人在餐厅点餐的过程：</p>
<ol>
<li>你将点的菜写在订单里，交给了服务员。</li>
<li>服务员将订单交给厨师。</li>
<li>厨师做好菜之后将做好的菜交给服务员。</li>
<li>最后服务员把菜递给你。</li>
</ol>
<p>在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。<br>所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。</p>
<p>结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Command</th>
<th>ConcreteCommand</th>
<th>Invoker</th>
<th>Receiver</th>
<th>Client</th>
</tr>
</thead>
<tbody>
<tr>
<td>餐厅</td>
<td>空白订单</td>
<td>填入菜名的订单</td>
<td>服务员</td>
<td>厨师</td>
<td>客人</td>
</tr>
<tr>
<td>YTKNetwork</td>
<td>YTKBaseRequest</td>
<td>CustomRequest</td>
<td>YTKNetworkAgent</td>
<td>AFNetworking</td>
<td>ViewController/ViewModel</td>
</tr>
</tbody>
</table>
<p>可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。</p>
<p>另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。</p>
<p>相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。</p>
<h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><hr>
<p>在真正讲解源码之前，我先详细说一下各个类的职责:</p>
<h2 id="3-1-责任介绍"><a href="#3-1-责任介绍" class="headerlink" title="3.1 责任介绍"></a>3.1 责任介绍</h2><table>
<thead>
<tr>
<th>类名</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKRequest</td>
<td>YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。</td>
</tr>
<tr>
<td>YTKNetworkConfig</td>
<td>被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。</td>
</tr>
<tr>
<td>YTKNetworkPrivate</td>
<td>提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。</td>
</tr>
<tr>
<td>YTKNetworkAgent</td>
<td>真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。</td>
</tr>
<tr>
<td>YTKBatchRequest</td>
<td>可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。</td>
</tr>
<tr>
<td>YTKBatchRequestAgent</td>
<td>负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。</td>
</tr>
<tr>
<td>YTKChainRequest</td>
<td>可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。</td>
</tr>
<tr>
<td>YTKChainRequestAgent</td>
<td>负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。</td>
</tr>
</tbody>
</table>
<p>OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。</p>
<h2 id="3-2-单个请求"><a href="#3-2-单个请求" class="headerlink" title="3.2 单个请求"></a>3.2 单个请求</h2><h3 id="3-21-单个请求的配置"><a href="#3-21-单个请求的配置" class="headerlink" title="3.21 单个请求的配置"></a>3.21 单个请求的配置</h3><p><a href="https://github.com/yuantiku/YTKNetwork/blob/master/Docs/BasicGuide_cn.md">官方的教程</a>建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application </div><div class="line">   didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">   YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];</div><div class="line">   config.baseUrl = <span class="string">@"http://yuantiku.com"</span>;</div><div class="line">   config.cdnUrl = <span class="string">@"http://fen.bi"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RegisterApi.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"YTKRequest.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RegisterApi</span> : <span class="title">YTKRequest</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RegisterApi.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"RegisterApi.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RegisterApi</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_username;</div><div class="line">    <span class="built_in">NSString</span> *_password;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//初始化的时候将两个参数值传入</span></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _username = username;</div><div class="line">        _password = password;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需要和baseUrl拼接的地址</span></div><div class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</div><div class="line">    <span class="comment">// “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息</span></div><div class="line">    <span class="keyword">return</span> <span class="string">@"/iphone/register"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求方法，某人是GET</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求体</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。</p>
<h3 id="3-22-单个请求的发起"><a href="#3-22-单个请求的发起" class="headerlink" title="3.22 单个请求的发起"></a>3.22 单个请求的发起</h3><p>还是刚才的注册API，在实例化以后，直接调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法）就可以发起它：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">        &#125; failure:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是以block的形式回调，YTKNetwork也支持代理的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        api.delegate = <span class="keyword">self</span>;</div><div class="line">        [api start];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有两点需要注意的是：</p>
<ol>
<li>必须给自定义请求类（RegisterApi）调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法），才能真正发起请求。</li>
<li>在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。</li>
</ol>
<p>知道了YTKRequest请求是如何在外部发起的，我们现在从<code>startWithCompletionBlockWithSuccess:failure</code>方法开始，来看一下YTKNetwork都做了什么：</p>
<p>首先来到YTKBaseRequest类（因为最早是由它定义的该方法）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line"><span class="comment">//传入成功和失败的block,并保存起来</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="comment">//保存成功和失败的回调block，便于将来调用</span></div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    <span class="comment">//发起请求</span></div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//保存成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                              failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当保存完成功和失败的block以后，调用<code>start</code>方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了<code>start</code>方法，但是由于YTKRequest类是它的子类并也实现了<code>start</code>方法，所以这里最先走的是YTKRequest类的<code>start</code>方法）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理）</span></div><div class="line">    _dataFromCache = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//5. 回调之前的操作</span></div><div class="line">        <span class="comment">//5.1 缓存处理</span></div><div class="line">        [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line">        </div><div class="line">        <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">        [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line">        </div><div class="line">        YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//6. 执行回调</span></div><div class="line">        <span class="comment">//6.1 请求完成的代理</span></div><div class="line">        [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">        <span class="comment">//6.2 请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">            strongSelf.successCompletionBlock(strongSelf);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">        [strongSelf clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个<code>start</code>方法里，它做的是请求之前缓存的查询和检查工作:</p>
<ul>
<li>如果忽略缓存，或者缓存获取失败，调用<code>startWithoutCache</code>方法（参考1-3的情况），发起请求。</li>
<li>如果能成功获取到缓存，则直接回调（参考4-7的情况）。</li>
</ul>
<p>我们来看一下每一步的具体实现：</p>
<ol>
<li><code>ignoreCache</code>属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。</li>
<li><code>resumableDownloadPath</code>是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。</li>
<li><code>loadCacheWithError：</code>方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒）</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache time"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 是否有缓存的元数据，如果没有，返回错误</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheMetadata]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid metadata. Cache may not exist"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，再验证是否有效</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateCacheWithError:error]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，而且有效，再验证是否能取出来</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheData]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache data"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。</p>
<p>我们来看一下上面关于缓存的元数据的获取方法：<code>loadCacheMetadata</code>方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheMetadata &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheMetadataFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            <span class="comment">//将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata</span></div><div class="line">            _cacheMetadata = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            YTKLog(<span class="string">@"Load cache metadata failed, reason = %@"</span>, exception.reason);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。<br>YTKCacheMetadata类被定义在YTKRequest.m文件里面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">long</span> <span class="keyword">long</span> version;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。<br>因此，<code>loadCacheMetadata</code>方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的<code>cacheMetadata</code>属性上。</p>
<p>现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 是否大于过期时间</span></div><div class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</div><div class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</div><div class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache expired"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 缓存的版本号是否符合</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</div><div class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache version mismatch"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 敏感信息是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</div><div class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</div><div class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></div><div class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache sensitive data mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// app的版本是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</div><div class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</div><div class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"App version mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果每项元数据信息都能通过，再在<code>loadCacheData</code>方法里面验证缓存是否能被取出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheData &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</div><div class="line">        _cacheData = data;</div><div class="line">        _cacheString = [[<span class="built_in">NSString</span> alloc] initWithData:_cacheData encoding:<span class="keyword">self</span>.cacheMetadata.stringEncoding];</div><div class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.responseSerializerType) &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Do nothing.</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                _cacheJSON = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:_cacheData options:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span> error:&amp;error];</div><div class="line">                <span class="keyword">return</span> error == <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                _cacheXML = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:_cacheData];</div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。</p>
<p>当确认缓存可以成功取出后，手动设置<code>dataFromCache</code>属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。</p>
<p>然后在真正回调之前做了如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="comment">//5. 回调之前的操作</span></div><div class="line">    <span class="comment">//5.1 缓存处理</span></div><div class="line">    [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">    [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line"></div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.1：<code>requestCompletePreprocessor</code>方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//保存响应数据到缓存</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//保存响应数据到缓存</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line"><span class="comment">//保存响应数据到缓存</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// New data will always overwrite old data.</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到, <code>requestCompletePreprocessor</code>方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要<code>cacheTimeInSeconds</code>方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是<code>isDataFromCache</code>方法返回NO。<br>但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。</p>
</blockquote>
<p>接着看下5.2：<code>requestCompleteFilter</code>方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompleteFilter &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">         strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，在用户同时实现了代理和block的情况下，二者都会被调用。</p>
</blockquote>
<p>到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。</p>
<p>反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么：</p>
<p>仔细看一下上面的<code>start</code>方法，我们会发现，如果缓存不满足条件时，会直接调用<code>startWithoutCache</code>方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么在<code>startWithoutCache</code>方法里都做了什么呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)startWithoutCache &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 清除缓存</span></div><div class="line">    [<span class="keyword">self</span> clearCacheVariables];</div><div class="line">    </div><div class="line">    <span class="comment">//2. 调用父类的发起请求</span></div><div class="line">    [<span class="keyword">super</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清除当前请求对应的所有缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearCacheVariables &#123;</div><div class="line">    _cacheData = <span class="literal">nil</span>;</div><div class="line">    _cacheXML = <span class="literal">nil</span>;</div><div class="line">    _cacheJSON = <span class="literal">nil</span>;</div><div class="line">    _cacheString = <span class="literal">nil</span>;</div><div class="line">    _cacheMetadata = <span class="literal">nil</span>;</div><div class="line">    _dataFromCache = <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，首先清除了关于缓存的所有数据，然后调用父类的<code>start</code>方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m:</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 告诉Accessories即将回调了（其实是即将发起请求）</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步里的Accessories是一些遵从<ytkrequestaccessory>代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里：</ytkrequestaccessory></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来跟踪请求的状态的代理。</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YTKRequestAccessory</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to start.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStart:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to stop. This method is called</span></div><div class="line"><span class="comment">///  before executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request has already stoped. This method is called</span></div><div class="line"><span class="comment">///  after executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestDidStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。</p>
<p>接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task</span></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户自定义的requestURL</span></div><div class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//响应的统一处理</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//序列化失败，则认定为请求失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSAssert</span>(request.requestTask != <span class="literal">nil</span>, <span class="string">@"requestTask should not be nil"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Retain request</span></div><div class="line">    YTKLog(<span class="string">@"Add request: %@"</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</div><div class="line">    </div><div class="line">    <span class="comment">//2. 将request放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line">    </div><div class="line">    <span class="comment">//3. 开始task</span></div><div class="line">    [request.requestTask resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法挺长的，但是请不要被吓到，它总共分为三个部分：</p>
<ul>
<li>第一部分是获取当前请求对应的task并赋给request的<code>requestTask</code>属性（以后提到的request，都为用户自定义的当前请求类的实例）。</li>
<li>第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。</li>
<li>第三部分是启动task。</li>
</ul>
<p>下面我来依次讲解每个部分：</p>
<p><strong>第一部分：获取当前请求对应的task并赋给request</strong>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//统一处理请求响应</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里判断了用户是否自定义了request：</p>
<ol>
<li>如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。</li>
<li>如果不是，则调用YTKRequest自己的生成task的方法。</li>
</ol>
<p>第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，<code>sessionTaskForRequest: error :</code>方法内部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//根据不同请求类型，序列化类型，和请求参数来返回NSURLSessionTask</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获得请求类型（GET，POST等）</span></div><div class="line">    YTKRequestMethod method = [request requestMethod];</div><div class="line"></div><div class="line">    <span class="comment">//2. 获得请求url</span></div><div class="line">    <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line"></div><div class="line">    <span class="comment">//3. 获得请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line">    </div><div class="line">    <span class="comment">//4. 获得request serializer</span></div><div class="line">    AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据不同的请求类型来返回对应的task</span></div><div class="line">    <span class="keyword">switch</span> (method) &#123;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodGET:</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</div><div class="line">                <span class="comment">//下载任务</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath requestSerializer:requestSerializer URLString:url parameters:param progress:request.resumableDownloadProgressBlock error:error];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//普通get请求</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPOST:</div><div class="line">            <span class="comment">//POST请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodHEAD:</div><div class="line">            <span class="comment">//HEAD请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"HEAD"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPUT:</div><div class="line">            <span class="comment">//PUT请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PUT"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodDELETE:</div><div class="line">            <span class="comment">//DELETE请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"DELETE"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPATCH:</div><div class="line">            <span class="comment">//PATCH请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PATCH"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法：</p>
<ol>
<li>获得请求类型（GET，POST等）：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  YTKRequestMethod method = [request requestMethod];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>requestMethod</code>方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。</p>
<p>它的枚举类型在YTKBaseRequest.h里面定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.h</span></div><div class="line"><span class="comment">///  HTTP Request method.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestMethod) &#123;</div><div class="line">    YTKRequestMethodGET = <span class="number">0</span>,</div><div class="line">    YTKRequestMethodPOST,</div><div class="line">    YTKRequestMethodHEAD,</div><div class="line">    YTKRequestMethodPUT,</div><div class="line">    YTKRequestMethodDELETE,</div><div class="line">    YTKRequestMethodPATCH,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用户可以根据实际的需求在自定义request类里面重写这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterAPI.m</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.获得请求url：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//返回当前请求url</span></div><div class="line">- (<span class="built_in">NSString</span> *)buildRequestUrl:(YTKBaseRequest *)request &#123;</div><div class="line">   </div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="comment">//用户自定义的url（不包括在YTKConfig里面设置的base_url）</span></div><div class="line">    <span class="built_in">NSString</span> *detailUrl = [request requestUrl];</div><div class="line">    <span class="built_in">NSURL</span> *temp = [<span class="built_in">NSURL</span> URLWithString:detailUrl];</div><div class="line">    </div><div class="line">    <span class="comment">// 存在host和scheme的url立即返回正确</span></div><div class="line">    <span class="keyword">if</span> (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</div><div class="line">        <span class="keyword">return</span> detailUrl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果需要过滤url，则过滤</span></div><div class="line">    <span class="built_in">NSArray</span> *filters = [_config urlFilters];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *baseUrl;</div><div class="line">    <span class="keyword">if</span> ([request useCDN]) &#123;</div><div class="line">        <span class="comment">//如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN</span></div><div class="line">        <span class="keyword">if</span> ([request cdnUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request cdnUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config cdnUrl];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl</span></div><div class="line">        <span class="keyword">if</span> ([request baseUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request baseUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config baseUrl];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果末尾没有/，则在末尾添加一个／</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:baseUrl];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (baseUrl.length &gt; <span class="number">0</span> &amp;&amp; ![baseUrl hasSuffix:<span class="string">@"/"</span>]) &#123;</div><div class="line">        url = [url URLByAppendingPathComponent:<span class="string">@""</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:detailUrl relativeToURL:url].absoluteString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.获得请求参数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">      <span class="comment">//获取用户提供的请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户提供的构造请求体的block（默认是没有的）</span></div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterApi.m</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.获得request serializer</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   <span class="comment">//4. 获得request serializer</span></div><div class="line">   AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    AFHTTPRequestSerializer *requestSerializer = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//HTTP or JSON</span></div><div class="line">    <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123;</div><div class="line">        requestSerializer = [AFHTTPRequestSerializer serializer];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123;</div><div class="line">        requestSerializer = [AFJSONRequestSerializer serializer];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//超时时间</span></div><div class="line">    requestSerializer.timeoutInterval = [request requestTimeoutInterval];</div><div class="line">    </div><div class="line">    <span class="comment">//是否允许数据服务</span></div><div class="line">    requestSerializer.allowsCellularAccess = [request allowsCellularAccess];</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要验证</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray];</div><div class="line">    <span class="keyword">if</span> (authorizationHeaderFieldArray != <span class="literal">nil</span>) &#123;</div><div class="line">        [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject</div><div class="line">                                                          password:authorizationHeaderFieldArray.lastObject];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要自定义 HTTPHeaderField</span></div><div class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary];</div><div class="line">    <span class="keyword">if</span> (headerFieldValueDictionary != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *httpHeaderField <span class="keyword">in</span> headerFieldValueDictionary.allKeys) &#123;</div><div class="line">            <span class="built_in">NSString</span> *value = headerFieldValueDictionary[httpHeaderField];</div><div class="line">            [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> requestSerializer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。</p>
<p>到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:<span class="literal">nil</span> error:error];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终返回NSURLSessionDataTask实例</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//根据有无构造请求体的block的情况来获取request</span></div><div class="line">    <span class="keyword">if</span> (block) &#123;</div><div class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获得request以后来获取dataTask</span></div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    dataTask = [_manager dataTaskWithRequest:request</div><div class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</div><div class="line">                               <span class="comment">//响应的统一处理</span></div><div class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</div><div class="line">                           &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。</p>
<p>OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在<code>addRequest：</code>方法里接下来做的是对序列化失败的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//序列化失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。</p>
<p>继续往下走，到了优先级的映射部分：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestPriority) &#123;</div><div class="line">    YTKRequestPriorityLow = <span class="number">-4</span>L,</div><div class="line">    YTKRequestPriorityDefault = <span class="number">0</span>,</div><div class="line">    YTKRequestPriorityHigh = <span class="number">4</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。</p>
<p>到这里，我们拿到了task的实例并设置好了优先级，紧接着就是<code>addRequest:</code>方法里的第二个部分：<br>YTKNetworkAgent将request实例放在了一个字典中，保存起来：</p>
<p><strong>第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//将request实例放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">  [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addRequestToRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    _requestsRecord[@(request.requestTask.taskIdentifier)] = request;</div><div class="line">    Unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#define Lock() pthread_mutex_lock(&amp;_lock)</span></div><div class="line"><span class="meta">#define Unlock() pthread_mutex_unlock(&amp;_lock)</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。</p>
</blockquote>
<p>在当前的request被保存以后，就到了最后一步，正式发起请求：</p>
<p><strong>第三部分：启动task</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   [request.requestTask resume];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。</p>
<p>那么接下来我们看一下YTKNetwork是如何处理请求的回调的。</p>
<p>眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：<code>handleRequestResult:responseObject:error:</code>。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//统一处理请求结果，包括成功和失败的情况</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task对应的request</span></div><div class="line">    Lock();</div><div class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</div><div class="line">    Unlock();</div><div class="line"></div><div class="line">    <span class="comment">//如果不存在对应的request，则立即返回</span></div><div class="line">    <span class="keyword">if</span> (!request) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    。。。</div><div class="line"></div><div class="line">    <span class="comment">//2. 获取request对应的response</span></div><div class="line">    request.responseObject = responseObject;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 获取responseObject，responseData和responseString</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        </div><div class="line">       <span class="comment">//3.1 获取 responseData</span></div><div class="line">        request.responseData = responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//3.2 获取responseString</span></div><div class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">         <span class="comment">//3.3 获取responseObject（或responseJSONObject）</span></div><div class="line">        <span class="comment">//根据返回的响应的序列化的类型来得到对应类型的响应</span></div><div class="line">        <span class="keyword">switch</span> (request.responseSerializerType)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Default serializer. Do nothing.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                request.responseJSONObject = request.responseObject;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调</span></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="comment">//如果该方法传入的error不为nil</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = error;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        <span class="comment">//如果序列化失败了</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = serializationError;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//即使没有error而且序列化通过，也要验证request是否有效</span></div><div class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</div><div class="line">        requestError = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单讲解一下上面的代码：</p>
<ul>
<li>首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。</li>
<li>然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。</li>
<li>再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。</li>
<li>最后根据succeed的值来进行成功和失败的回调。</li>
</ul>
<p>这里先重点介绍一下是如何判断json的有效性的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//判断code是否符合范围和json的有效性</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateResult:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 判断code是否在200~299之间</span></div><div class="line">    <span class="built_in">BOOL</span> result = [request statusCodeValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!result) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid status code"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//2. result 存在的情况判断json是否有效</span></div><div class="line">    <span class="keyword">id</span> json = [request responseJSONObject];</div><div class="line">    <span class="keyword">id</span> validator = [request jsonValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (json &amp;&amp; validator) &#123;</div><div class="line">        <span class="comment">//通过json和validator来判断json是否有效</span></div><div class="line">        result = [YTKNetworkUtils validateJSON:json withValidator:validator];</div><div class="line">        </div><div class="line">        <span class="comment">//如果json无效</span></div><div class="line">        <span class="keyword">if</span> (!result) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid JSON format"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，首先，用<code>statusCodeValidator</code>方法判断响应的code是否在正确的范围:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseReqiest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)statusCodeValidator &#123;</div><div class="line">    <span class="built_in">NSInteger</span> statusCode = [<span class="keyword">self</span> responseStatusCode];</div><div class="line">    <span class="keyword">return</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt;= <span class="number">299</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSInteger</span>)responseStatusCode &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.response.statusCode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再判断json的有效性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkUtils.m</span></div><div class="line"><span class="comment">//判断json的有效性</span></div><div class="line">+ (<span class="built_in">BOOL</span>)validateJSON:(<span class="keyword">id</span>)json withValidator:(<span class="keyword">id</span>)jsonValidator &#123;</div><div class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">        [jsonValidator isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSDictionary</span> * dict = json;</div><div class="line">        <span class="built_in">NSDictionary</span> * validator = jsonValidator;</div><div class="line">        <span class="built_in">BOOL</span> result = <span class="literal">YES</span>;</div><div class="line">        <span class="built_in">NSEnumerator</span> * enumerator = [validator keyEnumerator];</div><div class="line">        <span class="built_in">NSString</span> * key;</div><div class="line">        <span class="keyword">while</span> ((key = [enumerator nextObject]) != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">id</span> value = dict[key];</div><div class="line">            <span class="keyword">id</span> format = validator[key];</div><div class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]</div><div class="line">                || [value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                result = [<span class="keyword">self</span> validateJSON:value withValidator:format];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:format] == <span class="literal">NO</span> &amp;&amp;</div><div class="line">                    [value isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] == <span class="literal">NO</span>) &#123;</div><div class="line">                    result = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">               [jsonValidator isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSArray</span> * validatorArray = (<span class="built_in">NSArray</span> *)jsonValidator;</div><div class="line">        <span class="keyword">if</span> (validatorArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSArray</span> * array = json;</div><div class="line">            <span class="built_in">NSDictionary</span> * validator = jsonValidator[<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> array) &#123;</div><div class="line">                <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> validateJSON:item withValidator:validator];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:jsonValidator]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。</p>
<p>在验证返回的JSON数据是否有效以后，就可以进行回调了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先来分别看一下请求成功的处理和失败的处理：</p>
<p>请求成功的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block</span></div><div class="line">- (<span class="keyword">void</span>)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//写入缓存 </span></div><div class="line">        [request requestCompletePreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理,用户自定义</span></div><div class="line">        [request requestCompleteFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，则调用成功的代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFinished:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了成功回调的代码，则调用</span></div><div class="line">        <span class="keyword">if</span> (request.successCompletionBlock) &#123;</div><div class="line">            request.successCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经结束了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下<code>requestCompletePreprocessor</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//写入缓存文件</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">//写入缓存文件</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存文件</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// 1. 保存request的responseData到cacheFilePath</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 2. 保存request的metadata到cacheMetadataFilePath</span></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先看一下写入缓存操作的执行条件：当<code>cacheTimeInSeconds</code>方法返回大于0并且<code>isDataFromCache</code>为NO的时候会进行写入缓存。</p>
<p><code>cacheTimeInSeconds</code>方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。</p>
<p><code>isDataFromCache</code>属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：<code>isDataFromCache</code>的默认值是NO。在请求发起之前，-<br>查询缓存的时候：</p>
<ul>
<li>如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。</li>
<li>如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。</li>
</ul>
<p>即是说，如果发送了请求，则<code>isDataFromCache</code>一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。</p>
<p>因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。</p>
<p>我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：<br>第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种：</p>
<ol>
<li>缓存的版本，默认返回为0，用户可以自定义。</li>
<li>敏感数据，类型为id，默认返回nil，用户可以自定义。</li>
<li>NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
<li>元数据的创建时间。</li>
<li>app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
</ol>
<p>在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过<code>cacheMetadataFilePath</code>方法获取。</p>
<p>现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="comment">//纯NSData数据缓存的文件名</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</div><div class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</div><div class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</div><div class="line">    <span class="keyword">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</div><div class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Method:%ld Host:%@ Url:%@ Argument:%@"</span>,</div><div class="line">                             (<span class="keyword">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</div><div class="line">    <span class="keyword">return</span> cacheFileName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//纯NSData数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [<span class="keyword">self</span> cacheFileName];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//元数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.metadata"</span>, [<span class="keyword">self</span> cacheFileName]];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建用户保存所有YTKNetwork缓存的文件夹</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//获取全路径</span></div><div class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@"LazyRequestCache"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</div><div class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//创建文件夹</span></div><div class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。</p>
<p>而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。</p>
<p>为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存和缓存元数据的文件"></p>
<p>而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。</p>
<p>OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line"></div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">        strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用<code>clearCompletionBlock</code>方法将block清空。该方法的实现是在YTKBaseRequest里：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求失败</span></div><div class="line">- (<span class="keyword">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    request.error = error;</div><div class="line">    YTKLog(<span class="string">@"Request %@ failed, status code = %ld, error = %@"</span>,</div><div class="line">           <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]), (<span class="keyword">long</span>)request.responseStatusCode, error.localizedDescription);</div><div class="line"></div><div class="line">    <span class="comment">// 储存未完成的下载数据</span></div><div class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</div><div class="line">    <span class="keyword">if</span> (incompleteDownloadData) &#123;</div><div class="line">        [incompleteDownloadData writeToURL:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Load response from file and clean up if download task failed.</span></div><div class="line">    <span class="comment">//如果下载任务失败，则取出对应的响应文件并清空</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = request.responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件</span></div><div class="line">        <span class="keyword">if</span> (url.isFileURL &amp;&amp; [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:url.path]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//将url的data和string赋给request</span></div><div class="line">            request.responseData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">            request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:url error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空request</span></div><div class="line">        request.responseObject = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//请求失败的预处理，YTK没有定义，需要用户定义</span></div><div class="line">        [request requestFailedPreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理</span></div><div class="line">        [request requestFailedFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，就调用代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFailed:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了失败回调的block代码，就调用block</span></div><div class="line">        <span class="keyword">if</span> (request.failureCompletionBlock) &#123;</div><div class="line">            request.failureCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经停止了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到<code>resumableDownloadPath</code>里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。</p>
<p>到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKNetwork流程图"></p>
<p>我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.h</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request;</div><div class="line"></div><div class="line"><span class="comment">///  取消所有添加的request</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests;</div></pre></td></tr></table></figure></p>
<p>首先我们看下取消某个request这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line">    <span class="comment">//获取request的task，并取消</span></div><div class="line">    [request.requestTask cancel];</div><div class="line">    <span class="comment">//从字典里移除当前request</span></div><div class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">    <span class="comment">//清理所有block</span></div><div class="line">    [request clearCompletionBlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从字典里移除某request</span></div><div class="line">- (<span class="keyword">void</span>)removeRequestFromRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)];</div><div class="line">    YTKLog(<span class="string">@"Request queue size = %zd"</span>, [_requestsRecord count]);</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取消所有在字典里添加的request：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests &#123;</div><div class="line">    Lock();</div><div class="line">    <span class="built_in">NSArray</span> *allKeys = [_requestsRecord allKeys];</div><div class="line">    Unlock();</div><div class="line">    <span class="keyword">if</span> (allKeys &amp;&amp; allKeys.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *copiedKeys = [allKeys <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *key <span class="keyword">in</span> copiedKeys) &#123;</div><div class="line">            Lock();</div><div class="line">            YTKBaseRequest *request = _requestsRecord[key];</div><div class="line">            Unlock();</div><div class="line">            <span class="comment">//stop每个请求</span></div><div class="line">            [request stop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个stop方法是在YTKBaseRequest里面定义的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories将要回调了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//清空代理</span></div><div class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//调用agent的取消某个request的方法</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories回调完成了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。</p>
<h2 id="3-3-批量请求和链式请求"><a href="#3-3-批量请求和链式请求" class="headerlink" title="3.3 批量请求和链式请求"></a>3.3 批量请求和链式请求</h2><p>YTKNetwork支持的批量请求有两种：</p>
<ol>
<li>批量请求：多个请求几乎同时发起。</li>
<li>链式请求：当前个请求结束后才能发起下一个请求。</li>
</ol>
<p>其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？</p>
<p>我们首先来看一下YTKNetwork是如何实现批量请求的。</p>
<h3 id="3-31批量请求"><a href="#3-31批量请求" class="headerlink" title="3.31批量请求"></a>3.31批量请求</h3><p>YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的<code>_requestArray</code>实例变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithRequestArray:(<span class="built_in">NSArray</span>&lt;YTKRequest *&gt; *)requestArray &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//保存为属性</span></div><div class="line">        _requestArray = [requestArray <span class="keyword">copy</span>];</div><div class="line"></div><div class="line">        <span class="comment">//批量请求完成的数量初始化为0</span></div><div class="line">        _finishedCount = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败</span></div><div class="line">        <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">            <span class="keyword">if</span> (![req isKindOfClass:[YTKRequest <span class="keyword">class</span>]]) &#123;</div><div class="line">                YTKLog(<span class="string">@"Error, request item must be YTKRequest instance."</span>);</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化以后，我们就可以调用<code>start</code>方法来发起当前YTKBatchRequest实例所管理的所有请求了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="comment">//batch请求开始</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                                    failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                              failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果batch里第一个请求已经成功结束，则不能再start</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Batch request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//最开始设定失败的request为nil</span></div><div class="line">    _failedRequest = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//使用YTKBatchRequestAgent来管理当前的批量请求</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:<span class="keyword">self</span>];</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//遍历所有request，并开始请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        req.delegate = <span class="keyword">self</span>;</div><div class="line">        [req clearCompletionBlock];</div><div class="line">        [req start];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们可以看出：<br>1.在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的<code>start</code>方法会立即返回，否则可以无限制start。<br>2.YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequestAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addBatchRequest:(YTKBatchRequest *)request &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        [_requestArray addObject:request];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的<code>_requestArray</code>并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。</p>
<p>发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。</p>
<p>YTKRequest子类成功的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="meta">#pragma mark - Network Request Delegate</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//某个request成功后，首先让_finishedCount + 1</span></div><div class="line">    _finishedCount++;</div><div class="line">    </div><div class="line">    <span class="comment">//如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount == _requestArray.count) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//调用即将结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求成功的代理</span></div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFinished:)]) &#123;</div><div class="line">            [_delegate batchRequestFinished:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//调用批量请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (_successCompletionBlock) &#123;</div><div class="line">            _successCompletionBlock(<span class="keyword">self</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空成功和失败的block</span></div><div class="line">        [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">        [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。</p>
<p>接下来我们看一下某个请求失败的处理：</p>
<p>YTKReques子类失败的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    _failedRequest = request;</div><div class="line">    </div><div class="line">    <span class="comment">//调用即将结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//停止batch里所有的请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest *req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        [req stop];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的代理</span></div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFailed:)]) &#123;</div><div class="line">        [_delegate batchRequestFailed:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的block</span></div><div class="line">    <span class="keyword">if</span> (_failureCompletionBlock) &#123;</div><div class="line">        _failureCompletionBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//清空成功和失败的block</span></div><div class="line">    [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line"></div><div class="line">    <span class="comment">//调用请求结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。<br>而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。</p>
<p>总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。</p>
<p>现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。</p>
<h3 id="3-32链式请求"><a href="#3-32链式请求" class="headerlink" title="3.32链式请求"></a>3.32链式请求</h3><p>和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。</p>
<p>但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//下一个请求的index</span></div><div class="line">        _nextRequestIndex = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//保存链式请求的数组</span></div><div class="line">        _requestArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//保存回调的数组</span></div><div class="line">        _requestCallbackArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//空回调，用来填充用户没有定义的回调block</span></div><div class="line">        _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123;</div><div class="line">            <span class="comment">// do nothing</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是它提供了添加和删除request的接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//在当前chain添加request和callback</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//保存当前请求</span></div><div class="line">    [_requestArray addObject:request];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (callback != <span class="literal">nil</span>) &#123;</div><div class="line">        [_requestCallbackArray addObject:callback];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称</span></div><div class="line">        [_requestCallbackArray addObject:_emptyCallback];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。</p>
<p>我们接着看一下链式请求的发起：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="comment">//如果第1个请求已经结束，就不再重复start了</span></div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果请求队列数组里面还有request，则取出并start</span></div><div class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">        <span class="comment">//取出当前request并start</span></div><div class="line">        [<span class="keyword">self</span> startNextRequest];</div><div class="line">        <span class="comment">//在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain）</span></div><div class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request array is empty."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，YTKChainRequest用<code>_nextRequestIndex</code>来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。</p>
<p>这里<code>startNextRequest</code>方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)startNextRequest &#123;</div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</div><div class="line">        _nextRequestIndex++;</div><div class="line">        request.delegate = <span class="keyword">self</span>;</div><div class="line">        [request clearCompletionBlock];</div><div class="line">        [request start];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法有两个作用：</p>
<ol>
<li>第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界）</li>
<li>第二个作用是如果可以进行下一个request，则发起该request。并将<code>_nextRequestIndex</code>+1。</li>
</ol>
<p>所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。</p>
<p>现在我们知道了YTKChainRequest的发送，接下来看一下回调部分:</p>
<p>和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//某个request请求成功的代理的实现</span></div><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 取出当前的request和callback，进行回调</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</div><div class="line">    callback(<span class="keyword">self</span>, request);<span class="comment">//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面</span></div><div class="line">    </div><div class="line">    <span class="comment">//2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</div><div class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</div><div class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用<code>startNextRequest</code>方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了：</p>
<ul>
<li>如果没有了，则调用当前YTKChainRequest的最终成功的回调。</li>
<li>如果还有，则发起接下来的request（按顺序）。</li>
</ul>
<p>接下来我们再看一下某个request失败的代理的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//某个reqeust请求失败的代理</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFailed:failedBaseRequest:)]) &#123;</div><div class="line">        [_delegate chainRequestFailed:<span class="keyword">self</span> failedBaseRequest:request];</div><div class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。</p>
<p>现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//终止当前的chain</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line"></div><div class="line">    <span class="comment">//首先调用即将停止的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//然后stop当前的请求，再清空chain里所有的请求和回掉block</span></div><div class="line">    [<span class="keyword">self</span> clearRequest];</div><div class="line"></div><div class="line">    <span class="comment">//在YTKChainRequestAgent里移除当前的chain</span></div><div class="line">    [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line"></div><div class="line">    <span class="comment">//最后调用已经结束的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>stop</code>方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用<code>clearReuqest</code>方法，将当前request停止，再将请求队列数组和callback数组清空。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearRequest &#123;</div><div class="line">    <span class="comment">//获取当前请求的index</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (currentRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[currentRequestIndex];</div><div class="line">        [request stop];</div><div class="line">    &#125;</div><div class="line">    [_requestArray removeAllObjects];</div><div class="line">    [_requestCallbackArray removeAllObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在YTKChainRequestAgent单例里面，将自己移除掉。</p>
<h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4. 最后的话"></a>4. 最后的话</h1><hr>
<p>不知不觉写了好多，请原谅我一如既往啰嗦的风格~</p>
<p>阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。</p>
<p>我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。</p>
<p>所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。</p>
<p>希望这篇文章能对读者们有所帮助~</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechatpay.jpg" alt="J_Knight_ WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="J_Knight_ Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
            <a href="/tags/源码解析/" rel="tag"># 源码解析</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/14/iOS 代码规范/" rel="next" title="iOS 代码规范">
                <i class="fa fa-chevron-left"></i> iOS 代码规范
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/30/从一个实战项目来看一下React Native开发的几个关键技术点/" rel="prev" title="从一个实战项目来看一下React Native开发的几个关键技术点">
                从一个实战项目来看一下React Native开发的几个关键技术点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg"
               alt="J_Knight_" />
          <p class="site-author-name" itemprop="name">J_Knight_</p>
           
              <p class="site-description motion-element" itemprop="description">正在学React Native开发的iOS开发者</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/knightsj" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/1929625262/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/57f8ffda2e958a005581e3c0" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/3dd433cb3ea1" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-架构"><span class="nav-number">1.</span> <span class="nav-text">1. 架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-设计模式"><span class="nav-number">2.</span> <span class="nav-text">2. 设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-源码解析"><span class="nav-number">3.</span> <span class="nav-text">3. 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-责任介绍"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 责任介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-单个请求"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 单个请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-21-单个请求的配置"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.21 单个请求的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-22-单个请求的发起"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.22 单个请求的发起</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-批量请求和链式请求"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 批量请求和链式请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-31批量请求"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.31批量请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-32链式请求"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.32链式请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-最后的话"><span class="nav-number">4.</span> <span class="nav-text">4. 最后的话</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">J_Knight_</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>
