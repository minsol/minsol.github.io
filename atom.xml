<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J_Knight_</title>
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/knightsj/knightsj.github.io/"/>
  <updated>2018-01-31T01:54:40.476Z</updated>
  <id>https://github.com/knightsj/knightsj.github.io/</id>
  
  <author>
    <name>J_Knight_</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构 &amp; 算法 in Swift （一）：Swift基础和数据结构</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20&amp;%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/01/31/数据结构 &amp; 算法 in Swift （一）：Swift基础和数据结构/</id>
    <published>2018-01-31T00:47:58.980Z</published>
    <updated>2018-01-31T01:54:40.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/da_header_2.png" alt=""></p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>从本文标题中的序号可以看出，本文是一个连载的开篇。</p>
<p>而且这个连载的标题是：数据结构 &amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：</p>
<h2 id="第一：为什么学习数据结构和算法？"><a href="#第一：为什么学习数据结构和算法？" class="headerlink" title="第一：为什么学习数据结构和算法？"></a>第一：为什么学习数据结构和算法？</h2><p><strong>学习通用性知识，突破技能瓶颈</strong>：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。</p>
<h2 id="第二：为什么用Swift语言来实现？"><a href="#第二：为什么用Swift语言来实现？" class="headerlink" title="第二：为什么用Swift语言来实现？"></a>第二：为什么用Swift语言来实现？</h2><ol>
<li><p><strong>选择哪个语言并不重要，重要的是数据结构和算法本身的理解</strong>：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？</p>
</li>
<li><p><strong>如今Swift的势头还在上涨</strong>：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。</p>
<p>​</p>
</li>
</ol>
<p>基于上面这些原因，在今年年初把<strong>数据结构，算法和Swift</strong>的学习提上了日程，并且计划以连载的形式把学习过程中的笔记和知识分享出来。</p>
<p>该系列的<strong>最佳受众</strong>是那些已经会Swift，但是对数据结构和算法还没有过多接触过的iOS开发者。其次是那些不会Swift也不会数据结构和算法的iOS开发者，毕竟Swift是大势所趋。</p>
<p>不过对于那些非iOS开发者来说也同样适合，因为还是那句话：<strong>重点不在于使用哪种语言，而是数据结构和算法本身</strong>。除了第一篇会讲解一些在这个系列文章会使用到的Swift基础语法以外，后续的文章我会逐渐<strong>弱化对Swift语言的讲解，将重点放在数据结构和算法这里</strong>。而且后续我还会不断增加其他语言的实现（Java语言是肯定要加的，其他的语言还待定）。</p>
<p>好了，背景介绍完了，现在正式开始：</p>
<p>作为该系列的开篇，本文分为两个部分：</p>
<ol>
<li><strong>Swift语法基</strong>础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。</li>
<li><strong>数据结构</strong>：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列）</li>
</ol>
<blockquote>
<p>注：该系列涉及到的Swift语法最低基于Swift4.0。</p>
</blockquote>
<a id="more"></a>
<h1 id="Swift-语法基础"><a href="#Swift-语法基础" class="headerlink" title="Swift 语法基础"></a>Swift 语法基础</h1><p>Swift语法基础从以下几点来展开：</p>
<ol>
<li>循环语句</li>
<li>泛型</li>
<li>guard</li>
<li>函数</li>
<li>集合</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="循环条件的开闭区间"><a href="#循环条件的开闭区间" class="headerlink" title="循环条件的开闭区间"></a>循环条件的开闭区间</h3><p>Swift将循环的开闭区间做了语法上的简化：</p>
<h4 id="闭区间："><a href="#闭区间：" class="headerlink" title="闭区间："></a>闭区间：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// index : 1</span></div><div class="line"><span class="comment">// index : 2</span></div><div class="line"><span class="comment">// index : 3</span></div><div class="line"><span class="comment">// index : 4</span></div><div class="line"><span class="comment">// index : 5</span></div></pre></td></tr></table></figure>
<h4 id="半开闭区间："><a href="#半开闭区间：" class="headerlink" title="半开闭区间："></a>半开闭区间：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// index : 1</span></div><div class="line"><span class="comment">// index : 2</span></div><div class="line"><span class="comment">// index : 3</span></div><div class="line"><span class="comment">// index : 4</span></div></pre></td></tr></table></figure>
<h3 id="循环的升序与降序"><a href="#循环的升序与降序" class="headerlink" title="循环的升序与降序"></a>循环的升序与降序</h3><p>上面两个例子都是升序的（index从小到大），我们来看一下降序的写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> (<span class="number">1</span>..&lt;<span class="number">5</span>).reversed() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// index : 4</span></div><div class="line"><span class="comment">// index : 3</span></div><div class="line"><span class="comment">// index : 2</span></div><div class="line"><span class="comment">// index : 1</span></div></pre></td></tr></table></figure>
<blockquote>
<p>降序的应用可以在下篇的冒泡排序算法中可以看到。</p>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。</p>
<p>为了体现出泛型的意义，下面举一个例子来说明一下：</p>
<blockquote>
<p>实现这样一个功能:将传入该函数的两个参数互换。</p>
</blockquote>
<p>整型的交换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字符串的交换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoStrings</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> String, <span class="number">_</span> b: <span class="keyword">inout</span> String)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>浮点型的交换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Double, <span class="number">_</span> b: <span class="keyword">inout</span> Double)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。</p>
<p>此类问题可以使用泛型来解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。</p>
<p>泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" target="_blank" rel="external">Swift：Generics</a></p>
<h2 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h2><blockquote>
<p>guard是 swift 2.0推出的新的判断语句的用法。</p>
<p>与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃</p>
</blockquote>
<p>使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他某些操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。</p>
<p>可以用一个例子来分别使用if和guard来实现，体会二者的区别：</p>
<h3 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//money:    holding moneny (用户持有的钱数)</span></div><div class="line"><span class="comment">//price:    product price  (商品的价格)</span></div><div class="line"><span class="comment">//capacity: bag capacity   (用户用来装商品的袋子容量)</span></div><div class="line"><span class="comment">//volume:   product size   (商品的大小)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">buying1</span><span class="params">( money: Int , price: Int , capacity: Int , volume: Int)</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> money &gt;= price&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> capacity &gt;= volume&#123;</div><div class="line">            </div><div class="line">            <span class="built_in">print</span>(<span class="string">"Start buying..."</span>)</div><div class="line">            <span class="built_in">print</span>(<span class="string">"\(money-price) money left after buying."</span>)</div><div class="line">            <span class="built_in">print</span>(<span class="string">"\(capacity-volume) capacity left after buying."</span>)</div><div class="line">        </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            </div><div class="line">            <span class="built_in">print</span>(<span class="string">"No enough capacity"</span>)</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"No enough money"</span>)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的逻辑可以看出，当同时满足：</p>
<ol>
<li>用户的钱数&gt;商品价格</li>
<li>用户用来装商品的袋子容量&gt;商品的大小</li>
</ol>
<p>这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。</p>
<p>对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果：</p>
<h3 id="使用guard"><a href="#使用guard" class="headerlink" title="使用guard"></a>使用guard</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">buying2</span><span class="params">( money: Int , price: Int , capacity: Int , volume: Int)</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> money &gt;= price <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"No enough money"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> capacity &gt;= volume <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"No enough capacity"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="string">"Start buying..."</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(money-price) money after buying."</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(capacity-volume) capacity left after buying."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的实现可以看出：</p>
<ul>
<li>使用guard以后，将<code>money &lt; price</code>和<code>capacity &lt; volume</code> 这两个情况首先排除掉并填上了相应的处理代码。</li>
<li>在两个guard下面才是真正正确逻辑后的处理代码。</li>
</ul>
<p>因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。</p>
<ul>
<li>无返回值的函数</li>
<li>有返回值的函数</li>
<li>省略函数的外部参数名</li>
<li>值传递和引用传递</li>
</ul>
<h3 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a>无返回值的函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: String)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"log: \(message)!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(message: <span class="string">"memory warning"</span>)</div><div class="line"><span class="comment">// output: log: memory warning!</span></div></pre></td></tr></table></figure>
<h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logString</span><span class="params">(string: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"log: "</span> + string</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> logStr = logString(string: <span class="string">"memory warning!"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"\(logStr)"</span>)</div><div class="line"><span class="comment">// output: log: memory warning!</span></div></pre></td></tr></table></figure>
<h3 id="省略函数外部参数名"><a href="#省略函数外部参数名" class="headerlink" title="省略函数外部参数名"></a>省略函数外部参数名</h3><p>通过在函数形参前面加上<code>_</code>,可以起到在调用时省略外部参数的作用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logMessage</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"log: \(message)!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">logMessage(<span class="string">"memory warning"</span>)</div><div class="line"><span class="comment">// output: log: memory warning!</span></div></pre></td></tr></table></figure>
<p>再来看一下两个参数的情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addInt</span><span class="params">(<span class="number">_</span> a : Int ,<span class="number">_</span> b : Int)</span></span>&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"sum is \(a + b)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">addInt(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">//output : sum is 7</span></div></pre></td></tr></table></figure>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalArr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeLastInArray</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span>&#123;</div><div class="line">    array.removeLast()</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"\n============ before removing: \(originalArr)"</span>)</div><div class="line"><span class="comment">//[2, 1, 3]</span></div><div class="line"></div><div class="line">removeLastInArray(&amp;originalArr)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"============ after   removing: \(originalArr)"</span>)</div><div class="line"><span class="comment">//[2, 1]</span></div></pre></td></tr></table></figure>
<p>在这里使用的<code>inout</code>关键字就是将传入的数组改为引用传递了。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。</p>
<blockquote>
<p>这三种类型都支持泛型，也就是说里面的元素可以是整数，字符串，浮点等等。</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>Swift’s <code>Array</code> type is bridged to Foundation’s <code>NSArray</code> class.</p>
</blockquote>
<h4 id="可变数组与不可变数组"><a href="#可变数组与不可变数组" class="headerlink" title="可变数组与不可变数组"></a>可变数组与不可变数组</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// immutable array</span></div><div class="line"><span class="keyword">let</span> immutableNumbers: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment">// mutable array</span></div><div class="line"><span class="keyword">var</span> mutableNumbers : [<span class="type">Int</span>] = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p>Swift中可以用<code>let</code>和<code>var</code>来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。</p>
</blockquote>
<h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iteration 1</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> mutableNumbers &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index = mutableNumbers.index(of: value) &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Index of \(value) is \(index)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 2</span></div><div class="line">mutableNumbers.forEach &#123; value <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index = mutableNumbers.index(of: value) &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Index of \(value) is \(index)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 3</span></div><div class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> mutableNumbers.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Item \(index + 1): \(value)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mutableNumbers.append(<span class="number">11</span>)</div><div class="line"><span class="comment">// Output: [2, 1, 5, 4, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.insert(<span class="number">42</span>, at: <span class="number">4</span>)</div><div class="line"><span class="comment">// Output: [2, 1, 5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.swapAt(<span class="number">0</span>, <span class="number">1</span>)</div><div class="line"><span class="comment">// Output: [1, 2, 5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.remove(at: <span class="number">1</span>)</div><div class="line"><span class="comment">// Output: [2, 5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.removeFirst()</div><div class="line"><span class="comment">// Output: [5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.removeLast()</div><div class="line"><span class="comment">// Output: [5, 4, 42, 1, 3]</span></div><div class="line"></div><div class="line">mutableNumbers.removeAll()</div><div class="line"><span class="comment">//[]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>append函数的作用是在数组的末尾添加元素</p>
<p>swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。</p>
</blockquote>
<h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><blockquote>
<p>Swift’s <code>Set</code> type is bridged to Foundation’s <code>NSSet</code> class.</p>
</blockquote>
<h4 id="集合的无序性，值的唯一性"><a href="#集合的无序性，值的唯一性" class="headerlink" title="集合的无序性，值的唯一性"></a>集合的无序性，值的唯一性</h4><p>关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//value in set is unique</span></div><div class="line"><span class="keyword">let</span> onesSet: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"><span class="built_in">print</span>(onesSet)</div><div class="line"><span class="comment">// Output: [1]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> onesArray: <span class="type">Array</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"><span class="built_in">print</span>(onesArray)</div><div class="line"><span class="comment">// Output: [1, 1, 1, 1]</span></div></pre></td></tr></table></figure>
<h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbersSet: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="built_in">print</span>(numbersSet)</div><div class="line"><span class="comment">// Output: undefined order, e.g. [5, 2, 3, 1, 4]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// iteration 1</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> numbersSet &#123;</div><div class="line">    <span class="built_in">print</span>(value)</div><div class="line">&#125;</div><div class="line"><span class="comment">// output is in undefined order</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// iteration 2</span></div><div class="line">numbersSet.forEach &#123; value <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(value)</div><div class="line">&#125;</div><div class="line"><span class="comment">// output is in undefined order</span></div></pre></td></tr></table></figure>
<h4 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mutableStringSet: <span class="type">Set</span> = [<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>]</div><div class="line"><span class="keyword">let</span> item = <span class="string">"Two"</span></div><div class="line"></div><div class="line"><span class="comment">//contains</span></div><div class="line"><span class="keyword">if</span> mutableStringSet.<span class="built_in">contains</span>(item) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(item) found in the set"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(item) not found in the set"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//isEmpty</span></div><div class="line"><span class="keyword">let</span> strings = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">if</span> strings.isEmpty &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Set is empty"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//count</span></div><div class="line"><span class="keyword">let</span> emptyStrings = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">if</span> emptyStrings.<span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Set has no elements"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//insert</span></div><div class="line">mutableStringSet.insert(<span class="string">"Four"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//remove 1</span></div><div class="line">mutableStringSet.remove(<span class="string">"Three"</span>)</div><div class="line"></div><div class="line"><span class="comment">//remove 2</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedElement = mutableStringSet.remove(<span class="string">"Six"</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(removedElement) was removed from the Set"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Six is not found in the Set"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//removeAll()</span></div><div class="line">mutableStringSet.removeAll()</div><div class="line"><span class="comment">// []</span></div></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><blockquote>
<p>A dictionary <code>Key</code> type must conform to the <code>Hashable</code> protocol, like a set’s value type.</p>
</blockquote>
<h4 id="字典的声明"><a href="#字典的声明" class="headerlink" title="字典的声明"></a>字典的声明</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//empty dictionary</span></div><div class="line"><span class="keyword">var</span> dayOfWeek = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">var</span> dayOfWeek2 = [<span class="type">Int</span>: <span class="type">String</span>]()</div><div class="line"></div><div class="line"><span class="comment">//not empty dictionary</span></div><div class="line"><span class="keyword">var</span> dayOfWeek3: [<span class="type">Int</span>: <span class="type">String</span>] = [<span class="number">0</span>: <span class="string">"Sun"</span>, <span class="number">1</span>: <span class="string">"Mon"</span>, <span class="number">2</span>: <span class="string">"Tue"</span>]</div><div class="line"><span class="built_in">print</span>(dayOfWeek3)</div><div class="line"><span class="comment">//output:[2: "Tue", 0: "Sun", 1: "Mon"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。</p>
</blockquote>
<h4 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iteration 1</span></div><div class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dayOfWeek &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(key): \(value)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 2</span></div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dayOfWeek.keys &#123;</div><div class="line">    <span class="built_in">print</span>(key)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 3</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dayOfWeek.values &#123;</div><div class="line">    <span class="built_in">print</span>(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// find value</span></div><div class="line">dayOfWeek = [<span class="number">0</span>: <span class="string">"Sun"</span>, <span class="number">1</span>: <span class="string">"Mon"</span>, <span class="number">2</span>: <span class="string">"Tue"</span>]</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> day = dayOfWeek[<span class="number">2</span>] &#123;</div><div class="line">    <span class="built_in">print</span>(day)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// addValue 1</span></div><div class="line">dayOfWeek[<span class="number">3</span>] = <span class="string">"Wed"</span></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// updateValue 1</span></div><div class="line">dayOfWeek[<span class="number">2</span>] = <span class="string">"Mardi"</span></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Mardi", 0: "Sun", 1: "Mon", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// updateValue 2</span></div><div class="line">dayOfWeek.updateValue(<span class="string">"Tue"</span>, forKey: <span class="number">2</span>)</div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// removeValue 1</span></div><div class="line">dayOfWeek[<span class="number">1</span>] = <span class="literal">nil</span></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// removeValue 2</span></div><div class="line">dayOfWeek.removeValue(forKey: <span class="number">2</span>)</div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [0: "Sun", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// removeAll</span></div><div class="line">dayOfWeek.removeAll()</div><div class="line"></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Output: [:]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到从字典里面删除某个键值对有两个方法：</p>
<ol>
<li>使用<code>removeValue</code>方法并传入要删除的键值对里的键。</li>
<li>将字典取下标之后将nil赋给它。</li>
</ol>
</blockquote>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>这一部分内容主要是对连载的后续文章作铺垫，让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开：</p>
<ul>
<li><p>数据结构的基本概念</p>
</li>
<li><p>抽象数据类型</p>
</li>
<li><p>链表，栈和队列的实现</p>
<p>​</p>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先我们来看一下数据结构的概念：</p>
<blockquote>
<p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p>
</blockquote>
<p>由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据<strong>是如何联系起来</strong>的。</p>
<p>而这些联系，可以从两个维度来展开：</p>
<ol>
<li>逻辑结构：指数据对象中元素之间的相互关系。</li>
<li>物理结构：指数据的逻辑结构在计算机中的存储形式。</li>
</ol>
<p>可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？</p>
<p>逻辑结构：</p>
<ul>
<li>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。</li>
<li>线性结构：线性结构中的数据元素之间是一对一的关系。</li>
<li>树形结构：数据结构中的元素存在一对多的相互关系。</li>
<li>图形结构：数据结构中的元素存在多对多的相互关系。</li>
</ul>
<p>物理结构：</p>
<ul>
<li>顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。</li>
<li>链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</li>
</ul>
<p>为了便于记忆，用思维导图总结一下上面所说的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8da77739?w=501&amp;h=337&amp;f=png&amp;s=29900" alt=""></p>
<p>而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现：</p>
<p>比如线性表就是线性结构的一种实现：</p>
<ul>
<li>顺序存储结构的线性表就是<strong>数组</strong>：它的内存分布是连续的，元素之间可以通过内存地址来做关联；</li>
<li>链式存储结构的线性表就是<strong>链表</strong>：它的内存分布可以是不连续的，元素之间通过指针来做关联：<ul>
<li>如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。</li>
<li>如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。</li>
</ul>
</li>
</ul>
<p>为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？</p>
<p>对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。</p>
<p>但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。</p>
<p>而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。</p>
<blockquote>
<p>关于链表的这种插入操作会在后面用代码的形式体现出来。</p>
</blockquote>
<p>既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的<strong>抽象数据类型</strong>。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>首先来看一下抽象数据类型的概念，摘自《大话数据结构》:</p>
<blockquote>
<p>抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。</p>
</blockquote>
<p>需要注意的是：抽象数据类型的定义仅仅取决于它的一组<strong>逻辑特性</strong>，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者<strong>自己定义的数据类型</strong>。</p>
<p>我们看一下数据类型的标准格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ADT 抽象数据类型名</div><div class="line"></div><div class="line">Data</div><div class="line">   数据元素之间逻辑关系的定义</div><div class="line">   </div><div class="line">Operation</div><div class="line">   操作1</div><div class="line">      初始条件</div><div class="line">      操作结果描述</div><div class="line"> </div><div class="line">   操作2</div><div class="line">      初始条件</div><div class="line">      操作结果描述</div><div class="line">      </div><div class="line">   操作n</div><div class="line"></div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>其实看上去和面向对象编程里的类的定义相似：</p>
<ul>
<li>可以把抽象数据类型的Data 和 类的成员变量联系起来。</li>
<li>可以把抽象数据类型的操作和类的函数联系起来。</li>
</ul>
<p>简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。</p>
<p>下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。</p>
<blockquote>
<p>注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。</p>
</blockquote>
<h2 id="链表，栈和队列的实现"><a href="#链表，栈和队列的实现" class="headerlink" title="链表，栈和队列的实现"></a>链表，栈和队列的实现</h2><p>通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。</p>
<p>下面就来介绍几种在实际应用中使用的比较多的数学模型：</p>
<ul>
<li>链表</li>
<li>栈</li>
<li>队列</li>
</ul>
<h3 id="链表（Linked-list）"><a href="#链表（Linked-list）" class="headerlink" title="链表（Linked list）"></a>链表（Linked list）</h3><p>说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义：</p>
<blockquote>
<p>线性表：零个或多个数据元素的有限序列。</p>
</blockquote>
<p>而根据物理结构的不同，线性表有两种具体的实现方式：</p>
<ul>
<li>线性表的顺序存储结构：线性表的数据元素是被一段<strong>地址连续</strong>的存储单存储起来的。</li>
<li>线性表的链式存储结构: 线性表的数据元素是被用一组<strong>连续或不连续</strong>的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。</li>
</ul>
<blockquote>
<p>注：上面两个概念是笔者用自己的话总结出来的。</p>
</blockquote>
<p>在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。</p>
<h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><p>相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义：</p>
<blockquote>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
</blockquote>
<p>而且由于数据元素所持有的指针个数和链接特性可以将链表分为：</p>
<ul>
<li>单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点；</li>
<li>双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。</li>
<li>循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。</li>
</ul>
<p>笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。</p>
<h4 id="双向链表的抽象数据类型"><a href="#双向链表的抽象数据类型" class="headerlink" title="双向链表的抽象数据类型"></a>双向链表的抽象数据类型</h4><p>因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。</p>
<p>节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ADT 节点(node)</div><div class="line"></div><div class="line">Data</div><div class="line">  value:持有的数据</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   previous:指向上一节点的指针</div><div class="line">   next:指向下一节点的指针</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>再来看一下链表的抽象数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ADT 链表（linked list）</div><div class="line"></div><div class="line">Data</div><div class="line">  linked list:持有的线性表</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   count:持有节点总个数</div><div class="line">   isEmpty:是否为空</div><div class="line">   first:头节点</div><div class="line">   last:尾节点</div><div class="line">   node:传入index返回节点</div><div class="line">   insert:插入node到指定index</div><div class="line">   insertToHead:插入节点到表头</div><div class="line">   appendToTail:插入节点到表尾</div><div class="line">   removeAll:移除所有节点</div><div class="line">   remove:移除传入的节点</div><div class="line">   removeAt:移除传入index的节点</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<h4 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h4><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//value of a node</span></div><div class="line">    <span class="keyword">var</span> value: <span class="type">T</span></div><div class="line">  </div><div class="line">   <span class="comment">//pointer to previous node</span></div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> previous: <span class="type">LinkedListNode</span>?</div><div class="line">  </div><div class="line">    <span class="comment">//pointer to next node</span></div><div class="line">    <span class="keyword">var</span> next: <span class="type">LinkedListNode</span>?</div><div class="line">  </div><div class="line">    </div><div class="line">    <span class="comment">//init</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.value = value</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下链表的实现：</p>
<p>因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。</p>
<p>首先看一下链表的成员变量:</p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> = <span class="type">LinkedListNode</span>&lt;<span class="type">T</span>&gt;</div><div class="line">    </div><div class="line">    <span class="comment">//if empty</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> head == <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//total count of nodes</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">      </div><div class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</div><div class="line">            node = next</div><div class="line">            <span class="built_in">count</span> += <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointer to the first node, private</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> head: <span class="type">Node</span>?</div><div class="line">    </div><div class="line">    <span class="comment">//pointer to the first node, public</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Node</span>? &#123;</div><div class="line">        <span class="keyword">return</span> head</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointer to the last node</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> last: <span class="type">Node</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//until node.next is nil</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</div><div class="line">            node = next</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点：</p>
<ol>
<li><code>typealias</code>是用来重新为已经存在的类型命名的：这里用<code>Node</code>代替了<code>LinkedListNode&lt;T&gt;</code>（节点类型），降低了不少阅读代码的成本。</li>
<li>在获取<code>count</code>和<code>last</code>的实现，都先判断了<code>head</code>这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。</li>
<li>同样地，也是在获取<code>count</code>和<code>last</code>的实现里，使用了<code>while</code>控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。</li>
</ol>
<blockquote>
<p>最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的<code>LinkedList</code>这个class里面。</p>
</blockquote>
<h5 id="获取index上node"><a href="#获取index上node" class="headerlink" title="获取index上node"></a>获取index上node</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get node of index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">node</span><span class="params">(atIndex index: Int)</span></span> -&gt; <span class="type">Node</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</div><div class="line">        <span class="comment">//head node</span></div><div class="line">        <span class="keyword">return</span> head!</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> node = head!.next</div><div class="line"></div><div class="line">        <span class="keyword">guard</span> index &lt; <span class="built_in">count</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;index &#123;</div><div class="line">            <span class="comment">// go on finding by .next</span></div><div class="line">            node = node?.next</div><div class="line">            <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> node!</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。</p>
<h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//insert node to last index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">appendToTail</span><span class="params">(value: T)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newNode = <span class="type">Node</span>(value: value)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastNode = last &#123;</div><div class="line"></div><div class="line">        <span class="comment">//update last node: newNode becomes new last node;</span></div><div class="line">        <span class="comment">//the previous last node becomes the second-last node</span></div><div class="line">        newNode.previous = lastNode</div><div class="line">        lastNode.next = newNode</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">//blank linked list</span></div><div class="line">        head = newNode</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//insert node to index 0</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insertToHead</span><span class="params">(value: T)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newHead = <span class="type">Node</span>(value: value)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">//blank linked list</span></div><div class="line">        head = newHead</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        newHead.next = head</div><div class="line">        head?.previous = newHead</div><div class="line">        head = newHead</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//insert node in specific index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> node: Node, atIndex index: Int)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"invalid input index"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newNode = node</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line"></div><div class="line">        head = newNode</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</div><div class="line"></div><div class="line">            newNode.next = head</div><div class="line">            head?.previous = newNode</div><div class="line">            head = newNode</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> index &gt; <span class="built_in">count</span> &#123;</div><div class="line"></div><div class="line">                <span class="built_in">print</span>(<span class="string">"out of range"</span>)</div><div class="line">                <span class="keyword">return</span></div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> prev = <span class="keyword">self</span>.node(atIndex: index-<span class="number">1</span>)</div><div class="line">            <span class="keyword">let</span> next = prev?.next</div><div class="line"></div><div class="line">            newNode.previous = prev</div><div class="line">            newNode.next = prev?.next</div><div class="line">            prev?.next = newNode</div><div class="line">            next?.previous = newNode</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>链表的插入节点的操作分为三种，按照从上到下的顺序依次是：</p>
<ol>
<li>在头部插入</li>
<li>在尾部插入</li>
<li>指定index插入</li>
</ol>
<p>需要注意的是</p>
<ul>
<li>在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的<code>head</code>指针。</li>
<li>在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。</li>
</ul>
<blockquote>
<p>在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。</p>
</blockquote>
<h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//removing all nodes</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">()</span></span> &#123;</div><div class="line">    head = <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//remove the last node</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeLast</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> !isEmpty <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> remove(node: last!)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//remove a node by it's refrence</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(node: Node)</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> prev = node.previous</div><div class="line">    <span class="keyword">let</span> next = node.next</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> prev = prev &#123;</div><div class="line">        prev.next = next</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        head = next</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    next?.previous = prev</div><div class="line"></div><div class="line">    node.previous = <span class="literal">nil</span></div><div class="line">    node.next = <span class="literal">nil</span></div><div class="line">    <span class="keyword">return</span> node.value</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//remove a node by it's index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAt</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">self</span>.node(atIndex: index)</div><div class="line">    <span class="keyword">guard</span> node == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> remove(node: node!)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。</li>
<li>在持有某个节点的指针的时候可以指定链表来移除这个节点（使用<code>remove</code>函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。</li>
<li>当有要移除节点的指针但是知道该节点在链表中的index，可以使用<code>removeAt</code>函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用<code>remove</code>函数删除这个node。</li>
</ul>
<h5 id="打印所有节点"><a href="#打印所有节点" class="headerlink" title="打印所有节点"></a>打印所有节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllNodes</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> node = head</div><div class="line"></div><div class="line">    <span class="built_in">print</span>(<span class="string">"\nstart printing all nodes:"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">print</span>(<span class="string">"[\(index)]\(node!.value)"</span>)</div><div class="line">        node = node!.next</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。</p>
<p>为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list = <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">list.isEmpty   <span class="comment">// true</span></div><div class="line">list.first     <span class="comment">// nil</span></div><div class="line">list.<span class="built_in">count</span>     <span class="comment">// 0</span></div><div class="line"></div><div class="line">list.appendToTail(value: <span class="string">"Swift"</span>)</div><div class="line">list.isEmpty         <span class="comment">// false</span></div><div class="line">list.first!.value    <span class="comment">// "Swift"</span></div><div class="line">list.last!.value     <span class="comment">// "Swift"</span></div><div class="line">list.<span class="built_in">count</span>           <span class="comment">//1</span></div><div class="line"></div><div class="line">list.appendToTail(value:<span class="string">"is"</span>)</div><div class="line">list.first!.value    <span class="comment">// "Swift"</span></div><div class="line">list.last!.value     <span class="comment">// "is"</span></div><div class="line">list.<span class="built_in">count</span>           <span class="comment">// 2</span></div><div class="line"></div><div class="line">list.appendToTail(value:<span class="string">"great"</span>)</div><div class="line">list.first!.value    <span class="comment">// "Swift"</span></div><div class="line">list.last!.value     <span class="comment">// "great"</span></div><div class="line">list.<span class="built_in">count</span>           <span class="comment">// 3</span></div><div class="line"></div><div class="line"></div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]Swift</span></div><div class="line"><span class="comment">//[1]is</span></div><div class="line"><span class="comment">//[2]Great</span></div><div class="line"></div><div class="line">list.node(atIndex: <span class="number">0</span>)?.value <span class="comment">// Swift</span></div><div class="line">list.node(atIndex: <span class="number">1</span>)?.value <span class="comment">// is</span></div><div class="line">list.node(atIndex: <span class="number">2</span>)?.value <span class="comment">// great</span></div><div class="line">list.node(atIndex: <span class="number">3</span>)?.value <span class="comment">// nil</span></div><div class="line"></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"language"</span>), atIndex: <span class="number">1</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]Swift</span></div><div class="line"><span class="comment">//[1]language</span></div><div class="line"><span class="comment">//[2]is</span></div><div class="line"><span class="comment">//[3]great</span></div><div class="line"></div><div class="line"></div><div class="line">list.remove(node: list.first!)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]language</span></div><div class="line"><span class="comment">//[1]is</span></div><div class="line"><span class="comment">//[2]great</span></div><div class="line"></div><div class="line"></div><div class="line">list.removeAt(<span class="number">1</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]language</span></div><div class="line"><span class="comment">//[1]great</span></div><div class="line"></div><div class="line">list.removeLast()</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]language</span></div><div class="line"></div><div class="line">list.insertToHead(value: <span class="string">"study"</span>)</div><div class="line">list.<span class="built_in">count</span>             <span class="comment">// 2</span></div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]study</span></div><div class="line"><span class="comment">//[1]language</span></div><div class="line"></div><div class="line"></div><div class="line">list.removeAll()</div><div class="line">list.printAllNodes()<span class="comment">//linked list is empty</span></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">3</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]new</span></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">3</span>) <span class="comment">//out of range</span></div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]new</span></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">1</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]new</span></div><div class="line"><span class="comment">//[1]new</span></div></pre></td></tr></table></figure>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈的讲解从</p>
<ul>
<li>栈的定义</li>
<li>栈的抽象数据类型</li>
<li>栈的实现</li>
</ul>
<p>三个部分来展开。</p>
<h4 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h4><p>首先来看一下栈的定义：</p>
<blockquote>
<p>栈是限定仅在表的尾部进行插入和删除操作的线性表。</p>
</blockquote>
<p>从定义中可以看出，我们知道我们只能在栈的一端来操作栈：</p>
<ul>
<li>允许插入和删除的一端成为栈顶</li>
<li>另一端成为栈底</li>
</ul>
<p>用一张图来看一下栈的操作：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8db5eaf6?w=618&amp;h=432&amp;f=png&amp;s=73000" alt=""></p>
<blockquote>
<p>图源：《维基百科：Stack (abstract data type)》</p>
</blockquote>
<p>从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。</p>
<h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ADT 栈（Stack）</div><div class="line"></div><div class="line">Data</div><div class="line">  linked list:持有的线性表</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   count:栈的元素个数</div><div class="line">   isEmpty:是否为空</div><div class="line">   push:入栈</div><div class="line">   pop:出栈</div><div class="line">   top:返回顶部元素</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。</p>
<h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//array</span></div><div class="line">    fileprivate <span class="keyword">var</span> stackArray = [<span class="type">T</span>]()</div><div class="line">    </div><div class="line">    <span class="comment">//count</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> stackArray.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//is empty ?</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> stackArray.isEmpty</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//top element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">T</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> isEmpty&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> stackArray.last</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//push operation</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</div><div class="line">        stackArray.append(element)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//pop operation</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> isEmpty&#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"stack is empty"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> stackArray.removeLast()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//print all</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllElements</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"stack is empty"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"\nprint all stack elemets:"</span>)</div><div class="line">        <span class="keyword">for</span> (index, value) <span class="keyword">in</span> stackArray.enumerated() &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"[\(index)]\(value)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>fileprivate</code>：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的<code>private</code>。而有了<code>fileprivate</code>以后，新的<code>private</code>则代表了真正的私有：在这个类或结构体的外部无法访问。</li>
<li>这里<code>printAllElements</code>方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。</li>
</ul>
<p>我们来实例化上面定义的栈实际操作一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stack = <span class="type">Stack</span>.<span class="keyword">init</span>(stackArray: [])</div><div class="line">stack.printAllElements() <span class="comment">//stack is empty</span></div><div class="line">stack.isEmpty <span class="comment">//true</span></div><div class="line"></div><div class="line">stack.push(<span class="number">2</span>)</div><div class="line">stack.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"></div><div class="line">stack.isEmpty <span class="comment">//false</span></div><div class="line">stack.top     <span class="comment">//2</span></div><div class="line"></div><div class="line"></div><div class="line">stack.push(<span class="number">3</span>)</div><div class="line">stack.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"><span class="comment">//[1]3</span></div><div class="line"></div><div class="line">stack.isEmpty <span class="comment">//false</span></div><div class="line">stack.top     <span class="comment">//3</span></div><div class="line"></div><div class="line"></div><div class="line">stack.pop()</div><div class="line">stack.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"></div><div class="line">stack.isEmpty <span class="comment">//false</span></div><div class="line">stack.top     <span class="comment">//2</span></div><div class="line"></div><div class="line"></div><div class="line">stack.pop()</div><div class="line">stack.printAllElements() <span class="comment">//stack is empty</span></div><div class="line">stack.top <span class="comment">//nil</span></div><div class="line">stack.isEmpty <span class="comment">//true</span></div><div class="line"></div><div class="line">stack.pop() <span class="comment">//stack is empty</span></div></pre></td></tr></table></figure>
<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列的讲解从</p>
<ul>
<li>队列的定义</li>
<li>队列的抽象数据类型</li>
<li>队列的实现</li>
</ul>
<p>三个部分来展开。</p>
<h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8db00b50?w=618&amp;h=432&amp;f=png&amp;s=95179" alt=""></p>
<blockquote>
<p>图源：《维基百科：FIFO (computing and electronics)》</p>
</blockquote>
<h4 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ADT 队列（Queue）</div><div class="line"></div><div class="line">Data</div><div class="line">  linked list:持有的线性表</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   count:栈的元素个数</div><div class="line">   isEmpty:是否为空</div><div class="line">   front:获取队列头元素</div><div class="line">   enqueue:插入到队尾</div><div class="line">   dequeue:删除队列头元素并返回</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。</p>
<h4 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//array</span></div><div class="line">    fileprivate <span class="keyword">var</span> queueArray = [<span class="type">T</span>]()</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//count</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> queueArray.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//is empty?</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> queueArray.isEmpty</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//front element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> front: <span class="type">T</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> isEmpty &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> queueArray.first</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//add element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</div><div class="line">        queueArray.append(element)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//remove element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        <span class="keyword">if</span> isEmpty &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> queueArray.removeFirst()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//print all</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllElements</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"\nprint all queue elemets:"</span>)</div><div class="line">        <span class="keyword">for</span> (index, value) <span class="keyword">in</span> queueArray.enumerated() &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"[\(index)]\(value)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们初始化一个队列后实际操作一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> queue = <span class="type">Queue</span>.<span class="keyword">init</span>(queueArray: [])</div><div class="line">queue.printAllElements()<span class="comment">//queue is empty</span></div><div class="line">queue.isEmpty <span class="comment">//true</span></div><div class="line">queue.<span class="built_in">count</span>   <span class="comment">//0</span></div><div class="line"></div><div class="line"></div><div class="line">queue.enqueue(<span class="number">2</span>)</div><div class="line">queue.printAllElements()</div><div class="line">queue.isEmpty  <span class="comment">//false</span></div><div class="line"><span class="comment">//[0]2</span></div><div class="line"></div><div class="line">queue.enqueue(<span class="number">3</span>)</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"><span class="comment">//[1]3</span></div><div class="line"></div><div class="line"></div><div class="line">queue.enqueue(<span class="number">4</span>)</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"><span class="comment">//[1]3</span></div><div class="line"><span class="comment">//[2]4</span></div><div class="line">queue.front <span class="comment">//2</span></div><div class="line"></div><div class="line"></div><div class="line">queue.dequeue()</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]3</span></div><div class="line"><span class="comment">//[1]4</span></div><div class="line">queue.front <span class="comment">//3</span></div><div class="line"></div><div class="line"></div><div class="line">queue.dequeue()</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]4</span></div><div class="line">queue.front <span class="comment">//4</span></div><div class="line"></div><div class="line">queue.dequeue()</div><div class="line">queue.printAllElements() <span class="comment">//queue is empty</span></div><div class="line">queue.front <span class="comment">//return nil, and print : queue is empty</span></div><div class="line">queue.isEmpty <span class="comment">//true</span></div><div class="line">queue.<span class="built_in">count</span><span class="comment">//0</span></div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>这两周学习数据结构和算法让我收获很多，除了强化了Swift语法以外，感觉自己看代码的感觉变了：看到一个设计就会想到里面所用到的数据结构，或是算法上面有没有可以优化的可能等等。</p>
<p>我相信对我来说编程的一扇新的门被打开了，希望自己可以坚持下去～</p>
<p>该系列的所有代码会放在我的GitHub的一个项目里面，项目地址：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift">Github:data-structure-and-algorithm-in-Swift</a></p>
<p>本篇文章的代码：</p>
<ul>
<li>Swift语法部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B1%5D.Swift%20syntax">[1].Swift syntax</a></li>
<li>数据结构部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B2%5D.Data%20structure">[2].Data structure</a></li>
</ul>
<p>下篇预告：</p>
<p>从下一篇会开始正式讲解算法。本系列第二篇的主题是<strong>排序算法</strong>，内容是用Swift语言实现并讲解几种比较常见的排序算法：冒泡排序，选择排序，插入排序，希尔排序，堆排序，快速排序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/da_header_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;从本文标题中的序号可以看出，本文是一个连载的开篇。&lt;/p&gt;
&lt;p&gt;而且这个连载的标题是：数据结构 &amp;amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：&lt;/p&gt;
&lt;h2 id=&quot;第一：为什么学习数据结构和算法？&quot;&gt;&lt;a href=&quot;#第一：为什么学习数据结构和算法？&quot; class=&quot;headerlink&quot; title=&quot;第一：为什么学习数据结构和算法？&quot;&gt;&lt;/a&gt;第一：为什么学习数据结构和算法？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;学习通用性知识，突破技能瓶颈&lt;/strong&gt;：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。&lt;/p&gt;
&lt;h2 id=&quot;第二：为什么用Swift语言来实现？&quot;&gt;&lt;a href=&quot;#第二：为什么用Swift语言来实现？&quot; class=&quot;headerlink&quot; title=&quot;第二：为什么用Swift语言来实现？&quot;&gt;&lt;/a&gt;第二：为什么用Swift语言来实现？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择哪个语言并不重要，重要的是数据结构和算法本身的理解&lt;/strong&gt;：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如今Swift的势头还在上涨&lt;/strong&gt;：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于上面这些原因，在今年年初把&lt;strong&gt;数据结构，算法和Swift&lt;/strong&gt;的学习提上了日程，并且计划以连载的形式把学习过程中的笔记和知识分享出来。&lt;/p&gt;
&lt;p&gt;该系列的&lt;strong&gt;最佳受众&lt;/strong&gt;是那些已经会Swift，但是对数据结构和算法还没有过多接触过的iOS开发者。其次是那些不会Swift也不会数据结构和算法的iOS开发者，毕竟Swift是大势所趋。&lt;/p&gt;
&lt;p&gt;不过对于那些非iOS开发者来说也同样适合，因为还是那句话：&lt;strong&gt;重点不在于使用哪种语言，而是数据结构和算法本身&lt;/strong&gt;。除了第一篇会讲解一些在这个系列文章会使用到的Swift基础语法以外，后续的文章我会逐渐&lt;strong&gt;弱化对Swift语言的讲解，将重点放在数据结构和算法这里&lt;/strong&gt;。而且后续我还会不断增加其他语言的实现（Java语言是肯定要加的，其他的语言还待定）。&lt;/p&gt;
&lt;p&gt;好了，背景介绍完了，现在正式开始：&lt;/p&gt;
&lt;p&gt;作为该系列的开篇，本文分为两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Swift语法基&lt;/strong&gt;础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据结构&lt;/strong&gt;：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注：该系列涉及到的Swift语法最低基于Swift4.0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://github.com/knightsj/knightsj.github.io/tags/Swift/"/>
    
      <category term="Data Structure" scheme="https://github.com/knightsj/knightsj.github.io/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>YYCache 源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/01/23/YYCache%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/01/23/YYCache 源码解析/</id>
    <published>2018-01-23T00:37:36.671Z</published>
    <updated>2018-01-29T00:45:49.879Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ibireme/YYCache">YYCache</a>是国内开发者<a href="https://blog.ibireme.com/" target="_blank" rel="external">ibireme</a>开源的一个线程安全的高性能键值缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。</p>
<p>阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。</p>
<p>在正式开始讲解源码之前，先简单看一下该框架的使用方法。</p>
<h1 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h1><p>举一个缓存用户姓名的例子来看一下YYCache的几个API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//需要缓存的对象</span></div><div class="line"> <span class="built_in">NSString</span> *userName = <span class="string">@"Jack"</span>;</div><div class="line"></div><div class="line"><span class="comment">//需要缓存的对象在缓存里对应的键</span></div><div class="line"> <span class="built_in">NSString</span> *key = <span class="string">@"user_name"</span>;</div><div class="line"> </div><div class="line"> <span class="comment">//创建一个YYCache实例:userInfoCache</span></div><div class="line"> YYCache *userInfoCache = [YYCache cacheWithName:<span class="string">@"userInfo"</span>];</div><div class="line"> </div><div class="line"> <span class="comment">//存入键值对</span></div><div class="line"> [userInfoCache setObject:userName forKey:key withBlock:^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"caching object succeed"</span>);</div><div class="line"> &#125;];</div><div class="line"> </div><div class="line"> <span class="comment">//判断缓存是否存在</span></div><div class="line"> [userInfoCache containsObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="built_in">BOOL</span> contains) &#123;</div><div class="line">     <span class="keyword">if</span> (contains)&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"object exists"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> <span class="comment">//根据key读取数据</span></div><div class="line"> [userInfoCache objectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;  _Nonnull object) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"user name : %@"</span>,object);</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> <span class="comment">//根据key移除缓存</span></div><div class="line"> [userInfoCache removeObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"remove user name %@"</span>,key);</div><div class="line"> &#125;];</div><div class="line"> </div><div class="line"> <span class="comment">//移除所有缓存</span></div><div class="line"> [userInfoCache removeAllObjectsWithBlock:^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"removing all cache succeed"</span>);</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> <span class="comment">//移除所有缓存带进度</span></div><div class="line"> [userInfoCache removeAllObjectsWithProgressBlock:^(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: removedCount :%d  totalCount : %d"</span>,removedCount,totalCount);</div><div class="line"> &#125; endBlock:^(<span class="built_in">BOOL</span> error) &#123;</div><div class="line">     <span class="keyword">if</span>(!error)&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: succeed"</span>);</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: failed"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>总体来看这些API与<code>NSCache</code>是差不多的。<br>下面接着看一下该框架的架构：</p>
<h1 id="架构与职责划分"><a href="#架构与职责划分" class="headerlink" title="架构与职责划分"></a>架构与职责划分</h1><p>首先看一下架构图：</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5bd7907?w=604&amp;h=344&amp;f=png&amp;s=21874" alt=""></p>
<h2 id="职责划分"><a href="#职责划分" class="headerlink" title="职责划分"></a>职责划分</h2><p>从架构图上来看，该组件里面的成员并不多：</p>
<ul>
<li>YYCache：提供了最外层的接口，调用了YYMemoryCache与YYDiskCache的相关方法。</li>
<li>YYMemoryCache：负责处理容量小，相对高速的内存缓存。线程安全，支持自动和手动清理缓存等功能。</li>
<li>_YYLinkedMap：YYMemoryCache使用的双向链表类。</li>
<li>_YYLinkedMapNode：是_YYLinkedMap使用的节点类。</li>
<li>YYDiskCache：负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作，自动和手动清理缓存等功能。</li>
<li>YYKVStorage：YYDiskCache的底层实现类，用于管理磁盘缓存。</li>
<li>YYKVStorageItem：内置在YYKVStorage中，是YYKVStorage内部用于封装某个缓存的类。</li>
</ul>
<p>每个成员的详细的功能会在下文结合代码介绍。</p>
<a id="more"></a>
<h1 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h1><p>知道了YYCache的架构和职责划分以后，现在结合代码开始正式讲解。<br>讲解分为下面6个部分：</p>
<ul>
<li>YYCache</li>
<li>YYMemoryCache</li>
<li>YYDiskCache</li>
<li>保证线程安全的不同方案</li>
<li>提高缓存性能的几个尝试</li>
<li>其他知识点</li>
</ul>
<h2 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h2><p>YYCache给用户提供所有最外层的缓存操作接口，而这些接口的内部内部实际上是调用了YYMemoryCache和YYDiskCache对象的相关方法。</p>
<blockquote>
<p>因为YYMemoryCache和YYDiskCache的实例作为YYCache的两个公开的属性，所以用户<strong>无法直接使用YYMemoryCache和YYDiskCache对象</strong>，只能通过属性的方式来间接使用它们。</p>
</blockquote>
<p>我们来看一下YYCache的属性和接口：</p>
<h3 id="YYCache的属性和接口"><a href="#YYCache的属性和接口" class="headerlink" title="YYCache的属性和接口"></a>YYCache的属性和接口</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;<span class="comment">//缓存名称</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;<span class="comment">//内存缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;<span class="comment">//磁盘缓存</span></div><div class="line"></div><div class="line"><span class="comment">//是否包含某缓存，无回调</span></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//是否包含某缓存，有回调</span></div><div class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</div><div class="line"></div><div class="line"><span class="comment">//获取缓存对象，无回调</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//获取缓存对象，有回调</span></div><div class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存对象，无回调</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//写入缓存对象，有回调</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line"><span class="comment">//移除某缓存，无回调</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//移除某缓存，有回调</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</div><div class="line"></div><div class="line"><span class="comment">//移除所有缓存，无回调</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects;</div><div class="line"><span class="comment">//移除所有缓存，有回调</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"><span class="comment">//移除所有缓存，有进度和完成的回调</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</div><div class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从上面的接口可以看出YYCache的接口和NSCache很相近，而且在接口上都区分了有无回调的功能。<br>下面结合代码看一下这些接口是如何实现的：</p>
<h3 id="YYCache的接口实现"><a href="#YYCache的接口实现" class="headerlink" title="YYCache的接口实现"></a>YYCache的接口实现</h3><p>下面省略了带有回调的接口，因为与无回调的接口非常接近。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//先检查内存缓存是否存在，再检查磁盘缓存是否存在</span></div><div class="line">    <span class="keyword">return</span> [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//首先尝试获取内存缓存，然后获取磁盘缓存</span></div><div class="line">    <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object = [_memoryCache objectForKey:key];</div><div class="line">    </div><div class="line">    <span class="comment">//如果内存缓存不存在，就会去磁盘缓存里面找：如果找到了，则再次写入内存缓存中；如果没找到，就返回nil</span></div><div class="line">    <span class="keyword">if</span> (!object) &#123;</div><div class="line">        object = [_diskCache objectForKey:key];</div><div class="line">        <span class="keyword">if</span> (object) &#123;</div><div class="line">            [_memoryCache setObject:object forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">//先写入内存缓存，后写入磁盘缓存</span></div><div class="line">    [_memoryCache setObject:object forKey:key];</div><div class="line">    [_diskCache setObject:object forKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">//先移除内存缓存，后移除磁盘缓存</span></div><div class="line">    [_memoryCache removeObjectForKey:key];</div><div class="line">    [_diskCache removeObjectForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</div><div class="line">    <span class="comment">//先全部移除内存缓存，后全部移除磁盘缓存</span></div><div class="line">    [_memoryCache removeAllObjects];</div><div class="line">    [_diskCache removeAllObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的接口实现可以看出：在YYCache中，永远都是先访问内存缓存，然后再访问磁盘缓存（包括了写入，读取，查询，删除缓存的操作）。而且关于内存缓存（_memoryCache）的操作，是不存在block回调的。</p>
<p>现在了解了YYCache的接口以及实现，下面我分别讲解一下YYMemoryCache（内存缓存）和YYDiskCache（磁盘缓存）这两个类。</p>
<h2 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h2><p>YYMemoryCache负责处理容量小，相对高速的内存缓存：它将需要缓存的对象与传入的key关联起来，操作类似于NSCache。</p>
<p>但是与NSCache不同的是，YYMemoryCache的内部有：</p>
<ul>
<li>缓存淘汰算法：使用LRU(least-recently-used) 算法来淘汰（清理）使用频率较低的缓存。</li>
<li>缓存清理策略：使用三个维度来标记，分别是count（缓存数量），cost（开销），age（距上一次的访问时间）。YYMemoryCache提供了分别针对这三个维度的清理缓存的接口。用户可以根据不同的需求（策略）来清理在某一维度超标的缓存。</li>
</ul>
<p>一个是淘汰算法，另一个是清理维度，乍一看可能没什么太大区别。我在这里先简单区分一下：</p>
<p>缓存淘汰算法的目的在于区分出使用频率高和使用频率低的缓存，当缓存数量达到一定限制的时候会优先清理那些使用频率低的缓存。<strong>因为使用频率已经比较低的缓存在将来的使用频率也很有可能会低</strong>。</p>
<p>缓存清理维度是给每个缓存添加的标记：</p>
<ul>
<li><p>如果用户需要删除age（距上一次的访问时间）超过1天的缓存，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始查找，直到所有距上一次的访问时间超过1天的缓存都清理掉为止。</p>
</li>
<li><p>如果用户需要将缓存总开销清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</p>
</li>
<li><p>如果用户需要将缓存总数清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</p>
</li>
</ul>
<p>可以看出，无论是以哪个维度来清理缓存，都是从缓存使用频率最低的那个缓存开始清理。而YYMemoryCache保留的所有缓存的使用频率的高低，是由LRU这个算法决定的。</p>
<p>现在知道了这二者的区别，下面来具体讲解一下缓存淘汰算法和缓存清理策略：</p>
<h3 id="YYMemoryCache的缓存淘汰算法"><a href="#YYMemoryCache的缓存淘汰算法" class="headerlink" title="YYMemoryCache的缓存淘汰算法"></a>YYMemoryCache的缓存淘汰算法</h3><p>在详细讲解这个算法之前我觉得有必要先说一下该算法的核心：</p>
<p>我个人认为LRU缓存替换策略的核心在于<strong>如果某个缓存访问的频率越高，就认定用户在将来越有可能访问这个缓存</strong>。<br>所以在这个算法中，将那些最新访问（写入），最多次被访问的缓存移到最前面，然后那些很早之前写入，不经常访问的缓存就被自动放在了后面。这样一来，在保留的缓存个数一定的情况下，留下的缓存都是访问频率比较高的，这样一来也就提升了缓存的命中率。谁都不想留着一些很难被用户再次访问的缓存，毕竟缓存本身也占有一定的资源不是么？</p>
<p>其实这个道理和一些商城类app的商品推荐逻辑是一样的：<br>如果首页只能展示10个商品，对于一个程序员用户来说，可能推荐的是于那些他最近购买商品类似的机械键盘鼠标，技术书籍或者显示屏之类的商品，而不是一些洋娃娃或是钢笔之类的商品。</p>
<p>那么LRU算法具体是怎么做的呢？</p>
<p>在YYMemoryCache中，使用了双向链表这个数据结构来保存这些缓存：</p>
<ul>
<li>当写入一个新的缓存时，要把这个缓存节点放在链表头部，并且并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li>
<li>当访问一个已有的缓存时，要把这个缓存节点移动到链表头部，原位置两侧的缓存要接上，并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li>
<li>（根据清理维度）自动清理缓存时，要从链表的最后端逐个清理。</li>
</ul>
<p>这样一来，就可以保证链表前端的缓存是最近写入过和经常访问过的。而且该算法总是从链表的最后端删除缓存，这也就保证了留下的都是一些“比较新鲜的”缓存。</p>
<p>下面结合代码来讲解一下这个算法的实现：</p>
<p>YYMemoryCache<strong>用一个链表节点类来保存某个单独的内存缓存的信息（键，值，缓存时间等），然后用一个双向链表类来保存和管理这些节点</strong>。这两个类的名称分别是：</p>
<ul>
<li>_YYLinkedMapNode：链表内的节点类，可以看做是对某个单独内存缓存的封装。</li>
<li>_YYLinkedMap：双向链表类，用于保存和管理所有内存缓存(节点)</li>
</ul>
<h4 id="YYLinkedMapNode"><a href="#YYLinkedMapNode" class="headerlink" title="_YYLinkedMapNode"></a>_YYLinkedMapNode</h4><p>_YYLinkedMapNode可以被看做是对某个缓存的封装：它包含了该节点上一个和下一个节点的指针，以及缓存的key和对应的值（对象），还有该缓存的开销和访问时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">@package</span></div><div class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// retained by dic</span></div><div class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// retained by dic</span></div><div class="line">    <span class="keyword">id</span> _key;              		  <span class="comment">//缓存key</span></div><div class="line">    <span class="keyword">id</span> _value;              	          <span class="comment">//key对应值</span></div><div class="line">    <span class="built_in">NSUInteger</span> _cost;                     <span class="comment">//缓存开销</span></div><div class="line">    <span class="built_in">NSTimeInterval</span> _time;                 <span class="comment">//访问时间</span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYLinkedMapNode</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>下面看一下双向链表类：</p>
<h4 id="YYLinkedMap"><a href="#YYLinkedMap" class="headerlink" title="_YYLinkedMap"></a>_YYLinkedMap</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">@package</span></div><div class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; 	<span class="comment">// 用于存放节点</span></div><div class="line">    <span class="built_in">NSUInteger</span> _totalCost;   		<span class="comment">//总开销</span></div><div class="line">    <span class="built_in">NSUInteger</span> _totalCount;  		<span class="comment">//节点总数</span></div><div class="line">    _YYLinkedMapNode *_head;            <span class="comment">// 链表的头部结点</span></div><div class="line">    _YYLinkedMapNode *_tail; 		<span class="comment">// 链表的尾部节点</span></div><div class="line">    <span class="built_in">BOOL</span> _releaseOnMainThread; 	        <span class="comment">//是否在主线程释放，默认为NO</span></div><div class="line">    <span class="built_in">BOOL</span> _releaseAsynchronously; 	<span class="comment">//是否在子线程释放，默认为YES</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在链表头部插入某节点</span></div><div class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</div><div class="line"></div><div class="line"><span class="comment">//将链表内部的某个节点移到链表头部</span></div><div class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</div><div class="line"></div><div class="line"><span class="comment">//移除某个节点</span></div><div class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node;</div><div class="line"></div><div class="line"><span class="comment">//移除链表的尾部节点并返回它</span></div><div class="line">- (_YYLinkedMapNode *)removeTailNode;</div><div class="line"></div><div class="line"><span class="comment">//移除所有节点（默认在子线程操作）</span></div><div class="line">- (<span class="keyword">void</span>)removeAll;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从链表类的属性上看：链表类内置了CFMutableDictionaryRef，用于保存节点的键值对，它还持有了链表内节点的总开销，总数量，头尾节点等数据。</p>
<p>可以参考下面这张图来看一下二者的关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5e027e5?w=1001&amp;h=333&amp;f=png&amp;s=34319" alt=""></p>
<p>看一下_YYLinkedMap的接口的实现：</p>
<p>将节点插入到链表头部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//设置该node的值</span></div><div class="line">    <span class="built_in">CFDictionarySetValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node));</div><div class="line">    </div><div class="line">    <span class="comment">//增加开销和总缓存数量</span></div><div class="line">    _totalCost += node-&gt;_cost;</div><div class="line">    _totalCount++;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_head) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果链表内已经存在头节点，则将这个头节点赋给当前节点的尾指针（原第一个节点变成了现第二个节点）</span></div><div class="line">        node-&gt;_next = _head;</div><div class="line">        </div><div class="line">        <span class="comment">//将该节点赋给现第二个节点的头指针（此时_head指向的节点是先第二个节点）</span></div><div class="line">        _head-&gt;_prev = node;</div><div class="line">        </div><div class="line">        <span class="comment">//将该节点赋给链表的头结点指针（该节点变成了现第一个节点）</span></div><div class="line">        _head = node;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果链表内没有头结点，说明是空链表。说明是第一次插入，则将链表的头尾节点都设置为当前节点</span></div><div class="line">        _head = _tail = node;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要看懂节点操作的代码只要了解双向链表的特性即可。在双向链表中：</p>
<ul>
<li>每个节点都有两个分别指向前后节点的指针。所以说每个节点都知道它前一个节点和后一个节点是谁。</li>
<li>链表的头部节点指向它前面节点的指针为空；链表尾部节点指向它后侧节点的指针也为空。</li>
</ul>
<p>为了便于理解，我们可以把这个抽象概念类比于幼儿园手拉手的小朋友们：<br>每个小朋友的左手都拉着前面小朋友的右手；每个小朋友的右手都拉着后面小朋友的左手；<br>而且最前面的小朋友的左手和最后面的小朋友的右手都没有拉任何一个小朋友。</p>
<p>将某个节点移动到链表头部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果该节点已经是链表头部节点，则立即返回，不做任何操作</span></div><div class="line">    <span class="keyword">if</span> (_head == node) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_tail == node) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果该节点是链表的尾部节点</span></div><div class="line">        <span class="comment">//1. 将该节点的头指针指向的节点变成链表的尾节点（将倒数第二个节点变成倒数第一个节点，即尾部节点）</span></div><div class="line">        _tail = node-&gt;_prev;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 将新的尾部节点的尾部指针置空</span></div><div class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果该节点是链表头部和尾部以外的节点（中间节点）</span></div><div class="line">        <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></div><div class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></div><div class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//将原头节点赋给该节点的尾指针（原第一个节点变成了现第二个节点）</span></div><div class="line">    node-&gt;_next = _head;</div><div class="line">    </div><div class="line">    <span class="comment">//将当前节点的头节点置空</span></div><div class="line">    node-&gt;_prev = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//将现第二个节点的头结点指向当前节点（此时_head指向的节点是现第二个节点）</span></div><div class="line">    _head-&gt;_prev = node;</div><div class="line">    </div><div class="line">    <span class="comment">//将该节点设置为链表的头节点</span></div><div class="line">    _head = node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次看上面的代码我自己是懵逼的，不过如果结合上面小朋友拉手的例子就可以快一点理解。<br>如果要其中一个小朋友放在队伍的最前面，需要</p>
<ul>
<li>将原来这个小朋友前后的小朋友的手拉上。</li>
<li>然后将这个小朋友的右手和原来排在第一位的小朋友的左手拉上。</li>
</ul>
<p>上面说的比较简略，但是相信对大家理解整个过程会有帮助。</p>
<p>也可以再结合链表的图解来看一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5e027e5?w=1001&amp;h=333&amp;f=png&amp;s=34319" alt=""></p>
<p>读者同样可以利用这种思考方式理解下面这段代码：</p>
<p>移除链表中的某个节点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//除去该node的键对应的值</span></div><div class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key));</div><div class="line">    </div><div class="line">    <span class="comment">//减去开销和总缓存数量</span></div><div class="line">    _totalCost -= node-&gt;_cost;</div><div class="line">    _totalCount--;</div><div class="line">    </div><div class="line">    <span class="comment">//节点操作</span></div><div class="line">    <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></div><div class="line">    <span class="keyword">if</span> (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev;</div><div class="line">    </div><div class="line">    <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></div><div class="line">    <span class="keyword">if</span> (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 如果该node就是链表的头结点，则将该node的尾部指针指向的节点赋给链表的头节点（第二变成了第一）</span></div><div class="line">    <span class="keyword">if</span> (_head == node) _head = node-&gt;_next;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 如果该node就是链表的尾节点，则将该node的头部指针指向的节点赋给链表的尾节点（倒数第二变成了倒数第一）</span></div><div class="line">    <span class="keyword">if</span> (_tail == node) _tail = node-&gt;_prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>移除并返回尾部的node:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (_YYLinkedMapNode *)removeTailNode &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果不存在尾节点，则返回nil</span></div><div class="line">    <span class="keyword">if</span> (!_tail) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _YYLinkedMapNode *tail = _tail;</div><div class="line">    </div><div class="line">    <span class="comment">//移除尾部节点对应的值</span></div><div class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(_tail-&gt;_key));</div><div class="line">    </div><div class="line">    <span class="comment">//减少开销和总缓存数量</span></div><div class="line">    _totalCost -= _tail-&gt;_cost;</div><div class="line">    _totalCount--;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_head == _tail) &#123;</div><div class="line">        <span class="comment">//如果链表的头尾节点相同，说明链表只有一个节点。将其置空</span></div><div class="line">        _head = _tail = <span class="literal">nil</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//将链表的尾节指针指向的指针赋给链表的尾指针（倒数第二变成了倒数第一）</span></div><div class="line">        _tail = _tail-&gt;_prev;</div><div class="line">        <span class="comment">//将新的尾节点的尾指针置空</span></div><div class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，现在了解了YYMemoryCache底层的节点操作的代码。现在来看一下YYMemoryCache是如何使用它们的。</p>
<h4 id="YYMemoryCache的属性和接口"><a href="#YYMemoryCache的属性和接口" class="headerlink" title="YYMemoryCache的属性和接口"></a>YYMemoryCache的属性和接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYMemoryCache</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Attribute</span></div><div class="line"></div><div class="line"><span class="comment">//缓存名称，默认为nil</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"></div><div class="line"><span class="comment">//缓存总数量</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCount;</div><div class="line"></div><div class="line"><span class="comment">//缓存总开销</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCost;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Limit</span></div><div class="line"></div><div class="line"><span class="comment">//数量上限，默认为NSUIntegerMax，也就是无上限</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit;</div><div class="line"></div><div class="line"><span class="comment">//开销上限，默认为NSUIntegerMax，也就是无上限</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit;</div><div class="line"></div><div class="line"><span class="comment">//缓存时间上限，默认为DBL_MAX，也就是无上限</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit;</div><div class="line"></div><div class="line"><span class="comment">//清理超出上限之外的缓存的操作间隔时间，默认为5s</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval;</div><div class="line"></div><div class="line"><span class="comment">//收到内存警告时是否清理所有缓存，默认为YES</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning;</div><div class="line"></div><div class="line"><span class="comment">//app进入后台是是否清理所有缓存，默认为YES</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground;</div><div class="line"></div><div class="line"><span class="comment">//收到内存警告的回调block</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</div><div class="line"></div><div class="line"><span class="comment">//进入后台的回调block</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache);</div><div class="line"></div><div class="line"><span class="comment">//缓存清理是否在后台进行，默认为NO</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseOnMainThread;</div><div class="line"></div><div class="line"><span class="comment">//缓存清理是否异步执行，默认为YES</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseAsynchronously;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Access Methods</span></div><div class="line"></div><div class="line"><span class="comment">//是否包含某个缓存</span></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//获取缓存对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存对象</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存对象，并添加对应的开销</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line"></div><div class="line"><span class="comment">//移除某缓存</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//移除所有缓存</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Trim</span></div><div class="line"></div><div class="line"><span class="comment">// =========== 缓存清理接口 =========== </span></div><div class="line"><span class="comment">//清理缓存到指定个数</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存到指定开销</span></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</div></pre></td></tr></table></figure>
<h4 id="YYMemoryCache的接口实现"><a href="#YYMemoryCache的接口实现" class="headerlink" title="YYMemoryCache的接口实现"></a>YYMemoryCache的接口实现</h4><p>在YYMemoryCache的初始化方法里，会实例化一个_YYLinkedMap的实例来赋给_lru这个成员变量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init&#123;</div><div class="line">      ....</div><div class="line">      _lru = [_YYLinkedMap new];</div><div class="line">      ...</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  然后所有的关于缓存的操作，都要用到_lru这个成员变量，因为它才是在底层持有这些缓存（节点）的双向链表类。下面我们来看一下这些缓存操作接口的实现：</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//是否包含某个缓存对象</span></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line"></div><div class="line">    <span class="comment">//尝试从内置的字典中获得缓存对象</span></div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">return</span> contains;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取某个缓存对象</span></div><div class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></div><div class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写入某个缓存对象，开销默认为0</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    [<span class="keyword">self</span> setObject:object forKey:key withCost:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//写入某个缓存对象，并存入缓存开销</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!object) &#123;</div><div class="line">        [<span class="keyword">self</span> removeObjectForKey:key];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    </div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="built_in">NSTimeInterval</span> now = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        <span class="comment">//如果存在与传入的key值匹配的node，则更新该node的value,cost,time，并将这个node移到链表头部</span></div><div class="line">        </div><div class="line">        <span class="comment">//更新总cost</span></div><div class="line">        _lru-&gt;_totalCost -= node-&gt;_cost;</div><div class="line">        _lru-&gt;_totalCost += cost;</div><div class="line">        </div><div class="line">        <span class="comment">//更新node</span></div><div class="line">        node-&gt;_cost = cost;</div><div class="line">        node-&gt;_time = now;</div><div class="line">        node-&gt;_value = object;</div><div class="line">        </div><div class="line">        <span class="comment">//将node移动至链表头部</span></div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果不存在与传入的key值匹配的node，则新建一个node，将key,value,cost,time赋给它，并将这个node插入到链表头部</span></div><div class="line">        <span class="comment">//新建node,并赋值</span></div><div class="line">        node = [_YYLinkedMapNode new];</div><div class="line">        node-&gt;_cost = cost;</div><div class="line">        node-&gt;_time = now;</div><div class="line">        node-&gt;_key = key;</div><div class="line">        node-&gt;_value = object;</div><div class="line">        </div><div class="line">        <span class="comment">//将node插入至链表头部</span></div><div class="line">        [_lru insertNodeAtHead:node];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果cost超过了限制，则进行删除缓存操作（从链表尾部开始删除，直到符合限制要求）</span></div><div class="line">    <span class="keyword">if</span> (_lru-&gt;_totalCost &gt; _costLimit) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(_queue, ^&#123;</div><div class="line">            [<span class="keyword">self</span> trimToCost:_costLimit];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果total count超过了限制，则进行删除缓存操作（从链表尾部开始删除，删除一次即可）</span></div><div class="line">    <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; _countLimit) &#123;</div><div class="line">        _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//移除某个缓存对象</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">//内部调用了链表的removeNode：方法</span></div><div class="line">        [_lru removeNode:node];</div><div class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//内部调用了链表的removeAll方法</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    [_lru removeAll];</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的实现是针对缓存的查询，写入，获取操作的，接下来看一下缓存的清理策略。</p>
<h3 id="YYMemoryCache的缓存清理策略"><a href="#YYMemoryCache的缓存清理策略" class="headerlink" title="YYMemoryCache的缓存清理策略"></a>YYMemoryCache的缓存清理策略</h3><p>如上文所说，在YYCache中，缓存的清理可以从缓存总数量，缓存总开销，缓存距上一次的访问时间来清理缓存。而且每种维度的清理操作都可以分为自动和手动的方式来进行。</p>
<h4 id="缓存自动清理"><a href="#缓存自动清理" class="headerlink" title="缓存自动清理"></a>缓存自动清理</h4><p>缓存的自动清理功能在YYMemoryCache初始化之后就开始了，是一个递归调用的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init&#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//开始定期清理</span></div><div class="line">    [<span class="keyword">self</span> _trimRecursively];</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//递归清理，相隔时间为_autoTrimInterval，在初始化之后立即执行</span></div><div class="line">- (<span class="keyword">void</span>)_trimRecursively &#123;</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * <span class="built_in">NSEC_PER_SEC</span>)),</div><div class="line">                   </div><div class="line">        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</div><div class="line">            </div><div class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//在后台进行清理操作</span></div><div class="line">        [<span class="keyword">self</span> _trimInBackground];</div><div class="line">        </div><div class="line">        <span class="comment">//调用自己，递归操作</span></div><div class="line">        [<span class="keyword">self</span> _trimRecursively];</div><div class="line">            </div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清理所有不符合限制的缓存，顺序为：cost，count，age</span></div><div class="line">- (<span class="keyword">void</span>)_trimInBackground &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span> _trimToCost:<span class="keyword">self</span>-&gt;_costLimit];</div><div class="line">        [<span class="keyword">self</span> _trimToCount:<span class="keyword">self</span>-&gt;_countLimit];</div><div class="line">        [<span class="keyword">self</span> _trimToAge:<span class="keyword">self</span>-&gt;_ageLimit];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> _trimToCount:count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToCost:cost];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToAge:age];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，YYMemoryCache是按照缓存数量，缓存开销，缓存时间的顺序来自动清空缓存的。我们结合代码看一下它是如何按照缓存数量来清理缓存的（其他两种清理方式类似，暂不给出）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line"></div><div class="line"><span class="comment">//将内存缓存数量降至等于或小于传入的数量；如果传入的值为0，则删除全部内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> finish = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    </div><div class="line">    <span class="comment">//如果传入的参数=0，则删除所有内存缓存</span></div><div class="line">    <span class="keyword">if</span> (countLimit == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        [_lru removeAll];</div><div class="line">        finish = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_totalCount &lt;= countLimit) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">//如果当前缓存的总数量已经小于或等于传入的数量，则直接返回YES，不进行清理</span></div><div class="line">        finish = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">if</span> (finish) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    <span class="keyword">while</span> (!finish) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//==0的时候说明在尝试加锁的时候，获取锁成功，从而可以进行操作；否则等待10秒（但是不知道为什么是10s而不是2s，5s，等等）</span></div><div class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</div><div class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                finish = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">            pthread_mutex_unlock(&amp;_lock);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (holder.count) &#123;</div><div class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            [holder count]; <span class="comment">// release in queue</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓存手动清理"><a href="#缓存手动清理" class="headerlink" title="缓存手动清理"></a>缓存手动清理</h4><p>其实上面这三种清理的方法在YYMemoryCache封装成了接口，所以用户也可以通过YYCache的memoryCache这个属性来手动清理相应维度上不符合传入标准的缓存：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.h</span></div><div class="line"></div><div class="line"><span class="comment">// =========== 缓存清理接口 =========== </span></div><div class="line"><span class="comment">//清理缓存到指定个数</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存到指定开销</span></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</div></pre></td></tr></table></figure>
<p>看一下它们的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//清理缓存到指定个数</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> _trimToCount:count];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存到指定开销</span></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToCost:cost];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToAge:age];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h2><p>YYDiskCache负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作。作为YYCache的第二级缓存，它与第一级缓存YYMemoryCache的相同点是：</p>
<ul>
<li>都具有查询，写入，读取，删除缓存的接口。</li>
<li>不直接操作缓存，也是间接地通过另一个类（YYKVStorage）来操作缓存。</li>
<li>它使用LRU算法来清理缓存。</li>
<li>支持按 cost，count 和 age 这三个维度来清理不符合标准的缓存。</li>
</ul>
<p>它与YYMemoryCache不同点是：</p>
<ul>
<li><ol>
<li>根据缓存数据的大小来采取不同的形式的缓存：</li>
</ol>
<ul>
<li>数据库sqlite: 针对小容量缓存，缓存的data和元数据都保存在数据库里。</li>
<li>文件+数据库的形式: 针对大容量缓存，缓存的data写在文件系统里，其元数据保存在数据库里。</li>
</ul>
</li>
<li><ol>
<li>除了 cost，count 和 age 三个维度之外，还添加了一个磁盘容量的维度。</li>
</ol>
</li>
</ul>
<p>这里需要说明的是：<br>对于上面的第一条：我看源码的时候只看出来有这两种缓存形式，但是从内部的缓存type枚举来看，其实是分为三种的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YYKVStorageType) &#123;</div><div class="line">    </div><div class="line">    YYKVStorageTypeFile = <span class="number">0</span>,</div><div class="line">    YYKVStorageTypeSQLite = <span class="number">1</span>,</div><div class="line">    YYKVStorageTypeMixed = <span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也就是说我只找到了第二，第三种缓存形式，而第一种纯粹的文件存储（YYKVStorageTypeFile）形式的实现我没有找到：当type为<br>YYKVStorageTypeFile和YYKVStorageTypeMixed的时候的缓存实现都是一致的：都是讲data存在文件里，将元数据放在数据库里面。</p>
<p>在YYDiskCache的初始化方法里，没有发现正确的将缓存类型设置为YYKVStorageTypeFile的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"YYDiskCache init error"</span> reason:<span class="string">@"YYDiskCache must be initialized with a path. Use 'initWithPath:' or 'initWithPath:inlineThreshold:' instead."</span> userInfo:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:<span class="string">@""</span> inlineThreshold:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:path inlineThreshold:<span class="number">1024</span> * <span class="number">20</span>]; <span class="comment">// 20KB</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line"></div><div class="line">   ...    </div><div class="line">    YYKVStorageType type;</div><div class="line">    <span class="keyword">if</span> (threshold == <span class="number">0</span>) &#123;</div><div class="line">        type = YYKVStorageTypeFile;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threshold == <span class="built_in">NSUIntegerMax</span>) &#123;</div><div class="line">        type = YYKVStorageTypeSQLite;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        type = YYKVStorageTypeMixed;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出来，当给指定初始化方法<code>initWithPath:inlineThreshold:</code>的第二个参数传入0的时候，缓存类型才是YYKVStorageTypeFile。而且比较常用的初始化方法<code>initWithPath:</code>的实现里，是将20kb传入了指定初始化方法里，结果就是将type设置成了YYKVStorageTypeMixed。</p>
<p>而且我也想不出如果只有文件形式的缓存的话，其元数据如何保存。如果有读者知道的话，麻烦告知一下，非常感谢了~~</p>
<p>在本文暂时对于上面提到的”文件+数据库的形式”在下文统一说成文件缓存了。</p>
<p>在接口的设计上，YYDiskCache与YYMemoryCache是高度一致的，只不过因为有些时候大文件的访问可能会比较耗时，所以框架作者在保留了与YYMemoryCache一样的接口的基础上，还在原来的基础上添加了block回调，避免阻塞线程。来看一下YYDiskCache的接口(省略了注释)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.h</span></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; _Nullable object))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects;</div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</div><div class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)totalCount;</div><div class="line">- (<span class="keyword">void</span>)totalCountWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCount))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)totalCost;</div><div class="line">- (<span class="keyword">void</span>)totalCostWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCost))block;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Trim</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<p>从上面的接口代码可以看出，YYDiskCache与YYMemoryCache在接口设计上是非常相似的。但是，YYDiskCache有一个非常重要的属性，它<strong>作为用sqlite做缓存还是用文件做缓存的分水岭</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.h</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold;</div></pre></td></tr></table></figure>
<p>这个属性的默认值是20480byte，也就是20kb。即是说，如果缓存数据的长度大于这个值，就使用文件存储；如果小于这个值，就是用sqlite存储。来看一下这个属性是如何使用的：</p>
<p>首先我们会在YYDiskCache的指定初始化方法里看到这个属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line">   ...</div><div class="line">    _inlineThreshold = threshold;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里将_inlineThreshold赋值，也是唯一一次的赋值。然后在写入缓存的操作里判断写入缓存的大小是否大于这个临界值，如果是，则使用文件缓存：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">   </div><div class="line">   ...</div><div class="line">    <span class="built_in">NSString</span> *filename = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (_kv.type != YYKVStorageTypeSQLite) &#123;</div><div class="line">        <span class="comment">//如果长度大临界值，则生成文件名称，使得filename不为nil</span></div><div class="line">        <span class="keyword">if</span> (value.length &gt; _inlineThreshold) &#123;</div><div class="line">            filename = [<span class="keyword">self</span> _filenameForKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Lock();</div><div class="line">    <span class="comment">//在该方法内部判断filename是否为nil，如果是，则使用sqlite进行缓存；如果不是，则使用文件缓存</span></div><div class="line">    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们知道了YYDiskCache相对于YYMemoryCache最大的不同之处是缓存类型的不同。<br>细心的朋友会发现上面这个写入缓存的方法（saveItemWithKey:value:filename:extendedData:）实际上是属于_kv的。这个_kv就是上面提到的YYKVStorage的实例，它在YYDiskCache的初始化方法里被赋值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</div><div class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    _kv = kv;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样地，再举其他两个接口为例，内部也是调用了_kv的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    Lock();</div><div class="line">    <span class="built_in">BOOL</span> contains = [_kv itemExistsForKey:key];</div><div class="line">    Unlock();</div><div class="line">    <span class="keyword">return</span> contains;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    Lock();</div><div class="line">    [_kv removeItemForKey:key];</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以是时候来看一下YYKVStorage的接口和实现了：</p>
<h3 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h3><p>YYKVStorage实例负责保存和管理所有磁盘缓存。和YYMemoryCache里面的_YYLinkedMap将缓存封装成节点类_YYLinkedMapNode类似，YYKVStorage也将某个单独的磁盘缓存封装成了一个类，这个类就是YYKVStorageItem，它保存了某个缓存所对应的一些信息(key, value, 文件名，大小等等)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYKVStorageItem.h</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">//键</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">//值</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">//文件名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> size;                             <span class="comment">//值的大小，单位是byte</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> modTime;                          <span class="comment">//修改时间戳</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> accessTime;                       <span class="comment">//最后访问的时间戳</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">//extended data</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>既然在这里将缓存封装成了YYKVStorageItem实例，<strong>那么作为缓存的管理者，YYKVStorage就必然有操作YYKVStorageItem的接口</strong>了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYKVStorage.h</span></div><div class="line"></div><div class="line"><span class="comment">//写入某个item</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</div><div class="line">                  value:(<span class="built_in">NSData</span> *)value</div><div class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</div><div class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Remove Items</span></div><div class="line"></div><div class="line"><span class="comment">//移除某个键的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">//移除多个键的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</div><div class="line"></div><div class="line"><span class="comment">//移除大于参数size的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsLargerThanSize:(<span class="keyword">int</span>)size;</div><div class="line"></div><div class="line"><span class="comment">//移除时间早于参数时间的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsEarlierThanTime:(<span class="keyword">int</span>)time;</div><div class="line"></div><div class="line"><span class="comment">//移除item，使得缓存总容量小于参数size</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitSize:(<span class="keyword">int</span>)maxSize;</div><div class="line"></div><div class="line"><span class="comment">//移除item，使得缓存数量小于参数size</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitCount:(<span class="keyword">int</span>)maxCount;</div><div class="line"></div><div class="line"><span class="comment">//移除所有的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeAllItems;</div><div class="line"></div><div class="line"><span class="comment">//移除所有的item，附带进度与结束block</span></div><div class="line">- (<span class="keyword">void</span>)removeAllItemsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</div><div class="line">                               endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Get Items</span></div><div class="line"><span class="comment">//读取参数key对应的item</span></div><div class="line">- (<span class="keyword">nullable</span> YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">//读取参数key对应的data</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getItemValueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">//读取参数数组对应的item数组</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</div><div class="line"></div><div class="line"><span class="comment">//读取参数数组对应的item字典</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSData</span> *&gt; *)getItemValueForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</div></pre></td></tr></table></figure>
<p>大家最关心的应该是写入缓存的接口是如何实现的，下面重点讲一下写入缓存的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写入某个item</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</div><div class="line">                  value:(<span class="built_in">NSData</span> *)value</div><div class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</div><div class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</div></pre></td></tr></table></figure>
<p>这三个接口都比较类似，上面的两个方法都会调用最下面参数最多的方法。在详细讲解写入缓存的代码之前，我先讲一下写入缓存的大致逻辑，有助于让大家理解整个YYDiskCache写入缓存的流程：</p>
<ol>
<li>首先判断传入的key和value是否符合要求，如果不符合要求，则立即返回NO，缓存失败。</li>
<li>再判断是否type==YYKVStorageTypeFile并且文件名为空字符串（或nil）：如果是，则立即返回NO，缓存失败。</li>
<li>判断filename是否为空字符串：<ol>
<li>如果不为空：写入文件，并将缓存的key，等信息写入数据库，但是不将key对应的data写入数据库。</li>
<li>如果为空：<ol>
<li>如果缓存类型为YYKVStorageTypeSQLite：将缓存文件删除</li>
<li>如果缓存类型不为YYKVStorageTypeSQLite：则将缓存的key和对应的data等其他信息存入数据库。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:item.key value:item.value filename:item.filename extendedData:item.extendedData];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:key value:value filename:<span class="literal">nil</span> extendedData:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value filename:(<span class="built_in">NSString</span> *)filename extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span> || value.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_type == YYKVStorageTypeFile &amp;&amp; filename.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (filename.length) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名不为空字符串，说明要进行文件缓存</span></div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _fileWriteWithName:filename data:value]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//写入元数据</span></div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</div><div class="line">            <span class="comment">//如果缓存信息保存失败，则删除对应的文件</span></div><div class="line">            [<span class="keyword">self</span> _fileDeleteWithName:filename];</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名为空字符串，说明不要进行文件缓存</span></div><div class="line">        <span class="keyword">if</span> (_type != YYKVStorageTypeSQLite) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//如果缓存类型不是数据库缓存，则查找出相应的文件名并删除</span></div><div class="line">            <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</div><div class="line">            <span class="keyword">if</span> (filename) &#123;</div><div class="line">                [<span class="keyword">self</span> _fileDeleteWithName:filename];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 缓存类型是数据库缓存，把元数据和value写入数据库</span></div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:<span class="literal">nil</span> extendedData:extendedData];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，在底层写入缓存的方法是<code>_dbSaveWithKey:value:fileName:extendedData:</code>，这个方法使用了两次:</p>
<ul>
<li>在以文件（和数据库）存储缓存时</li>
<li>在以数据库存储缓存时</li>
</ul>
<p>不过虽然调用了两次，我们可以从传入的参数是有差别的：第二次filename传了nil。那么我们来看一下<code>_dbSaveWithKey:value:fileName:extendedData:</code>内部是如何区分有无filename的情况的：</p>
<ul>
<li>当filename为空时，说明在外部没有写入该缓存的文件：则把data写入数据库里</li>
<li>当filename不为空时，说明在外部有写入该缓存的文件：则不把data也写入了数据库里</li>
</ul>
<p>下面结合代码看一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数据库存储</span></div><div class="line">- (<span class="built_in">BOOL</span>)_dbSaveWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value fileName:(<span class="built_in">NSString</span> *)fileName extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//sql语句</span></div><div class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@"insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);"</span>;</div><div class="line">    </div><div class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> timestamp = (<span class="keyword">int</span>)time(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//key</span></div><div class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//filename</span></div><div class="line">    sqlite3_bind_text(stmt, <span class="number">2</span>, fileName.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//size</span></div><div class="line">    sqlite3_bind_int(stmt, <span class="number">3</span>, (<span class="keyword">int</span>)value.length);</div><div class="line">    </div><div class="line">    <span class="comment">//inline_data</span></div><div class="line">    <span class="keyword">if</span> (fileName.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名长度==0，则将value存入数据库</span></div><div class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, value.bytes, (<span class="keyword">int</span>)value.length, <span class="number">0</span>);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名长度不为0，则不将value存入数据库</span></div><div class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//modification_time</span></div><div class="line">    sqlite3_bind_int(stmt, <span class="number">5</span>, timestamp);</div><div class="line">    </div><div class="line">    <span class="comment">//last_access_time</span></div><div class="line">    sqlite3_bind_int(stmt, <span class="number">6</span>, timestamp);</div><div class="line">    </div><div class="line">    <span class="comment">//extended_data</span></div><div class="line">    sqlite3_bind_blob(stmt, <span class="number">7</span>, extendedData.bytes, (<span class="keyword">int</span>)extendedData.length, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</div><div class="line">        <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@"%s line:%d sqlite insert error (%d): %s"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>框架作者用数据库的一条记录来保存关于某个缓存的所有信息。<br>而且数据库的第四个字段是保存缓存对应的data的，从上面的代码可以看出当filename为空和不为空的时候的处理的差别。</p>
<p>上面的<code>sqlite3_stmt</code>可以看作是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。<br>而sqlite3_bind_text和sqlite3_bind_int是绑定函数，可以看作是将变量插入到字段的操作。</p>
<p>OK，现在看完了写入缓存，我们再来看一下获取缓存的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYKVSorage.m</span></div><div class="line">- (YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    YYKVStorageItem *item = [<span class="keyword">self</span> _dbGetItemWithKey:key excludeInlineData:<span class="literal">NO</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (item) &#123;</div><div class="line">        <span class="comment">//更新内存访问的时间</span></div><div class="line">        [<span class="keyword">self</span> _dbUpdateAccessTimeWithKey:key];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (item.filename) &#123;</div><div class="line">            <span class="comment">//如果有文件名，则尝试获取文件数据</span></div><div class="line">            item.value = [<span class="keyword">self</span> _fileReadWithName:item.filename];</div><div class="line">            <span class="comment">//如果此时获取文件数据失败，则删除对应的item</span></div><div class="line">            <span class="keyword">if</span> (!item.value) &#123;</div><div class="line">                [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</div><div class="line">                item = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面这段代码我们可以看到获取YYKVStorageItem的实例的方法是<code>_dbGetItemWithKey:excludeInlineData:</code><br>我们来看一下它的实现：</p>
<ol>
<li>首先根据查找key的sql语句生成stmt</li>
<li>然后将传入的key与该stmt进行绑定</li>
<li>最后通过这个stmt来查找出与该key对应的有关该缓存的其他数据并生成item。</li>
</ol>
<p>来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (YYKVStorageItem *)_dbGetItemWithKey:(<span class="built_in">NSString</span> *)key excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</div><div class="line">    <span class="built_in">NSString</span> *sql = excludeInlineData ? <span class="string">@"select key, filename, size, modification_time, last_access_time, extended_data from manifest where key = ?1;"</span> : <span class="string">@"select key, filename, size, inline_data, modification_time, last_access_time, extended_data from manifest where key = ?1;"</span>;</div><div class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</div><div class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    YYKVStorageItem *item = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</div><div class="line">    <span class="keyword">if</span> (result == SQLITE_ROW) &#123;</div><div class="line">        <span class="comment">//传入stmt来生成YYKVStorageItem实例</span></div><div class="line">        item = [<span class="keyword">self</span> _dbGetItemFromStmt:stmt excludeInlineData:excludeInlineData];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</div><div class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@"%s line:%d sqlite query error (%d): %s"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到最终生成YYKVStorageItem实例的是通过<code>_dbGetItemFromStmt:excludeInlineData:</code>来实现的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (YYKVStorageItem *)_dbGetItemFromStmt:(sqlite3_stmt *)stmt excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//提取数据</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> *key = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</div><div class="line">    <span class="keyword">char</span> *filename = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</div><div class="line">    <span class="keyword">int</span> size = sqlite3_column_int(stmt, i++);</div><div class="line">    </div><div class="line">    <span class="comment">//判断excludeInlineData</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *inline_data = excludeInlineData ? <span class="literal">NULL</span> : sqlite3_column_blob(stmt, i);</div><div class="line">    <span class="keyword">int</span> inline_data_bytes = excludeInlineData ? <span class="number">0</span> : sqlite3_column_bytes(stmt, i++);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> modification_time = sqlite3_column_int(stmt, i++);</div><div class="line">    <span class="keyword">int</span> last_access_time = sqlite3_column_int(stmt, i++);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *extended_data = sqlite3_column_blob(stmt, i);</div><div class="line">    <span class="keyword">int</span> extended_data_bytes = sqlite3_column_bytes(stmt, i++);</div><div class="line">    </div><div class="line">    <span class="comment">//将数据赋给item的属性</span></div><div class="line">    YYKVStorageItem *item = [YYKVStorageItem new];</div><div class="line">    <span class="keyword">if</span> (key) item.key = [<span class="built_in">NSString</span> stringWithUTF8String:key];</div><div class="line">    <span class="keyword">if</span> (filename &amp;&amp; *filename != <span class="number">0</span>) item.filename = [<span class="built_in">NSString</span> stringWithUTF8String:filename];</div><div class="line">    item.size = size;</div><div class="line">    <span class="keyword">if</span> (inline_data_bytes &gt; <span class="number">0</span> &amp;&amp; inline_data) item.value = [<span class="built_in">NSData</span> dataWithBytes:inline_data length:inline_data_bytes];</div><div class="line">    item.modTime = modification_time;</div><div class="line">    item.accessTime = last_access_time;</div><div class="line">    <span class="keyword">if</span> (extended_data_bytes &gt; <span class="number">0</span> &amp;&amp; extended_data) item.extendedData = [<span class="built_in">NSData</span> dataWithBytes:extended_data length:extended_data_bytes];</div><div class="line">    <span class="keyword">return</span> item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码分为两个部分：</p>
<ul>
<li>获取数据库里每一个字段对应的数据</li>
<li>将数据赋给YYKVStorageItem的实例</li>
</ul>
<p>需要注意的是：</p>
<ol>
<li>字符串类型需要使用<code>stringWithUTF8String:</code>来转成NSString类型。</li>
<li>这里面会判断<code>excludeInlineData</code>：<ul>
<li>如果为TRUE，就提取存入的data数据</li>
<li>如果为FALSE，就不提取</li>
</ul>
</li>
</ol>
<h2 id="保证线程安全的方案"><a href="#保证线程安全的方案" class="headerlink" title="保证线程安全的方案"></a>保证线程安全的方案</h2><p>我相信对于某个设计来说，它的产生一定是基于某种个特定问题下的某个场景的</p>
<p>由上文可以看出：</p>
<ul>
<li>YYMemoryCache 使用了 pthread_mutex 线程锁（互斥锁）来确保线程安全</li>
<li>YYDiskCache 则选择了更适合它的 dispatch_semaphore。</li>
</ul>
<h3 id="内存缓存操作的互斥锁"><a href="#内存缓存操作的互斥锁" class="headerlink" title="内存缓存操作的互斥锁"></a>内存缓存操作的互斥锁</h3><p>在YYMemoryCache中，是使用互斥锁来保证线程安全的。<br>首先在YYMemoryCache的初始化方法中得到了互斥锁，并在它的所有接口里都加入了互斥锁来保证线程安全，包括setter，getter方法和缓存操作的实现。举几个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)totalCost &#123;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    <span class="built_in">NSUInteger</span> totalCost = _lru-&gt;_totalCost;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">return</span> totalCost;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setReleaseOnMainThread:(<span class="built_in">BOOL</span>)releaseOnMainThread &#123;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _lru-&gt;_releaseOnMainThread = releaseOnMainThread;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">return</span> contains;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></div><div class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而且需要在dealloc方法中销毁这个锁头：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//销毁互斥锁</span></div><div class="line">    pthread_mutex_destroy(&amp;_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="磁盘缓存使用信号量来代替锁"><a href="#磁盘缓存使用信号量来代替锁" class="headerlink" title="磁盘缓存使用信号量来代替锁"></a>磁盘缓存使用信号量来代替锁</h3><p>框架作者采用了信号量的方式来给<br>首先在初始化的时候实例化了一个信号量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line">    ...</div><div class="line">    _lock = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">    _queue = dispatch_queue_create(<span class="string">"com.ibireme.cache.disk"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>然后使用了宏来代替加锁解锁的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)</span></div><div class="line"><span class="meta">#define Unlock() dispatch_semaphore_signal(self-&gt;_lock)</span></div></pre></td></tr></table></figure>
<p>简单说一下信号量：</p>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p>
<ul>
<li>dispatch_semaphore_create：定义信号量</li>
<li>dispatch_semaphore_signal：使信号量+1</li>
<li>dispatch_semaphore_wait：使信号量-1</li>
</ul>
<p>当信号量为0时，就会做等待处理，这是其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能：</p>
<ul>
<li>执行某段代码之前，执行dispatch_semaphore_wait函数，让信号量-1变为0，执行这段代码。</li>
<li>此时如果其他线程过来访问这段代码，就要让其等待。</li>
<li>当这段代码在当前线程结束以后，执行dispatch_semaphore_signal函数，令信号量再次+1，那么如果有正在等待的线程就可以访问了。</li>
</ul>
<p>需要注意的是：如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到dispatch_semaphore_wait的顺序。</p>
<p>这也就是信号量和互斥锁的一个区别：互斥量用于线程的互斥，信号线用于线程的同步。</p>
<ul>
<li><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但<strong>互斥无法限制访问者对资源的访问顺序，即访问是无序的</strong>。</p>
</li>
<li><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。</p>
</li>
</ul>
<p>那么问题来了：为什么内存缓存使用的是互斥锁（pthread_mutex），而磁盘缓存使用的就是信号量（dispatch_semaphore）呢？</p>
<p>答案在框架作者的文章<a href="https://blog.ibireme.com/2015/10/26/yycache/" target="_blank" rel="external">YYCache 设计思路</a>里可以找到:</p>
<p>为什么内存缓存使用互斥锁（pthread_mutex）？</p>
<p>框架作者在最初使用的是自旋锁(OSSpinLock)作为内存缓存的线程锁，但是后来得知其不够安全，所以退而求其次，使用了pthread_mutex。</p>
<p>为什么磁盘缓存使用的是信号量（dispatch_semaphore）？</p>
<blockquote>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
</blockquote>
<p>因为YYDiskCache在写入比较大的缓存时，可能会有比较长的等待时间，而dispatch_semaphore在这个时候是不消耗CPU资源的，所以比较适合。</p>
<h2 id="提高缓存性能的几个尝试"><a href="#提高缓存性能的几个尝试" class="headerlink" title="提高缓存性能的几个尝试"></a>提高缓存性能的几个尝试</h2><h3 id="选择合适的线程锁"><a href="#选择合适的线程锁" class="headerlink" title="选择合适的线程锁"></a>选择合适的线程锁</h3><p>可以参考上一部分YYMemoryCache 和YYDiskCache使用的不同的锁以及原因。</p>
<h3 id="选择合适的数据结构"><a href="#选择合适的数据结构" class="headerlink" title="选择合适的数据结构"></a>选择合适的数据结构</h3><p>在YYMemoryCache中，作者选择了双向链表来保存这些缓存节点。那么可以思考一下，为什么要用双向链表而不是单向链表或是数组呢？</p>
<ul>
<li><p>为什么不选择单向链表：单链表的节点只知道它后面的节点（只有指向后一节点的指针），而不知道前面的。所以如果想移动其中一个节点的话，其前后的节点不好做衔接。</p>
</li>
<li><p>为什么不选择数组：数组中元素在内存的排列是连续的，对于寻址操作非常便利；但是对于插入，删除操作很不方便，需要整体移动，移动的元素个数越多，代价越大。而链表恰恰相反，因为其节点的关联仅仅是靠指针，所以对于插入和删除操作会很便利，而寻址操作缺比较费时。由于在LRU策略中会有非常多的移动，插入和删除节点的操作，所以使用双向链表是比较有优势的。</p>
</li>
</ul>
<h3 id="选择合适的线程来操作不同的任务"><a href="#选择合适的线程来操作不同的任务" class="headerlink" title="选择合适的线程来操作不同的任务"></a>选择合适的线程来操作不同的任务</h3><p>无论缓存的自动清理和释放，作者默认把这些任务放到子线程去做：</p>
<p>看一下释放所有内存缓存的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeAll &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//将开销，缓存数量置为0</span></div><div class="line">    _totalCost = <span class="number">0</span>;</div><div class="line">    _totalCount = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//将链表的头尾节点置空</span></div><div class="line">    _head = <span class="literal">nil</span>;</div><div class="line">    _tail = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CFDictionaryGetCount</span>(_dic) &gt; <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CFMutableDictionaryRef</span> holder = _dic;</div><div class="line">        _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        </div><div class="line">        <span class="comment">//是否在子线程操作</span></div><div class="line">        <span class="keyword">if</span> (_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CFRelease</span>(holder);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>YYMemoryCacheGetReleaseQueue()</code>使用了内联函数，返回了低优先级的并发队列。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//内联函数，返回优先级最低的全局并发队列</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</div><div class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择底层的类"><a href="#选择底层的类" class="headerlink" title="选择底层的类"></a>选择底层的类</h3><p>同样是字典实现，但是作者使用了更底层且快速的CFDictionary而没有用NSDictionary来实现。</p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="禁用原生初始化方法并标明新定义的指定初始化方法"><a href="#禁用原生初始化方法并标明新定义的指定初始化方法" class="headerlink" title="禁用原生初始化方法并标明新定义的指定初始化方法"></a>禁用原生初始化方法并标明新定义的指定初始化方法</h3><p>YYCache有4个供外部调用的初始化接口，无论是对象方法还是类方法都需要传入一个字符串（名称或路径）。</p>
<p>而两个原生的初始化方法被框架作者禁掉了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</div><div class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</div></pre></td></tr></table></figure>
<p>如果用户使用了上面两个初始化方法就会在编译期报错。</p>
<p>而剩下的四个可以使用的初始化方法中，有一个是指定初始化方法，被作者用<code>NS_DESIGNATED_INITIALIZER</code>标记了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"></div><div class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithName:(<span class="built_in">NSString</span> *)name;</div><div class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithPath:(<span class="built_in">NSString</span> *)path;</div></pre></td></tr></table></figure>
<p>指定初始化方法就是所有可使用的初始化方法都必须调用的方法。更详细的介绍可以参考我的下面两篇文章：</p>
<ul>
<li><a href="https://juejin.im/post/5940c8befe88c2006a468ea6" target="_blank" rel="external">iOS 代码规范</a>中讲解“类”的这一部分。</li>
<li><a href="https://juejin.im/post/5a4f3710f265da3e4d728239" target="_blank" rel="external">《Effective objc》干货三部曲（三）：技巧篇</a>中的第16条。</li>
</ul>
<h3 id="异步释放对象的技巧"><a href="#异步释放对象的技巧" class="headerlink" title="异步释放对象的技巧"></a>异步释放对象的技巧</h3><p>为了异步将某个对象释放掉，可以通过在GCD的block里面给它发个消息来实现。这个技巧在该框架中很常见，举一个删除一个内存缓存的例子：</p>
<p>首先将这个缓存的node类取出，然后异步将其释放掉。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        [_lru removeNode:node];</div><div class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了释放掉这个node对象，在一个异步执行的（主队列或自定义队列里）block里给其发送了<code>class</code>这个消息。不需要纠结这个消息具体是什么，他的目的是为了避免编译错误，因为我们无法在block里面硬生生地将某个对象写进去。</p>
<p>其实关于上面这一点我自己也有点拿不准，希望理解得比较透彻的同学能在下面留个言~ ^^</p>
<h3 id="内存警告和进入后台的监听"><a href="#内存警告和进入后台的监听" class="headerlink" title="内存警告和进入后台的监听"></a>内存警告和进入后台的监听</h3><p>YYCache默认在收到内存警告和进入后台时，自动清除所有内存缓存。所以在YYMemoryCache的初始化方法里，我们可以看到这两个监听的动作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init&#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">      </div><div class="line">    <span class="comment">//监听app生命周期</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidReceiveMemoryWarningNotification) name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidEnterBackgroundNotification) name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span> object:<span class="literal">nil</span>];</div><div class="line">   </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现监听到消息后的处理方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//内存警告时，删除所有内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)_appDidReceiveMemoryWarningNotification &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didReceiveMemoryWarningBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.didReceiveMemoryWarningBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldRemoveAllObjectsOnMemoryWarning) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//进入后台时，删除所有内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)_appDidEnterBackgroundNotification &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didEnterBackgroundBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.didEnterBackgroundBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldRemoveAllObjectsWhenEnteringBackground) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断头文件的导入"><a href="#判断头文件的导入" class="headerlink" title="判断头文件的导入"></a>判断头文件的导入</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if __has_include(<span class="meta-string">&lt;YYCache/YYCache.h&gt;</span>)</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYMemoryCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYDiskCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYKVStorage.h&gt;</span></span></div><div class="line"><span class="meta">#elif __has_include(<span class="meta-string">&lt;YYWebImage/YYCache.h&gt;</span>)</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYMemoryCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYDiskCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYKVStorage.h&gt;</span></span></div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="meta">#import <span class="meta-string">"YYMemoryCache.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"YYDiskCache.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"YYKVStorage.h"</span></span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>在这里作者使用__has_include来检查Frameworks是否引入某个类。<br>因为YYWebImage已经集成YYCache,所以如果导入过YYWebImage的话就无需重再导入YYCache了。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>通过看该组件的源码，我收获的不仅有缓存设计的思路，还有：</p>
<ul>
<li>双向链表的概念以及相关操作</li>
<li>数据库的使用</li>
<li>互斥锁，信号量的使用</li>
<li>实现线程安全的方案</li>
<li>变量，方法的命名以及接口的设计</li>
</ul>
<p>相信读过这篇文章的你也会有一些收获~<br>如果能趁热打铁，下载一个<a href="https://github.com/ibireme/YYCache">YYCache</a>源码看就更好啦~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ibireme/YYCache&quot;&gt;YYCache&lt;/a&gt;是国内开发者&lt;a href=&quot;https://blog.ibireme.com/&quot;&gt;ibireme&lt;/a&gt;开源的一个线程安全的高性能键值缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。&lt;/p&gt;
&lt;p&gt;阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。&lt;/p&gt;
&lt;p&gt;在正式开始讲解源码之前，先简单看一下该框架的使用方法。&lt;/p&gt;
&lt;h1 id=&quot;基本使用方法&quot;&gt;&lt;a href=&quot;#基本使用方法&quot; class=&quot;headerlink&quot; title=&quot;基本使用方法&quot;&gt;&lt;/a&gt;基本使用方法&lt;/h1&gt;&lt;p&gt;举一个缓存用户姓名的例子来看一下YYCache的几个API：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//需要缓存的对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *userName = &lt;span class=&quot;string&quot;&gt;@&quot;Jack&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//需要缓存的对象在缓存里对应的键&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *key = &lt;span class=&quot;string&quot;&gt;@&quot;user_name&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//创建一个YYCache实例:userInfoCache&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; YYCache *userInfoCache = [YYCache cacheWithName:&lt;span class=&quot;string&quot;&gt;@&quot;userInfo&quot;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//存入键值对&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; [userInfoCache setObject:userName forKey:key withBlock:^&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;caching object succeed&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//判断缓存是否存在&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; [userInfoCache containsObjectForKey:key withBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull key, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; contains) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (contains)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;object exists&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//根据key读取数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; [userInfoCache objectForKey:key withBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSCoding&lt;/span&gt;&amp;gt;  _Nonnull object) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;user name : %@&quot;&lt;/span&gt;,object);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//根据key移除缓存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; [userInfoCache removeObjectForKey:key withBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * _Nonnull key) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;remove user name %@&quot;&lt;/span&gt;,key);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//移除所有缓存&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; [userInfoCache removeAllObjectsWithBlock:^&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;removing all cache succeed&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//移除所有缓存带进度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; [userInfoCache removeAllObjectsWithProgressBlock:^(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; removedCount, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; totalCount) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;remove all cache objects: removedCount :%d  totalCount : %d&quot;&lt;/span&gt;,removedCount,totalCount);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125; endBlock:^(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!error)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;remove all cache objects: succeed&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;remove all cache objects: failed&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;总体来看这些API与&lt;code&gt;NSCache&lt;/code&gt;是差不多的。&lt;br&gt;下面接着看一下该框架的架构：&lt;/p&gt;
&lt;h1 id=&quot;架构与职责划分&quot;&gt;&lt;a href=&quot;#架构与职责划分&quot; class=&quot;headerlink&quot; title=&quot;架构与职责划分&quot;&gt;&lt;/a&gt;架构与职责划分&lt;/h1&gt;&lt;p&gt;首先看一下架构图：&lt;/p&gt;
&lt;h2 id=&quot;架构图&quot;&gt;&lt;a href=&quot;#架构图&quot; class=&quot;headerlink&quot; title=&quot;架构图&quot;&gt;&lt;/a&gt;架构图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5bd7907?w=604&amp;amp;h=344&amp;amp;f=png&amp;amp;s=21874&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;职责划分&quot;&gt;&lt;a href=&quot;#职责划分&quot; class=&quot;headerlink&quot; title=&quot;职责划分&quot;&gt;&lt;/a&gt;职责划分&lt;/h2&gt;&lt;p&gt;从架构图上来看，该组件里面的成员并不多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YYCache：提供了最外层的接口，调用了YYMemoryCache与YYDiskCache的相关方法。&lt;/li&gt;
&lt;li&gt;YYMemoryCache：负责处理容量小，相对高速的内存缓存。线程安全，支持自动和手动清理缓存等功能。&lt;/li&gt;
&lt;li&gt;_YYLinkedMap：YYMemoryCache使用的双向链表类。&lt;/li&gt;
&lt;li&gt;_YYLinkedMapNode：是_YYLinkedMap使用的节点类。&lt;/li&gt;
&lt;li&gt;YYDiskCache：负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作，自动和手动清理缓存等功能。&lt;/li&gt;
&lt;li&gt;YYKVStorage：YYDiskCache的底层实现类，用于管理磁盘缓存。&lt;/li&gt;
&lt;li&gt;YYKVStorageItem：内置在YYKVStorage中，是YYKVStorage内部用于封装某个缓存的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个成员的详细的功能会在下文结合代码介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>开源一个封装AFNetworking的网络框架 - SJNetwork</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/12/27/%E5%BC%80%E6%BA%90%E4%B8%80%E4%B8%AA%E5%B0%81%E8%A3%85AFNetworking%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%20-%20SJNetwork/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/12/27/开源一个封装AFNetworking的网络框架 - SJNetwork/</id>
    <published>2017-12-27T00:35:41.042Z</published>
    <updated>2017-12-27T00:50:45.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>该框架是一个通用的网络层，可以供给不同app的业务层调用。该框架封装了AFNetworking，而且有些地方借鉴了YTKNetwork的设计思路：以对象的形式封装并管理请求。</p>
<p>它在功能上支持：</p>
<ul>
<li>发送请求方法为GET，POST，PUT，DELETE的普通网络请求的功能</li>
<li>上传图片功能（单张与多张上传，指定上传前的图片压缩比率）</li>
<li>下载功能（支持断点续传和后台下载）</li>
<li>缓存管理（写入，读取，清除缓存，计算大小）功能</li>
<li>请求管理（查看正在进行的请求的状态，请求的单个与批量取消）功能</li>
<li>设置请求体里的默认键值对（eg.需要添加版本号进行版本控制）</li>
<li>添加请求头（eg.针对一些需要使用token的服务）</li>
<li>设置服务器地址</li>
<li>设置debug模式（调试时打印出便于调试的log，比如读取缓存失败的具体原因）</li>
</ul>
<p>GitHub链接：<a href="https://github.com/knightsj/SJNetwork">SJNetwork</a></p>
<blockquote>
<p>里面附有demo</p>
</blockquote>
<a id="more"></a>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>在看架构图之前，先简单介绍一下该框架里每个类的职责:</p>
<h2 id="职责划分"><a href="#职责划分" class="headerlink" title="职责划分"></a>职责划分</h2><table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">职责</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SJNetwork</td>
<td style="text-align:left">总头文件，只需要引入该文件即可使用该框架所有功能</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkProtocol</td>
<td style="text-align:left">定制了请求结束后的处理方法，今后可能还会扩展</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkHeader</td>
<td style="text-align:left">定义了回调block和一些枚举类型</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkManager</td>
<td style="text-align:left">与业务层直接对接的类，包含了除配置接口外所有关于网络请求功能的接口</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkBaseEngine</td>
<td style="text-align:left">所有负责发送请求类的基类</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkRequestEngine</td>
<td style="text-align:left">发送（GET,POST,PUT,DELETE）请求的类：支持设置缓存有效期，读，写和清理缓存</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkUploadEngine</td>
<td style="text-align:left">发送上传请求的类：支持设置图片类型和压缩上传，批量上传</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkDownloadEngine</td>
<td style="text-align:left">发送下载请求的类：支持断点续传和后台下载</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkRequestModel</td>
<td style="text-align:left">请求对象类：持有某个网络请求的一些数据；比如请求url，请求体等）</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkCacheManager</td>
<td style="text-align:left">缓存处理类：缓存的写入，读取，删除</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkConfig</td>
<td style="text-align:left">配置类：配置服务器地址，debug模式等</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkUtils</td>
<td style="text-align:left">工具类：可以用于生成缓存路径，app版本号等</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkRequestPool</td>
<td style="text-align:left">请求对象池：用于存放正在进行的请求对象</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkCacheInfo</td>
<td style="text-align:left">缓存元数据：记录其对应缓存数据的信息（版本号，缓存过期时间）</td>
</tr>
<tr>
<td style="text-align:left">SJNetworkDownloadResumeDataInfo</td>
<td style="text-align:left">未下载完成数据的元数据：记录未下载完成数据的信息（已经下载的比例，下载数据的总长度，已经下载数据的长度）</td>
</tr>
</tbody>
</table>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/1609352038129d87?w=839&amp;h=539&amp;f=png&amp;s=45872" alt="architecture"></p>
<blockquote>
<p>从架构图中可以看出：</p>
<ul>
<li>业务方调用<code>SJNetworkManager</code>的接口来发送请求（或进行操作请求等操作），而实际进行工作的类其实是<code>SJNetworkRequestEngine</code>,<code>SJNetworkUploadEngine</code>,<code>SJNetworkDownloadEngine</code>，<code>SJNetworkCacheManager</code>这些类。</li>
<li>所有的请求都会被封装成一个<code>SJNetworkRequestModel</code>实例来管理，其管理者为<code>SJNetworkRequestPool</code>。</li>
<li>在该框架内，<code>SJNetworkConfig</code>和<code>SJNetworkUtils</code>是可以在任意地方调用的，因为要经常获取用户所做的一些配置以及调用一些常用的工具类方法。</li>
</ul>
</blockquote>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p><strong>Step1:下载与导入框架</strong></p>
<p>通过Pod:</p>
<figure class="highlight plain"><figcaption><span>'SJNetwork'```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">或者 手动将 ``SJNetwork``文件夹拖入到工程里面。</div><div class="line"></div><div class="line">&gt;因为代码刚上传到Cocoapods，所以很可能还没有审核通过。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">**Step2:引入头文件：**</div><div class="line"></div><div class="line">```objective-c</div><div class="line">#import &quot;SJNetwork.h&quot;</div></pre></td></tr></table></figure>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><h2 id="基本的配置"><a href="#基本的配置" class="headerlink" title="基本的配置"></a>基本的配置</h2><p>因为配置对象是一个单例（<code>SJNetworkConfig</code>），所以可以在项目任何地方来使用。看一下该框架支持哪些配置项：</p>
<h3 id="服务器地址："><a href="#服务器地址：" class="headerlink" title="服务器地址："></a>服务器地址：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SJNetworkConfig sharedConfig].baseUrl = @&quot;http://v.juhe.cn&quot;;</div></pre></td></tr></table></figure>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数:"></a>默认参数:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[SJNetworkConfig sharedConfig].defailtParameters = @&#123;@&quot;app_version&quot;:[SJNetworkUtils appVersionStr],</div><div class="line">                                                        @&quot;platform&quot;:@&quot;iOS&quot;&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>默认参数会拼接在所有请求的请求体中；</p>
<p>如果是GET请求，则拼接在url里面。</p>
</blockquote>
<h3 id="超时时间："><a href="#超时时间：" class="headerlink" title="超时时间："></a>超时时间：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SJNetworkConfig sharedConfig].timeoutSeconds = 30;</div></pre></td></tr></table></figure>
<blockquote>
<p>超时时间默认为20s。</p>
</blockquote>
<h3 id="Debug模式："><a href="#Debug模式：" class="headerlink" title="Debug模式："></a>Debug模式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SJNetworkConfig sharedConfig].debugMode = YES;//默认为NO</div></pre></td></tr></table></figure>
<blockquote>
<p>如果设置debug模式为YES，则会打印出很多详细的log，便于调试。</p>
<p>如果设置为NO，则没有log。</p>
</blockquote>
<h3 id="添加请求头键值对："><a href="#添加请求头键值对：" class="headerlink" title="添加请求头键值对："></a>添加请求头键值对：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkConfig sharedConfig] addCustomHeader:@&#123;@&quot;token&quot;:@&quot;2j4jd9s74bfm9sn3&quot;&#125;];</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] addCustomHeader:@&#123;@&quot;token&quot;:@&quot;2j4jd9s74bfm9sn3&quot;&#125;];//实际上调用了SJNetworkConfig的addCustomHeader方法</div></pre></td></tr></table></figure>
<blockquote>
<p>添加的请求头键值对会自动添加到所有的请求头中；</p>
<p>如果键值对原来不存在，则添加；如果原来存在，则替换原有的。</p>
</blockquote>
<h2 id="普通网络请求"><a href="#普通网络请求" class="headerlink" title="普通网络请求"></a>普通网络请求</h2><p>在这里定义GET，POST，PUT，DELETE请求为普通的网络请求，是由<code>SJNetworkRequestManager</code>实现的。所有的这些普通的网络请求都支持写入和读取缓存，但是默认是不支持的，由用户来决定是否写入，读取缓存。</p>
<p>发送一个不支持写入和读取缓存的POST请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] sendPostRequest:@&quot;toutiao/index&quot;</div><div class="line">                                       parameters:@&#123;@&quot;type&quot;:@&quot;top&quot;,</div><div class="line">                                                    @&quot;key&quot; :@&quot;0c60&quot;&#125;</div><div class="line">                                          success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;request succeed:%@&quot;,responseObject);</div><div class="line"></div><div class="line">  &#125; failure:^(NSURLSessionTask *task, NSError *error, NSInteger statusCode) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;request failed:%@&quot;,error);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>发送一个支持写入有效时间为180秒并在缓存有效时读取缓存的POST请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] sendPostRequest:@&quot;toutiao/index&quot;</div><div class="line">                                       parameters:@&#123;@&quot;type&quot;:@&quot;top&quot;,</div><div class="line">                                                    @&quot;key&quot; :@&quot;0c60&quot;&#125;</div><div class="line">                                        loadCache:YES</div><div class="line">                                    cacheDuration:180</div><div class="line">                                          success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;request succeed:%@&quot;,responseObject);</div><div class="line"></div><div class="line"> &#125; failure:^(NSURLSessionTask *task, NSError *error, NSInteger statusCode) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;request failed:%@&quot;,error);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>cacheDuration：缓存有效的时间，单位为秒。</p>
<ul>
<li>如果大于0，则进行缓存。</li>
<li>如果小于等于0，则不进行缓存。</li>
</ul>
<p>loadCache：如果设置为YES，则在发起请求前，先查看是否缓存有效（如果设置为NO，则无论有没有缓存，都进行网络请求）：</p>
<ul>
<li>如果缓存存在并有效，则返回缓存，不进行网络请求；</li>
<li>如果缓存不存在，或者存在但失效（时间过期）则删除缓存（如果缓存存在）并进行网络请求。</li>
</ul>
</blockquote>
<p>完整的带有缓存判断的普通网络请求的流程图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/24/160873e31e97cd9b?w=1037&amp;h=617&amp;f=png&amp;s=64142" alt="request"></p>
<h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>缓存管理是由<code>SJNetworkCacheManager</code>的单例来实现的，功能分为缓存的读取，删除和计算。先来看一下缓存的读取：</p>
<h3 id="缓存的读取"><a href="#缓存的读取" class="headerlink" title="缓存的读取"></a>缓存的读取</h3><p>该框架支持单个缓存的读取和多个缓存的读取：</p>
<ul>
<li>单个缓存的读取只返回某个缓存对象（字典，或数组）或nil。</li>
<li>多个缓存的读取返回的是一个数组或nil。</li>
</ul>
<h4 id="单个缓存的读取："><a href="#单个缓存的读取：" class="headerlink" title="单个缓存的读取："></a>单个缓存的读取：</h4><p>如果知道这个缓存对应的请求url，method，请求体，就能尝试获取它所对应的缓存对象：</p>
<p>举个例子，如果想获取上面有写入缓存的网络请求的缓存，就可以用如下API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] loadCacheWithUrl:@&quot;toutiao/index&quot;</div><div class="line">                                            method:@&quot;POST&quot;</div><div class="line">                                        parameters:@&#123;@&quot;type&quot;:@&quot;top&quot;,</div><div class="line">                                                   @&quot;key&quot; :@&quot;0c60&quot;&#125;</div><div class="line">                                   completionBlock:^(id  _Nullable cacheObject) &#123;</div><div class="line">                               </div><div class="line">    NSLog(@&quot;%@&quot;,cacheObject);</div><div class="line">                               </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，在缓存的读取过程中会有以下几种情况： </p>
<ul>
<li><p>如果这个请求对应的缓存不存在，则会从block里传过来nil。</p>
</li>
<li><p>如果这个请求对应的缓存存在，但是失效了（有效期过了），则这个缓存就会被清除掉，并会在block里传过来nil。</p>
</li>
<li><p>如果这个请求对应的缓存存在并有效，则会从block里传过来缓存对象。</p>
</li>
</ul>
</blockquote>
<h4 id="多个缓存的读取："><a href="#多个缓存的读取：" class="headerlink" title="多个缓存的读取："></a>多个缓存的读取：</h4><p>如果有些请求使用的是同一个url（但是不同的请求方法或者参数）并做了缓存，那么通过如下方法可以获取它们的缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] loadCacheWithUrl:@&quot;toutiao/index&quot;</div><div class="line">                                   completionBlock:^(NSArray * _Nullable cacheArr) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,cacheArr);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果有些请求使用的是同一个url以及请求方法，但是请求参数不同，那么通过如下方法可以获取它们的缓存（用数组保存）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] loadCacheWithUrl:@&quot;toutiao/index&quot;</div><div class="line">                                            method:@&quot;POST&quot;</div><div class="line">                                   completionBlock:^(NSArray * _Nullable cacheArr) &#123;</div><div class="line">     NSLog(@&quot;%@&quot;,cacheArr);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>现在我们知道这个框架在缓存的读取上支持单个与批量读取，接下来看一下缓存的删除：</p>
<h3 id="缓存的删除"><a href="#缓存的删除" class="headerlink" title="缓存的删除"></a>缓存的删除</h3><p>同样地，该框架也支持缓存的单个与批量删除。</p>
<p>如果你想删除属于某个特定url，method，请求参数的请求的缓存，可以使用下面这个API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] clearCacheWithUrl:@&quot;toutiao/index&quot;</div><div class="line">                                             method:@&quot;POST&quot;</div><div class="line">                                         parameters:@&#123;@&quot;type&quot;:@&quot;top&quot;,</div><div class="line">                                                      @&quot;key&quot; :@&quot;0c60&quot;&#125;</div><div class="line">                                    completionBlock:^(BOOL isSuccess) &#123;</div><div class="line"></div><div class="line">     if (isSuccess) &#123;</div><div class="line">       NSLog(@&quot;Clearing cache successfully!&quot;);</div><div class="line">     &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果你想删除使用的是同一个url（但是不同的请求方法或者参数）的请求的缓存，可以使用下面这个API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] clearCacheWithUrl:@&quot;toutiao/index&quot;</div><div class="line">                                    completionBlock:^(BOOL isSuccess) &#123;</div><div class="line"></div><div class="line">     if (isSuccess) &#123;</div><div class="line">       NSLog(@&quot;Clearing cache successfully!&quot;);</div><div class="line">     &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果你想删除使用同一个url和method，但是不同请求参数的的请求的缓存，可以使用下面这个API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] clearCacheWithUrl:@&quot;toutiao/index&quot;</div><div class="line">                                             method:@&quot;POST&quot;</div><div class="line">                                withCompletionBlock:^(BOOL isSuccess) &#123;</div><div class="line">     if (isSuccess) &#123;</div><div class="line">        NSLog(@&quot;Clearing cache successfully!&quot;);</div><div class="line">     &#125;</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>看完了缓存的读取和删除，我们来看一下缓存的计算:</p>
<h3 id="缓存的计算"><a href="#缓存的计算" class="headerlink" title="缓存的计算"></a>缓存的计算</h3><p>缓存的计算只提供了一个接口，在block回调的时候会回传一个文件个数，所有缓存的大小，以及带有KB或MB的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] calculateCacheSizeWithCompletionBlock:^(NSUInteger fileCount, NSUInteger totalSize, NSString *totalSizeString) &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;file count :%lu and total size:%lu total size string:%@&quot;,(unsigned long)fileCount,(unsigned long)totalSize, totalSizeString);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>fileCount:缓存文件的个数，为整数</p>
<p>total size：单位为字节</p>
<p>totalSizeString：带有KB和MB转化的字符串：在1024*1024字节以内以KB为单位；以外以MB为单位。例如：<figure class="highlight plain"><figcaption><span>count :5 and total size:1298609 total size string:1.2385 MB```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt; **注意：**所计算的缓存包括所有普通请求的缓存以及未下载完成，以后需要继续下载的数据。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 上传功能</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">上传图片的功能是由``SJNetworkUploadManager`类的单例实现的：支持上传单个与多个``UIImage``对象，可以设置压缩比率（不设置时默认为1，不压缩）。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 单张图片，原图上传</div><div class="line"></div><div class="line">上传单个UIImage对象，上传前不对图片进行压缩：</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">```objective-c</div><div class="line">[[SJNetworkManager sharedManager]  sendUploadImageRequest:@&quot;api&quot;</div><div class="line">                                               parameters:nil</div><div class="line">                                                    image:image_1</div><div class="line">                                                     name:@&quot;color&quot;</div><div class="line">                                                 mimeType:@&quot;png&quot;</div><div class="line">                                                 progress:^(NSProgress *uploadProgress) </div><div class="line">&#123;</div><div class="line"></div><div class="line">    self.progressView.observedProgress = uploadProgress;</div><div class="line"></div><div class="line">&#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;upload succeed&quot;);</div><div class="line"></div><div class="line">&#125; failure:^(NSURLSessionTask *task, NSError *error, NSInteger statusCode, NSArray&lt;UIImage *&gt; *uploadFailedImages) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;upload failed, failed images:%@&quot;,uploadFailedImages);</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="多张图片，压缩一半"><a href="#多张图片，压缩一半" class="headerlink" title="多张图片，压缩一半"></a>多张图片，压缩一半</h3><p>上传多个UIImage对象，压缩比率为0.5：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager]  sendUploadImagesRequest:@&quot;api&quot;</div><div class="line">                                                parameters:nil</div><div class="line">                                                    images:@[image_1,image_2]</div><div class="line">                                             compressRatio:0.5</div><div class="line">                                                      name:@&quot;images&quot;</div><div class="line">                                                  mimeType:@&quot;jpg&quot;</div><div class="line">                                                  progress:^(NSProgress *uploadProgress) </div><div class="line">&#123;</div><div class="line"></div><div class="line">    self.progressView.observedProgress = uploadProgress;</div><div class="line"></div><div class="line">&#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;upload succeed&quot;);</div><div class="line"></div><div class="line">&#125; failure:^(NSURLSessionTask *task, NSError *error, NSInteger statusCode, NSArray&lt;UIImage *&gt; *uploadFailedImages) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;upload failed, failed images:%@&quot;,uploadFailedImages);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>这里的mimeType可以设置为jpg/JPG, png/PNG, jpeg/JPEG，作为图片上传到服务器时的类型。需要注意的是，如果mimeType为png/PNG的时候，设置的压缩比率就是无效的，将会一定以原图大小上传。</p>
</blockquote>
<h3 id="忽略设置过的BaseUrl"><a href="#忽略设置过的BaseUrl" class="headerlink" title="忽略设置过的BaseUrl"></a>忽略设置过的BaseUrl</h3><p>考虑到上传图片的服务器可能与普通请求的服务器不同，特意增加了一个参数：<code>ignoreBaseUrl</code>。如果该布尔值设置为YES，则在<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```objective-c</div><div class="line">[[SJNetworkManager sharedManager]  sendUploadImagesRequest:@&quot;http://uploads.im/api&quot;</div><div class="line">                                               ignoreBaseUrl:YES</div><div class="line">                                                  parameters:nil</div><div class="line">                                                      images:@[image_1,image_2]</div><div class="line">                                               compressRatio:0.5</div><div class="line">                                                        name:@&quot;images&quot;</div><div class="line">                                                    mimeType:@&quot;jpg&quot;</div><div class="line">                                                    progress:^(NSProgress *uploadProgress) </div><div class="line">  &#123;</div><div class="line"></div><div class="line">      self.progressView.observedProgress = uploadProgress;</div><div class="line"></div><div class="line">  &#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;upload succeed&quot;);</div><div class="line"></div><div class="line">  &#125; failure:^(NSURLSessionTask *task, NSError *error, NSInteger statusCode, NSArray&lt;UIImage *&gt; *uploadFailedImages) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;upload failed, failed images:%@&quot;,uploadFailedImages);</div><div class="line"></div><div class="line">  &#125;];</div></pre></td></tr></table></figure></p>
<p>还有一个方法，就是强制更改<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```objective-c</div><div class="line">[SJNetworkConfig sharedConfig].baseUrl = @&quot;http://uploads.im&quot;;</div><div class="line">[[SJNetworkManager sharedManager]  sendUploadImagesRequest:@&quot;api&quot;</div><div class="line">                                             ignoreBaseUrl:NO</div><div class="line">                                                parameters:nil</div><div class="line">                                                    images:@[image_3,image_4]</div><div class="line">                                             compressRatio:0.5</div><div class="line">                                                      name:@&quot;color&quot;</div><div class="line">                                                  mimeType:@&quot;png&quot;</div><div class="line">                                                  progress:^(NSProgress *uploadProgress) </div><div class="line">&#123;</div><div class="line"></div><div class="line">    self.progressView.observedProgress = uploadProgress;</div><div class="line"></div><div class="line">&#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;upload succeed&quot;);</div><div class="line"></div><div class="line">&#125; failure:^(NSURLSessionTask *task, NSError *error, NSInteger statusCode, NSArray&lt;UIImage *&gt; *uploadFailedImages) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;upload failed, failed images:%@&quot;,uploadFailedImages);</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>虽然看上去不是很优雅，但却也是可行的：在请求所有普通网络请求之前将baseUrl再次改回去即可。</p>
<p>暂时该框架还无法支持多个baseUrl的功能，以后如果有研究到的话就会添加上去。</p>
<h2 id="下载功能"><a href="#下载功能" class="headerlink" title="下载功能"></a>下载功能</h2><p>下载功能是由<code>SJNetworkDownloadManager</code>的单例来实现的，支持断点续传以及后台下载。</p>
<ul>
<li>如果设置为支持后台下载，则在内部生成的task类为：<code>NSURLSessionDownloadTask</code>。在手机退出前台，进入后台后后仍然可以下载。</li>
<li>如果设置为不支持后台下载，则在内部生成的task类为：<code>NSURLSessionDataTask</code>。在手机退出前台后无法继续下载，但是通过框架内部的<strong>自动恢复下载机制</strong>，在回到前台后就会继续之前的下载。而且结合了<code>NSOutputStream</code>实例，将下载下来的数据一点一点的写在沙盒里面，减少了内存的压力，也就是支持大文件下载。</li>
<li>如果支持断点续传，则由于断网或者取消请求等造成的下载失败后会保存未下载完成的数据。在后来启动该下载任务后，会继续下载。</li>
<li>如果不支持断点续传，则不会保留未下载完成的数据。在后来启动该下载后只能从头开始下载。</li>
</ul>
<p>综上会是由四种情况：</p>
<table>
<thead>
<tr>
<th></th>
<th>支持断点续传</th>
<th>不支持断点续传</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持后台下载</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>不支持后台下载</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p><strong>默认配置</strong>为：支持断点续传，不支持后台下载（因为除非是音乐视频类等特殊app，后台下载的操作可能会被Apple拒掉）。</p>
<h3 id="下载接口"><a href="#下载接口" class="headerlink" title="下载接口"></a>下载接口</h3><h4 id="默认的下载功能（支持断点续传，不支持后台下载）："><a href="#默认的下载功能（支持断点续传，不支持后台下载）：" class="headerlink" title="默认的下载功能（支持断点续传，不支持后台下载）："></a>默认的下载功能（支持断点续传，不支持后台下载）：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] sendDownloadRequest:@&quot;wallpaper.jpg&quot;</div><div class="line">                                     downloadFilePath:_imageFileLocalPath</div><div class="line">                                             progress:^(NSInteger receivedSize, NSInteger expectedSize, CGFloat progress)</div><div class="line">&#123;</div><div class="line">       self.progressView.progress = progress;</div><div class="line"></div><div class="line">&#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;Download succeed!&quot;);</div><div class="line"></div><div class="line">&#125; failure:^(NSURLSessionTask *task, NSError *error, NSString *resumableDataPath) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;Download failed!&quot;);</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>如果支持断点续传，在返回失败的回调里面会传过来未下载完成数据的路径：<code>resumableDataPath</code>。</p>
</blockquote>
<h4 id="不支持断点续传，不支持后台下载："><a href="#不支持断点续传，不支持后台下载：" class="headerlink" title="不支持断点续传，不支持后台下载："></a>不支持断点续传，不支持后台下载：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] sendDownloadRequest:@&quot;half-eatch.jpg&quot;</div><div class="line">                                     downloadFilePath:_imageFileLocalPath</div><div class="line">                                            resumable:NO</div><div class="line">                                    backgroundSupport:NO</div><div class="line">                                             progress:^(NSInteger receivedSize, NSInteger expectedSize, CGFloat progress) </div><div class="line">&#123;</div><div class="line"></div><div class="line">    self.progressView.progress = progress;</div><div class="line"></div><div class="line">&#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;Download succeed!&quot;);</div><div class="line"></div><div class="line">&#125; failure:^(NSURLSessionTask *task, NSError *error, NSString *resumableDataPath) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;Download failed!&quot;);</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="支持断点续传，支持后台下载："><a href="#支持断点续传，支持后台下载：" class="headerlink" title="支持断点续传，支持后台下载："></a>支持断点续传，支持后台下载：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] sendDownloadRequest:@&quot;universe.jpg&quot;</div><div class="line">                                     downloadFilePath:_imageFileLocalPath</div><div class="line">                                            resumable:YES</div><div class="line">                                    backgroundSupport:YES</div><div class="line">                                             progress:^(NSInteger receivedSize, NSInteger expectedSize, CGFloat progress)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    self.progressView.progress = progress;</div><div class="line"></div><div class="line">&#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;Download succeed!&quot;);</div><div class="line"></div><div class="line">&#125; failure:^(NSURLSessionTask *task, NSError *error, NSString *resumableDataPath) &#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;Download failed!&quot;);</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="不支持断点续传，支持后台下载："><a href="#不支持断点续传，支持后台下载：" class="headerlink" title="不支持断点续传，支持后台下载："></a>不支持断点续传，支持后台下载：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] sendDownloadRequest:@&quot;iceberg.jpg&quot;</div><div class="line">                                     downloadFilePath:_imageFileLocalPath</div><div class="line">                                            resumable:NO</div><div class="line">                                    backgroundSupport:YES</div><div class="line">                                             progress:^(NSInteger receivedSize, NSInteger expectedSize, CGFloat progress)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    self.progressView.progress = progress;</div><div class="line"></div><div class="line"> &#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">     NSLog(@&quot;Download succeed!&quot;);</div><div class="line"></div><div class="line"> &#125; failure:^(NSURLSessionTask *task, NSError *error, NSString *resumableDataPath) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;Download failed!&quot;);</div><div class="line"></div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>和上传一样，下载接口也都支持是否忽略baseUrl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] sendDownloadRequest:@&quot;http://oih3a9o4n.bkt.clouddn.com/wallpaper.jpg&quot;</div><div class="line">                                        ignoreBaseUrl:YES</div><div class="line">                                     downloadFilePath:_imageFileLocalPath</div><div class="line">                                             progress:^(NSInteger receivedSize, NSInteger expectedSize, CGFloat progress)</div><div class="line">&#123;</div><div class="line">      self.progressView.progress = progress;</div><div class="line"></div><div class="line">&#125; success:^(id responseObject) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;Download succeed!&quot;);</div><div class="line"></div><div class="line">&#125; failure:^(NSURLSessionTask *task, NSError *error, NSString *resumableDataPath) &#123;</div><div class="line"></div><div class="line">      NSLog(@&quot;Download failed!&quot;);</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="下载的暂停，恢复和取消"><a href="#下载的暂停，恢复和取消" class="headerlink" title="下载的暂停，恢复和取消"></a>下载的暂停，恢复和取消</h3><p>所有的下载请求都支持暂停，恢复和取消操作。并且这些操作都支持单独与批量操作：</p>
<h4 id="下载的暂停"><a href="#下载的暂停" class="headerlink" title="下载的暂停"></a>下载的暂停</h4><p>暂停单独的下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] suspendDownloadRequest:@&quot;universe.jpg&quot;];</div></pre></td></tr></table></figure>
<p>暂停多个下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] suspendDownloadRequests:@[@&quot;universe.jpg&quot;,@&quot;wallpaper.jpg&quot;]];</div></pre></td></tr></table></figure>
<p>暂停所有下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] suspendAllDownloadRequests];</div></pre></td></tr></table></figure>
<h4 id="下载的恢复"><a href="#下载的恢复" class="headerlink" title="下载的恢复"></a>下载的恢复</h4><p>恢复单独的正在暂停的下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] resumeDownloadReqeust:@&quot;universe.jpg&quot;];</div></pre></td></tr></table></figure>
<p>恢复多个正在暂停的下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] resumeDownloadReqeusts:@[@&quot;universe.jpg&quot;,@&quot;wallpaper.jpg&quot;]];</div></pre></td></tr></table></figure>
<p>恢复所有正在暂停的下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] resumeAllDownloadRequests];</div></pre></td></tr></table></figure>
<h4 id="下载的取消"><a href="#下载的取消" class="headerlink" title="下载的取消"></a>下载的取消</h4><p>取消单独的下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] cancelDownloadRequest:@&quot;universe.jpg&quot;];</div></pre></td></tr></table></figure>
<p>取消多个下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] cancelDownloadRequests:@[@&quot;universe.jpg&quot;,@&quot;wallpaper.jpg&quot;]];</div></pre></td></tr></table></figure>
<p>取消所有下载请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] cancelAllDownloadRequests];</div></pre></td></tr></table></figure>
<h2 id="请求的管理"><a href="#请求的管理" class="headerlink" title="请求的管理"></a>请求的管理</h2><p>在该框架中，无论是普通的下载请求，上传请求和下载请求，在发送请求之前都将用户传入的参数保存在专门的请求对象<code>SJNetworkRequestModel</code>的实例里面。而这些实例的管理工作交给了<code>SJNetworkRequestPool</code>类的单例：</p>
<ul>
<li>在请求开始之前，将请求实例放入其中的一个字典里管理。</li>
<li>当请求结束以后，将所对应的请求实例移除。</li>
</ul>
<p>除了添加和移除请求对象以外，<code>SJNetworkRequestPool</code>对请求的管理还包括：</p>
<ul>
<li>对正在进行的请求状况的查询</li>
<li>对正在进行的请求的取消。</li>
</ul>
<h3 id="请求状况的查询"><a href="#请求状况的查询" class="headerlink" title="请求状况的查询"></a>请求状况的查询</h3><h4 id="是否仍然有正在进行的请求："><a href="#是否仍然有正在进行的请求：" class="headerlink" title="是否仍然有正在进行的请求："></a>是否仍然有正在进行的请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BOOL remaining =  [[SJNetworkManager sharedManager] remainingCurrentRequests];</div><div class="line">if (remaining) &#123;</div><div class="line">    NSLog(@&quot;There is remaining request&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="正在进行的请求个数："><a href="#正在进行的请求个数：" class="headerlink" title="正在进行的请求个数："></a>正在进行的请求个数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSUInteger count = [[SJNetworkManager sharedManager] currentRequestCount];</div><div class="line">if (count &gt; 0) &#123;</div><div class="line">    NSLog(@&quot;There is %lu requests&quot;,(unsigned long)count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="打印所有正在进行的请求对象："><a href="#打印所有正在进行的请求对象：" class="headerlink" title="打印所有正在进行的请求对象："></a>打印所有正在进行的请求对象：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] logAllCurrentRequests];</div></pre></td></tr></table></figure>
<h3 id="请求的取消"><a href="#请求的取消" class="headerlink" title="请求的取消"></a>请求的取消</h3><p>请求的取消也分为单个和批量的取消：</p>
<h4 id="取消某个请求："><a href="#取消某个请求：" class="headerlink" title="取消某个请求："></a>取消某个请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] cancelCurrentRequestWithUrl:@&quot;toutiao/index&quot;</div><div class="line">                                                           method:@&quot;POST&quot;</div><div class="line">                                                       parameters:@&#123;@&quot;type&quot;:@&quot;top&quot;,</div><div class="line">                                                                    @&quot;key&quot; :@&quot;0c60&quot;&#125;];</div></pre></td></tr></table></figure>
<h4 id="取消相同url的请求："><a href="#取消相同url的请求：" class="headerlink" title="取消相同url的请求："></a>取消相同url的请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] cancelCurrentRequestWithUrl:@&quot;toutiao/index&quot;];</div></pre></td></tr></table></figure>
<h4 id="取消多个指定url的请求："><a href="#取消多个指定url的请求：" class="headerlink" title="取消多个指定url的请求："></a>取消多个指定url的请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] cancelDownloadRequests:@[@&quot;toutiao/index&quot;,@&quot;weixin/query&quot;]];</div></pre></td></tr></table></figure>
<h4 id="取消所有正在进行的请求："><a href="#取消所有正在进行的请求：" class="headerlink" title="取消所有正在进行的请求："></a>取消所有正在进行的请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[SJNetworkManager sharedManager] cancelAllCurrentRequests];</div></pre></td></tr></table></figure>
<h2 id="Log输出"><a href="#Log输出" class="headerlink" title="Log输出"></a>Log输出</h2><p>如果将debug模式设置为YES，则会打印出很多便于调试的log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SJNetworkConfig sharedConfig].debugMode = YES;</div></pre></td></tr></table></figure>
<h3 id="请求对象的log"><a href="#请求对象的log" class="headerlink" title="请求对象的log"></a>请求对象的log</h3><p>由于重写了<code>SJNetworkRequestModel</code>的<code>description</code>方法，所以在打印该对象的时候，普通的网络请求，上传请求，下载请求都有属于自己的log，在这里举一个普通请求的log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   &lt;SJNetworkRequestModel: 0x6040001fc100&gt;</div><div class="line">   type:             ordinary request</div><div class="line">   method:          GET</div><div class="line">   url:             http://v.juhe.cn/toutiao/index</div><div class="line">   parameters:      &#123;</div><div class="line">    &quot;app_version&quot; = &quot;1.0&quot;;</div><div class="line">    key = 0c60;</div><div class="line">    platform = iOS;</div><div class="line">    type = top;</div><div class="line">&#125;</div><div class="line">   loadCache:       YES</div><div class="line">   cacheDuration:   5 seconds</div><div class="line">   requestIdentifer:b4b36793efabad54a14389cf09bc8133_a6a72ddee1dd86825cb5707c500784f5_7b65261ff298c6a386c89a632bd17b39_30c9b994c268547f38a2f9af6f8c171f</div><div class="line">   task:            &lt;__NSCFLocalDataTask: 0x7f8e075320a0&gt;&#123; taskIdentifier: 1 &#125; &#123; completed &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="请求和缓存的log"><a href="#请求和缓存的log" class="headerlink" title="请求和缓存的log"></a>请求和缓存的log</h3><p>举一个需要获取缓存的网络请求但是遇到缓存过期的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">=========== Load cache info failed, reason:Cache is expired, begin to clear cache...</div><div class="line">=========== Load cache failed: Cache info is invalid </div><div class="line">=========== Faild to load cache, start to sending network request...</div><div class="line">=========== Start requesting...</div><div class="line">=========== url:http://v.juhe.cn/toutiao/index</div><div class="line">=========== method:GET</div><div class="line">=========== parameters:&#123;</div><div class="line">    &quot;app_version&quot; = &quot;1.0&quot;;</div><div class="line">    key = 0c60;</div><div class="line">    platform = iOS;</div><div class="line">    type = top;</div><div class="line">&#125;</div><div class="line">=========== Request succeed! </div><div class="line">=========== Request url:http://v.juhe.cn/toutiao/index</div><div class="line">=========== Response object:&#123;</div><div class="line">  code = 200,</div><div class="line">  msg = &quot;&quot;,</div><div class="line">  data = &#123;&#125;</div><div class="line">&#125;</div><div class="line">=========== Write cache succeed!</div><div class="line">=========== cache object: &#123;</div><div class="line">  code = 200,</div><div class="line">  msg = &quot;&quot;,</div><div class="line">  data = &#123;&#125;</div><div class="line">&#125;</div><div class="line">=========== Cache path: /Users/****/***/***/*******.cacheData</div><div class="line">=========== Available duration: 180 seconds</div></pre></td></tr></table></figure>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>在调试这个框架的时候使用了很多网络资源，也看了好多文章，获得了很多帮助，所以不得不提一下：</p>
<h2 id="API服务"><a href="#API服务" class="headerlink" title="API服务"></a>API服务</h2><ul>
<li>免费的接口服务：<a href="https://www.juhe.cn/" target="_blank" rel="external">聚合数据</a></li>
<li>上传图片的接口服务：<a href="http://uploads.im" target="_blank" rel="external">Uploads</a></li>
<li>下载图片的图床：<a href="https://portal.qiniu.com/" target="_blank" rel="external">七牛云开发者平台</a></li>
</ul>
<h2 id="使用和参考的框架"><a href="#使用和参考的框架" class="headerlink" title="使用和参考的框架"></a>使用和参考的框架</h2><ul>
<li><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a></li>
<li><a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.jianshu.com/p/f65e32012f07" target="_blank" rel="external">iOS开发网络篇之文件下载、大文件下载、断点下载</a></li>
<li><a href="http://www.jianshu.com/p/1211cf99dfc3" target="_blank" rel="external">iOS使用NSURLSession进行下载（包括后台下载，断点下载）</a></li>
<li><a href="https://www.cnblogs.com/goodboy-heyang/p/5195806.html" target="_blank" rel="external">iOS开发之网络编程 –2. NSURLSessionDownloadTask文件下载</a></li>
<li><a href="http://www.cnblogs.com/machao/p/5864251.html" target="_blank" rel="external">MCDownloadManager ios文件下载管理器</a></li>
<li><a href="http://www.jianshu.com/p/5e6630e999fa?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="external">华山论剑之浅谈iOS的文件下载,断点下载(基于NSURLSession的网络请求)</a></li>
</ul>
<h1 id="框架传送门"><a href="#框架传送门" class="headerlink" title="框架传送门"></a>框架传送门</h1><p>GitHub地址：<a href="https://github.com/knightsj/SJNetwork">SJNetwork</a></p>
<blockquote>
<p>里面附有demo</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>现在社区里二次封装AFNetworking，上传图片，以及下载器的框架有很多，但是因为总是想写一个<strong>属于自己代码风格的框架</strong>，而且网络层对我自己还是有些挑战的，所以想试一试。</p>
<p>除去中间间隔的时间，整个框架基本成型的时间用了有一个多月，但是写全英文的注释，最后的重构（修改了架构，分离了一些类），命名的规范，修改bug，优化等事情又花去了半个月。特别是由于自己对下载这一块不熟，尤其是断点续传，后台下载这两方面更是没有实战经验，在写的时候也花了不少时间。</p>
<p>希望能多给出宝贵意见和建议，我自己发现有不足的地方也会更新~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;该框架是一个通用的网络层，可以供给不同app的业务层调用。该框架封装了AFNetworking，而且有些地方借鉴了YTKNetwork的设计思路：以对象的形式封装并管理请求。&lt;/p&gt;
&lt;p&gt;它在功能上支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送请求方法为GET，POST，PUT，DELETE的普通网络请求的功能&lt;/li&gt;
&lt;li&gt;上传图片功能（单张与多张上传，指定上传前的图片压缩比率）&lt;/li&gt;
&lt;li&gt;下载功能（支持断点续传和后台下载）&lt;/li&gt;
&lt;li&gt;缓存管理（写入，读取，清除缓存，计算大小）功能&lt;/li&gt;
&lt;li&gt;请求管理（查看正在进行的请求的状态，请求的单个与批量取消）功能&lt;/li&gt;
&lt;li&gt;设置请求体里的默认键值对（eg.需要添加版本号进行版本控制）&lt;/li&gt;
&lt;li&gt;添加请求头（eg.针对一些需要使用token的服务）&lt;/li&gt;
&lt;li&gt;设置服务器地址&lt;/li&gt;
&lt;li&gt;设置debug模式（调试时打印出便于调试的log，比如读取缓存失败的具体原因）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GitHub链接：&lt;a href=&quot;https://github.com/knightsj/SJNetwork&quot;&gt;SJNetwork&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;里面附有demo&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>如何提高代码的可读性? -读《编写可读代码的艺术》</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/11/13/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/11/13/如何提高代码的可读性/</id>
    <published>2017-11-13T04:13:23.282Z</published>
    <updated>2017-11-13T04:34:52.965Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-63f87902508af82e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《编写可读代码的艺术》封面"></p>
<h1 id="一-为什么读这本书"><a href="#一-为什么读这本书" class="headerlink" title="一. 为什么读这本书"></a>一. 为什么读这本书</h1><p>很多同行在编写代码的时候往往只关注一些宏观上的主题：架构，设计模式，数据结构等等，却忽视了一些更细节上的点：比如变量如何命名与使用，控制流的设计，以及注释的写法等等。以上这些细节上的东西可以用<strong>代码的可读性</strong>来概括。</p>
<p>不同于宏观上的架构，设计模式等需要好几个类，好几个模块才能看出来：代码的可读性是能够立刻从微观上的，一个变量的命名，函数的逻辑划分，注释的信息质量里面看出来的。</p>
<p>宏观层面上的东西固然重要，但是代码的可读性也属于评价代码质量的一个无法让人忽视的指标：它影响了阅读代码的成本（毕竟代码注意是给人看的），甚至会影响代码出错的概率！</p>
<p>这里引用《编写可读代码的艺术》这本书里的一句话:</p>
<blockquote>
<p>对于一个整体的软件系统而言，既需要宏观的架构决策，设计与指导原则，也必须重视围观的代码细节。在软件历史中，有许多影响深远的重大失败，其根源往往是编码细节出现了疏漏。</p>
</blockquote>
<p>因此笔者认为代码的可读性可以作为考量一名程序员专业程度的指标。</p>
<p>或许已经有很多同行也正在努力提高自己代码的可读性。然而这里有一个很典型的错觉（笔者之前就有这种错觉）是：越少的代码越容易让人理解。</p>
<p>但是事实上，并不是代码越精简就越容易让人理解。相对于追求最小化代码行数，一个更好的提高可读性方法是<strong>最小化人们理解代码所需要的时间。</strong></p>
<p>这就引出了这本中的一个核心定理：</p>
<blockquote>
<p>可读性基本定理：代码的写法应当使别人理解它所需要的时间最小化。</p>
</blockquote>
<p>正式这句话深深地吸引了我，于是决定利用这两周的业余时间读完并总结了这本书。</p>
<p>这本书讲的就是关于”如何提高代码的可读性“。<br>总结下来，这本书从浅入深，在三个层次告诉了我们如何让代码易于理解：</p>
<ul>
<li>表层上的改进：在命名方法（变量名，方法名），变量声明，代码格式，注释等方面的改进。</li>
<li>控制流和逻辑的改进：在控制流，逻辑表达式上让代码变得更容易理解。</li>
<li>结构上的改进：善于抽取逻辑，借助自然语言的描述来改善代码。</li>
</ul>
<a id="more"></a>
<h1 id="二-表层的改进"><a href="#二-表层的改进" class="headerlink" title="二. 表层的改进"></a>二. 表层的改进</h1><p>首先来讲最近简单的一层如何改进，涉及到以下几点：</p>
<ul>
<li>如何命名</li>
<li>如何声明与使用变量</li>
<li>如何简化表达式</li>
<li>如何让代码具有美感</li>
<li>如何写注释</li>
</ul>
<h2 id="如何命名"><a href="#如何命名" class="headerlink" title="如何命名"></a>如何命名</h2><p>关于如何命名，作者提出了一个关键思想：</p>
<blockquote>
<p>关键思想：把尽可能多的信息装入名字中。</p>
</blockquote>
<p>这里的多指的是有价值的多。那么如何做到有价值呢？作者介绍了以下几个建议：</p>
<ul>
<li>选择专业的词汇，避免泛泛的名字</li>
<li>给名字附带更多信息</li>
<li>决定名字最适合的长度</li>
<li>名字不能引起歧义</li>
</ul>
<h3 id="选择专业的词汇，避免泛泛的名字"><a href="#选择专业的词汇，避免泛泛的名字" class="headerlink" title="选择专业的词汇，避免泛泛的名字"></a>选择专业的词汇，避免泛泛的名字</h3><p>一个比较常见的反例：<code>get</code> 。</p>
<p><code>get</code>这个词最好是用来做轻量级的取方法的开头，而如果用到其他的地方就会显得很不专业。</p>
<p>举个书中的例子：</p>
<p><code>getPage(url)</code></p>
<p>通过这个方法名很难判断出这个方法是从缓存中获取页面数据还是从网页中获取。如果是从网页中获取，更专业的词应该是<code>fetchPage(url)</code>或者<code>downloadPage(url)</code>。</p>
<p>还有一个比较常见的反例：<code>returnValue</code>和<code>retval</code>。这两者都是“返回值”的意思，他们被滥用在各个有返回值的函数里面。其实这两个次除了携带他们本来的意思<code>返回值</code>以外并不具备任何其他的信息，是典型的泛泛的名字。</p>
<p>那么如何选择一个专业的词汇呢？答案是在非常贴近你自己的意图的基础上，选择一个富有表现力的词汇。</p>
<p>举几个例子：</p>
<ul>
<li>相对于<code>make</code>，选择<code>create</code>,<code>generate</code>,<code>build</code>等词汇会更有表现力，更加专业。</li>
<li>相对于<code>find</code>，选择<code>search</code>,<code>extract</code>,<code>recover</code>等词汇会更有表现力，更加专业。</li>
<li>相对于<code>retval</code>，选择一个能充分描述这个返回值的性质的名字，例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> euclidean_norm = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> retval = <span class="number">0.0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; v.length; i += <span class="number">1</span>;)</div><div class="line">       retval += v[i] * v[i];</div><div class="line">    <span class="keyword">return</span> Match.sqrt(retval);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的retval表示的是“平方的和”，因此<code>sum_squares</code>这个词更加贴切你的意图，更加专业。</p>
<p>但是，有些情况下，泛泛的名字也是有意义的，例如一个交换变量的情景：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (right &lt; left)&#123;</div><div class="line">    tmp = right;</div><div class="line">    right = left;</div><div class="line">    left = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面这种<code>tmp</code>只是作为一个临时存储的情况下，tmp表达的意思就比较贴切了。因此，像<code>tmp</code>这个名字，只适用于短期存在而且特性为临时性的变量。</p>
<h3 id="给名字附带更多信息"><a href="#给名字附带更多信息" class="headerlink" title="给名字附带更多信息"></a>给名字附带更多信息</h3><p>除了选择一个专业，贴切意图的词汇，我们也可以通过添加一些前后缀来给这个词附带更多的信息。这里所指的更多的信息有三种：</p>
<ul>
<li>变量的单位</li>
<li>变量的属性</li>
<li>变量的格式</li>
</ul>
<h4 id="为变量添加单位"><a href="#为变量添加单位" class="headerlink" title="为变量添加单位"></a>为变量添加单位</h4><p>有些变量是有单位的，在变量名的后面添加其单位可以让这个变量名携带更多信息：</p>
<ul>
<li>一个表达时间间隔的变量，它的单位是秒：相对于<code>duraction</code>，<code>ducation_secs</code>携带了更多的信息</li>
<li>一个表达内存大小的变量，它的单位是mb：相对于<code>size</code>，<code>cache_mb</code>携带了更多的信息。</li>
</ul>
<h4 id="为变量添加重要属性"><a href="#为变量添加重要属性" class="headerlink" title="为变量添加重要属性"></a>为变量添加重要属性</h4><p>有些变量是具有一些非常重要的属性，其重要程度是不允许使用者忽略的。例如：</p>
<ul>
<li>一个UTF-8格式的html字节，相对于<code>html</code>，<code>html_utf8</code>更加清楚地描述了这个变量的格式。</li>
<li>一个纯文本，需要加密的密码字符串：相对于<code>password</code>，<code>plaintext_password</code>更清楚地描述了这个变量的特点。</li>
</ul>
<h4 id="为变量选择适当的格式"><a href="#为变量选择适当的格式" class="headerlink" title="为变量选择适当的格式"></a>为变量选择适当的格式</h4><p>对于命名，有些既定的格式需要注意：</p>
<ul>
<li>使用大驼峰命名来表示类名：<code>HomeViewController</code>。</li>
<li>使用小驼峰命名来表示属性名：<code>userNameLabel</code>。</li>
<li>使用下划线连接词来表示变量名：<code>product_id</code>。</li>
<li>使用<code>kConstantName</code>来表示常量：<code>kCacheDuraction</code>。</li>
<li>使用MACRO_NAME来表示宏：<code>SCREEN_WIDTH</code>。</li>
</ul>
<h3 id="决定名字最适合的长度"><a href="#决定名字最适合的长度" class="headerlink" title="决定名字最适合的长度"></a>决定名字最适合的长度</h3><p>名字越长越难记住，名字越短所持有的信息就越少，如何决定名字的长度呢？这里有几个原则：</p>
<ul>
<li>如果变量的作用域很小，可以取很短的名字</li>
<li>驼峰命名中的单元不能超过3个</li>
<li>不能使用大家不熟悉的缩写</li>
<li>丢掉不必要的单元</li>
</ul>
<h4 id="如果变量的作用域很小，可以取很短的名字"><a href="#如果变量的作用域很小，可以取很短的名字" class="headerlink" title="如果变量的作用域很小，可以取很短的名字"></a>如果变量的作用域很小，可以取很短的名字</h4><p>如果一个变量作用域很小：则可以给它取一个很短的名字也无妨。</p>
<p>看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(debug)&#123;</div><div class="line">    map &lt;string,<span class="keyword">int</span>&gt;m;</div><div class="line">    LookUpNamesNumbers(&amp;m);</div><div class="line">    Print(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，变量的类型和使用范围一眼可见，读者可以了解这段代码的所有信息，所以即使是取<code>m</code>这个非常简短的名字，也不影响读者来理解作者的意图。</p>
<p>相反的，如果<code>m</code>是一个全局变量，当你看到下面这段代码就会很头疼，因为你不知道它的类型并不明确:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LookUpNamesNumbers(&amp;m);</div><div class="line">Print(m);</div></pre></td></tr></table></figure>
<h4 id="驼峰命名中的单元不能超过3个"><a href="#驼峰命名中的单元不能超过3个" class="headerlink" title="驼峰命名中的单元不能超过3个"></a>驼峰命名中的单元不能超过3个</h4><p>我们知道驼峰命名可以很清晰地体现变量的含义，但是当驼峰命名中的单元超过了3个之后，就会很影响阅读体验:</p>
<p><code>userFriendsInfoModel</code></p>
<p><code>memoryCacheCalculateTool</code></p>
<p>是不是看上去很吃力？因为我们大脑同时可以记住的信息非常有限，尤其是在看代码的时候，这种短期记忆的局限性是无法让我们同时记住或者瞬间理解几个具有3~4个单元的变量名的。所以我们需要在变量名里面去除一些不必要的单元：</p>
<h4 id="丢掉不必要的单元"><a href="#丢掉不必要的单元" class="headerlink" title="丢掉不必要的单元"></a>丢掉不必要的单元</h4><p>有些单元在变量里面是可以去掉的，例如：</p>
<p><code>convertToString</code>可以省略成<code>toString</code>。</p>
<h4 id="不能使用大家不熟悉的缩写"><a href="#不能使用大家不熟悉的缩写" class="headerlink" title="不能使用大家不熟悉的缩写"></a>不能使用大家不熟悉的缩写</h4><p>有些缩写是大家熟知的：</p>
<ul>
<li><code>doc</code> 可以代替<code>document</code></li>
<li><code>str</code> 可以代替<code>string</code></li>
</ul>
<p>但是如果你想用<code>BEManager</code>来代替<code>BackEndManager</code>就比较不合适了。因为不了解的人几乎是无法猜到这个名称的意义的。</p>
<p>所以类似这种情况不能偷懒，该是什么就是什么，否则会起到相反的效果。因为它看起来非常陌生，跟我们熟知的一些缩写规则相去甚远。</p>
<h3 id="名字不能引起歧义"><a href="#名字不能引起歧义" class="headerlink" title="名字不能引起歧义"></a>名字不能引起歧义</h3><p>有些名字会引起歧义，例如：</p>
<ul>
<li>filter：过滤这个词，可以是过滤出符合标准的，也可以是减少不符合标准的：是两种完全相反的结果，所以不推荐使用。</li>
<li>clip：类似的，到底是在原来的基础上截掉某一段还是另外截出来某一段呢？同样也不推荐使用。</li>
<li>布尔值：read_password:是表达需要读取密码，还是已经读了密码呢？所以最好使用<code>need_password</code>或者<code>is_authenticated</code>来代替比较好。通常来说，给布尔值的变量加上<code>is</code>,<code>has</code>,<code>can</code>,<code>should</code>这样的词可以使布尔值表达的意思更加明确</li>
</ul>
<p>这一节讲了很多关于如何起好一个变量名的方法。其实有一个很简单的原则来判断这个变量名起的是否是好的：那就是：<strong>团队的新成员是否能迅速理解这个变量名的含义</strong>。如果是，那么这个命名就是成功的，否则就不要偷懒了，起个好名字，对谁都好。其实如果你养成习惯多花几秒钟想出个好名字，你会发现你的“命名能力”会很快提升。 </p>
<h2 id="如何声明与使用变量"><a href="#如何声明与使用变量" class="headerlink" title="如何声明与使用变量"></a>如何声明与使用变量</h2><p>在写程序的过程中我们会声明很多变量（成员变量，临时变量），而我们要知道变量的声明与使用策略是会对代码的可读性造成影响的：</p>
<ul>
<li>变量越多，越难跟踪它们的动向。</li>
<li>变量的作用域越大，就需要跟踪它们的动向越久。</li>
<li>变量改变的越频繁，就越难跟踪它的当前值。</li>
</ul>
<p>相对的，对于变量的声明与使用，我们可以从这四个角度来提高代码的可读性：</p>
<ol>
<li>减少变量的个数</li>
<li>缩小变量的作用域</li>
<li>缩短变量声明与使用其代码的距离</li>
<li>变量最好只写一次</li>
</ol>
<h3 id="减少变量的个数"><a href="#减少变量的个数" class="headerlink" title="减少变量的个数"></a>减少变量的个数</h3><p>在一个函数里面可能会声明很多变量，但是有些变量的声明是毫无意义的，比如：</p>
<ul>
<li>没有价值的临时变量</li>
<li>表示中间结果的变量</li>
</ul>
<h4 id="没有价值的临时变量"><a href="#没有价值的临时变量" class="headerlink" title="没有价值的临时变量"></a>没有价值的临时变量</h4><p>有些变量的声明完全是多此一举，它们的存在反而加大了阅读代码的成本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> now = datetime.datatime.now()</div><div class="line">root_message.last_view_time = now</div></pre></td></tr></table></figure>
<p>上面这个<code>now</code>变量的存在是毫无意义的，因为：</p>
<ul>
<li>没有拆分任何复杂的表达式</li>
<li><code>datetime.datatime.now</code>已经很清楚地表达了意思</li>
<li>只使用了一次，因此而没有压缩任何冗余的代码</li>
</ul>
<p>所以完全不用这个变量也是完全可以的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root_message.last_view_time = datetime.datatime.now()</div></pre></td></tr></table></figure>
<h4 id="表示中间结果的变量"><a href="#表示中间结果的变量" class="headerlink" title="表示中间结果的变量"></a>表示中间结果的变量</h4><p>有的时候为了达成一个目标，把一件事情分成了两件事情来做，这两件事情中间需要一个变量来传递结果。但往往这件事情不需要分成两件事情来做，这个“中间结果”也就不需要了：</p>
<p>看一个比较常见的需求，一个把数组中的某个值移除的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> remove_value = <span class="function"><span class="keyword">function</span> (<span class="params">array, value_to_remove</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> index_to_remove = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i+=<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">if</span> (array[i] === value_to_remove)&#123;</div><div class="line">            index_to_remove = i;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (index_to_remove !== <span class="literal">null</span>)&#123;</div><div class="line">        array.splice(index_to_remove,<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面把这个事情分成了两件事情来做：</p>
<ol>
<li>找出要删除的元素的序号，保存在变量<code>index_to_remove</code>里面。</li>
<li>拿到<code>index_to_remove</code>以后使用<code>splice</code>方法删除它。（这段代码是JavaScript代码）</li>
</ol>
<p>这个例子对于变量的命名还是比较合格的，但实际上这里所使用的中间结果变量是完全不需要的，整个过程也不需要分两个步骤进行。来看一下如何一步实现这个需求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> remove_value = <span class="function"><span class="keyword">function</span> (<span class="params">array, value_to_remove</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i+=<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">if</span> (array[i] === value_to_remove)&#123;</div><div class="line">            array.splice(i,<span class="number">1</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法里面，当知道应该删除的元素的序号<code>i</code>的时候，就直接用它来删除了应该删除的元素并立即返回。</p>
<p>除了减轻了内存和处理器的负担（因为不需要开辟新的内容来存储结果变量以及可能不用完全走遍整个的for语句），阅读代码的人也会很快领会代码的意图。</p>
<p>所以在写代码的时候，如果可以“速战速决”，就尽量使用最快，最简洁的方式来实现目的。</p>
<h3 id="缩小变量的作用域"><a href="#缩小变量的作用域" class="headerlink" title="缩小变量的作用域"></a>缩小变量的作用域</h3><p>变量的作用域越广，就越难追踪它，值也越难控制，所以我们应该让你的<strong>变量对尽量少的代码可见</strong>。</p>
<p>比如类的成员变量就相当于一个“小型局部变量”。如果这个类比较庞大，我们就会很难追踪它，因为所有方法都可以“隐式”调用它。所以相反地，如果我们可以把它“降格”为局部变量，就会很容易追踪它的行踪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//成员变量，比较难追踪</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeCass</span></span>&#123;</div><div class="line">  string str_;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span></span>&#123;</div><div class="line">     str_ = ...;</div><div class="line">     Method2();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="comment">//using str_</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>降格：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//局部变量，容易追踪</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeCass</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span></span>&#123;</div><div class="line">     string str = ...;</div><div class="line">     Method2(str);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Method2</span><span class="params">(string str)</span></span>&#123;</div><div class="line">     <span class="comment">//using str</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以在设计类的时候如果这个数据（变量）可以通过方法参数来传递，就不要以成员变量来保存它。</p>
<h3 id="缩短变量声明与使用其代码的距离"><a href="#缩短变量声明与使用其代码的距离" class="headerlink" title="缩短变量声明与使用其代码的距离"></a>缩短变量声明与使用其代码的距离</h3><p>在实现一个函数的时候，我们可能会声明比较多的变量，但这些变量的使用位置却不都是在函数开头。</p>
<p>有一个比较不好的习惯就是无论变量在当前函数的哪个位置使用，都在一开始（函数的开头）就声明了它们。这样可能导致的问题是：阅读代码的人读到函数后半部分的时候就忘记了这个变量的类型和初始值；而且因为在函数的开头就声明了好几个变量，也对阅读代码的人的大脑造成了负担，因为人的短期记忆是有限的，特别是记一些暂时还不知道怎么用的东西。</p>
<p>因此，如果在函数内部需要在不同地方使用几个不同的变量，建议在真正使用它们之前再声明它。</p>
<h3 id="变量最好只写一次"><a href="#变量最好只写一次" class="headerlink" title="变量最好只写一次"></a>变量最好只写一次</h3><p>操作一个变量的地方越多，就越难确定它的当前值。所以在很多语言里面有其各自的方式让一些变量不可变（是个常量），比如C++里的<code>const</code>和Java中的<code>final</code>。</p>
<h2 id="如何简化表达式"><a href="#如何简化表达式" class="headerlink" title="如何简化表达式"></a>如何简化表达式</h2><p>有些表达式比较长，很难让人马上理解。这时候最好可以将其拆分成更容易的几个小块。可以尝试下面的几个方法：</p>
<ul>
<li>使用解释变量</li>
<li>使用总结变量</li>
<li>使用德摩根定理</li>
</ul>
<h3 id="使用解释变量"><a href="#使用解释变量" class="headerlink" title="使用解释变量"></a>使用解释变量</h3><p>有些变量会从一个比较长的算式得出，这个表达式可能很难让人看懂。这时候就需要用一个简短的“解释”变量来诠释算式的含义。使用书中的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip() == <span class="string">"root"</span></div></pre></td></tr></table></figure>
<p>其实上面左侧的表达式其实得出的是用户名，我们可以用<code>username</code>来替换它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">username = line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip()</div><div class="line"><span class="keyword">if</span> username == <span class="string">"root"</span></div></pre></td></tr></table></figure>
<h3 id="使用总结变量"><a href="#使用总结变量" class="headerlink" title="使用总结变量"></a>使用总结变量</h3><p>除了以“变量”替换“算式”，还可以用“变量”来替换含有更多变量更复杂的内容，比如条件语句，这时候该变量可以被称为”总结变量”。使用书中的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(request.user.id == document.owner_id)&#123;</div><div class="line">   <span class="comment">//do something </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这条判断语句所判断的是：“该文档的所有者是不是该用户”。我们可以使用一个总结性的变量<code>user_owns_document</code>来替换它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> user_owns_document = (request.user.id == document.owner_id);</div><div class="line"><span class="keyword">if</span> (user_owns_document)&#123;</div><div class="line">   <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用德摩根定理"><a href="#使用德摩根定理" class="headerlink" title="使用德摩根定理"></a>使用德摩根定理</h3><p>德摩根定理:</p>
<ol>
<li><code>not(a or b or c)</code>等价于<code>(not a) and (not b) and (not c)</code></li>
<li><code>not(a and b and c)</code>等价于<code>(not a) or (not b) or (not c)</code></li>
</ol>
<p>当我们条件语句里面存在外部取反的情况，就可以使用德摩根定理来做个转换。使用书中的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用德摩根定理转换以前</span></div><div class="line"><span class="keyword">if</span>(!(file_exists &amp;&amp; !is_protected))&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用德摩根定理转换以后</span></div><div class="line"><span class="keyword">if</span>(!file_exists || is_protected)&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="如何让代码具有美感"><a href="#如何让代码具有美感" class="headerlink" title="如何让代码具有美感"></a>如何让代码具有美感</h2><p>在读过一些好的源码之后我有一个感受：好的源码往往都看上去都很漂亮，很有美感。这里说的漂亮和美感不是指代码的逻辑清晰有条理，而是指感官上的视觉感受让人感觉很舒服。这是从一种纯粹的审美的角度来评价代码的：富有美感的代码让人赏心悦目，也容易让人读懂。</p>
<p>为了让代码更有美感，采取以下实践会很有帮助：</p>
<ul>
<li>用换行和列对齐来让代码更加整齐</li>
<li>选择一个有意义的顺序</li>
<li>把代码分成”段落”</li>
<li>保持风格一致性</li>
</ul>
<h3 id="用换行和列对齐来让代码更加整齐"><a href="#用换行和列对齐来让代码更加整齐" class="headerlink" title="用换行和列对齐来让代码更加整齐"></a>用换行和列对齐来让代码更加整齐</h3><p>有些时候，我们可以利用换行和列对齐来让代码显得更加整齐。</p>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>换行比较常用在函数或方法的参数比较多的时候。</p>
<p>使用换行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)requestWithUrl:(NSString*)url </div><div class="line">  				method:(NSString*)method </div><div class="line">                params:(NSDictionary *)params </div><div class="line">               success:(SuccessBlock)success </div><div class="line">               failure:(FailuireBlock)failure&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不使用换行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)requestWithUrl:(NSString*)url method:(NSString*)method params:(NSDictionary *)params success:(SuccessBlock)success failure:(FailuireBlock)failure&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过比较可以看出，如果不使用换行，就很难一眼看清楚都是用了什么参数，而且代码整体看上去整洁干净了很多。</p>
<h4 id="列对齐"><a href="#列对齐" class="headerlink" title="列对齐"></a>列对齐</h4><p>在声明一组变量的时候，由于每个变量名的长度不同，导致了在变量名左侧对齐的情况下，等号以及右侧的内容没有对齐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *name = userInfo[@&quot;name&quot;];</div><div class="line">NSString *sex = userInfo[@&quot;sex&quot;];</div><div class="line">NSString *address = userInfo[@&quot;address&quot;];</div></pre></td></tr></table></figure>
<p>而如果使用了列对齐的方法，让等号以及右侧的部分对齐的方式会使代码看上去更加整洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *name    = userInfo[@&quot;name&quot;];</div><div class="line">NSString *sex     = userInfo[@&quot;sex&quot;];</div><div class="line">NSString *address = userInfo[@&quot;address&quot;];</div></pre></td></tr></table></figure>
<p>这二者的区别在条目数比较多以及变量名称长度相差较大的时候会更加明显。</p>
<h3 id="选择一个有意义的顺序"><a href="#选择一个有意义的顺序" class="headerlink" title="选择一个有意义的顺序"></a>选择一个有意义的顺序</h3><p>当涉及到相同变量（属性）组合的存取都存在的时候，最好以一个有意义的顺序来排列它们：</p>
<ul>
<li>让变量的顺序与对应的HTML表单中<input>字段的顺序相匹配</li>
<li>从最重要到最不重要排序</li>
<li>按照字母排序</li>
</ul>
<p>举个例子：相同集合里的元素同时出现的时候最好保证每个元素出现顺序是一致的。除了便于阅读这个好处以外，也有助于能发现漏掉的部分，尤其当元素很多的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//给model赋值</div><div class="line">model.name	  = dict[&quot;name&quot;]；</div><div class="line">model.sex 	  = dict[&quot;sex&quot;]；</div><div class="line">model.address = dict[&quot;address&quot;]；</div><div class="line"></div><div class="line"> ...</div><div class="line">  </div><div class="line">//拿到model来绘制UI</div><div class="line">nameLabel.text    = model.name;</div><div class="line">sexLabel.text     = model.sex;</div><div class="line">addressLabel.text = model.address;</div></pre></td></tr></table></figure>
<h3 id="把代码分成”段落”"><a href="#把代码分成”段落”" class="headerlink" title="把代码分成”段落”"></a>把代码分成”段落”</h3><p>在写文章的时候，为了能让整个文章看起来结构清晰，我们通常会把大段文字分成一个个小的段落，让表达相同主旨的语言凑到一起，与其他主旨的内容分隔开来。</p>
<p>而且除了让读者明确哪些内容是表达同一主旨之外，把文章分为一个个段落的好处还有便于找到你的阅读”脚印“，便于段落之间的导航；也可以让你的阅读具有一定的节奏感。</p>
<p>其实这些道理同样适用于写代码：如果你可以把一个拥有好几个步骤的大段函数，以空行+注释的方法将每一个步骤区分开来，那么则会对读者理解该函数的功能有极大的帮助。这样一来，代码既能有一定的美感，也具备了可读性。其实可读性又何尝不是来自于规则，富有美感的代码呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BigFunction&#123;</div><div class="line">  </div><div class="line">     <span class="comment">//step1:*****</span></div><div class="line">     ....</div><div class="line">       </div><div class="line">     <span class="comment">//step2:*****</span></div><div class="line">     ...</div><div class="line">        </div><div class="line">     <span class="comment">//step3:*****</span></div><div class="line">     ....</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="保持风格一致性"><a href="#保持风格一致性" class="headerlink" title="保持风格一致性"></a>保持风格一致性</h3><p>有些时候，你的某些代码风格可能与大众比较容易接受的风格不太一样。但是如果你在你自己所写的代码各处能够保持你这种独有的风格，也是可以对代码的可读性有积极的帮助的。</p>
<p>比如一个比较经典的代码风格问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(condition)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>or:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(condition)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上面的两种写法，每个人对条件判断右侧的大括号的位置会有不同的看法。但是无论你坚持的是哪一个，请在你的代码里做到始终如一。因为如果有某几个特例的话，是非常影响代码的阅读体验的。</p>
<p>我们要知道，一个逻辑清晰的代码也可以因为留白的不规则，格式不对齐，顺序混乱而让人很难读懂，这是十分让人痛心的事情。所以既然你的代码在命名上，逻辑上已经很优秀了，就不妨再费一点功夫把她打扮的漂漂亮亮的吧！</p>
<h2 id="如何写注释"><a href="#如何写注释" class="headerlink" title="如何写注释"></a>如何写注释</h2><p>首先引用书中的一句话：</p>
<blockquote>
<p>注释的目的是尽量帮助读者了解得和作者一样多。</p>
</blockquote>
<p>在你写代码的时候，在脑海中可能会留下一些代码里面很难体现出来的部分：这些部分在别人读你的代码的时候可能很难体会到。而这些“不对称”的信息就是需要通过以注释的方式来告诉阅读代码的人。</p>
<p>想要写出好的注释，就需要首先知道：</p>
<ul>
<li>什么不能作为注释</li>
<li>什么应该作为注释</li>
</ul>
<h3 id="什么不能作为注释"><a href="#什么不能作为注释" class="headerlink" title="什么不能作为注释"></a>什么不能作为注释</h3><p>我们都知道注释占用了代码的空间，而且实际上对程序本身的运行毫无帮助，所以最好保证它是<strong>物有所值的</strong>。</p>
<p>不幸的是，有一些注释是毫无价值的，它无情的占用了代码间的空间，影响了阅读代码的人的阅读效率，也浪费了写注释的人的时间。这样的注释有以下两种：</p>
<ul>
<li>描述能立刻从代码自身就能立刻理解的代码意图的注释</li>
<li>给不好的命名添加的注释</li>
</ul>
<h4 id="描述能立刻从代码自身就能立刻理解的代码意图的注释"><a href="#描述能立刻从代码自身就能立刻理解的代码意图的注释" class="headerlink" title="描述能立刻从代码自身就能立刻理解的代码意图的注释"></a>描述能立刻从代码自身就能立刻理解的代码意图的注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//add params1 and params2 and return sum of them</div><div class="line">- (int)addParam1:(int)param1 param2:(int)param2</div></pre></td></tr></table></figure>
<p>上面这个例子举的比较简单，但反映的问题很明显：这里面的注释是完全不需要的，它的存在反而增加了阅读代码的人的工作量。因为他从方法名就可以马上意会到这个函数的作用了。</p>
<h4 id="给不好的命名添加的注释"><a href="#给不好的命名添加的注释" class="headerlink" title="给不好的命名添加的注释"></a>给不好的命名添加的注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)</div></pre></td></tr></table></figure>
<p>讲完了注释不应该是什么内容，现在讲一下注释应该是什么样的内容：</p>
<h3 id="什么应该作为注释"><a href="#什么应该作为注释" class="headerlink" title="什么应该作为注释"></a>什么应该作为注释</h3><p>本书中介绍的注释大概有以下几种：</p>
<ul>
<li><p>写代码时的思考</p>
</li>
<li><p>对代码的评价</p>
</li>
<li><p>常量</p>
</li>
<li><p>全局观的概述</p>
<p>​</p>
</li>
</ul>
<h4 id="写代码时的思考"><a href="#写代码时的思考" class="headerlink" title="写代码时的思考"></a>写代码时的思考</h4><p>你的代码可能不是一蹴而就的，它的产生可能会需要一些思考的过程。然而很多时候代码本身却无法将这些思考表达出来，所以你就可能有必要通过注释的方式来呈现你的思考，让阅读代码的人知道这段代码是哪些思考的结晶，从而也让读者理解了<strong>这段代码为什么这么写</strong>。如果遇到了比你高明的高手，在他看到你的注释之后兴许会马上设计出一套更加合适的方案。</p>
<h4 id="对代码的评价"><a href="#对代码的评价" class="headerlink" title="对代码的评价"></a>对代码的评价</h4><p>有些时候你知道你现在写的代码是个<strong>临时的方案</strong>：它可能确实是解决当前问题的一个方法，但是：</p>
<ul>
<li><p>你知道同时它也存在着某些缺陷，甚至是陷阱</p>
</li>
<li><p>你不知道有其他的方案可以替代了</p>
</li>
<li><p>你知道有哪个方案可以替代但是由于时间的关系或者自身的能力无法实现</p>
<p>​</p>
</li>
</ul>
<p>也可能你知道你现在实现的这个方案几乎就是”完美的“，因为如果使用了其他的方案，可能会消耗更多的资源等等。</p>
<p>对于上面这些情况，你都有必要写上几个字作为注释来诚实的告诉阅读你的这段代码的人这段代码的情况，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//该方案有一个很容易忽略的陷阱：****</div><div class="line">//该方案是存在性能瓶颈，性能瓶颈在其中的**函数中</div><div class="line">//该方案的性能可能并不是最好的，因为如果使用某某算法的话可能会好很多</div></pre></td></tr></table></figure>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在定义常量的时候，在其后面最好添加一个关于它是什么或者为什么它是这个值的原因。因为常量通常是不应该被修改的，所以最好把这个常量为什么是这个值说明一下：</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">image_quality = 0.72 // 最佳的size/quanlity比率</div><div class="line">retry_limit   = 4    // 服务器性能所允许的请求失败的重试上限</div></pre></td></tr></table></figure>
<h4 id="全局观的概述"><a href="#全局观的概述" class="headerlink" title="全局观的概述"></a>全局观的概述</h4><p>对于一个刚加入团队的新人来说，除了团队文化，代码规范以外，可能最需要了解的是当前被分配到的项目的一些“全局观”的认识：比如组织架构，类与类之间如何交互，数据如何保存，如何流动，以及模块的入口点等等。</p>
<p>有时仅仅添加了几句话，可能就会让新人迅速地了解当前系统或者当前类的结构以及作用，而且这些也同样对开发过当前系统的人员迅速回忆出之前开发的细节有很大帮助。</p>
<p>这些注释可以在一个类的开头（介绍这个类的职责，以及在整个系统中的角色）也可以在一个模块入口处。书中举了一个关于这种注释的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//这个文件包含了一些辅助函数，尾门的文件系统提供了更便利的接口</div></pre></td></tr></table></figure>
<p>再举一个iOS开发里众所周知的网络框架<code>AFNetworking</code>的例子。在<code>AFHTTPSessionManager</code>的头文件里说明了这个类的职责：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//AFHTTPSessionManager` is a subclass of `AFURLSessionManager` with convenience methods for making HTTP requests. When a `baseURL` is provided, requests made with the `GET` / `POST` / et al. convenience methods can be made with relative paths</div></pre></td></tr></table></figure>
<p>在知道了什么不应该是注释以及什么应该是注释以后，我们来看一下一个真正合格的注释应该是什么样子的：</p>
<blockquote>
<p>注释应当有很高的信息/空间率</p>
</blockquote>
<p>也就是说，注释应该用最简短的话来最明确地表达。要做到这一点需要做的努力是：</p>
<ul>
<li><strong>让注释保持紧凑</strong>：尽量用最简洁的话来表达，不应该有重复的内容</li>
<li><strong>准确地描述函数的行为</strong>：要把函数的具体行为准确表达出来，不能停留在表明</li>
<li><strong>用输入/输出的例子来说明特别的情况</strong>：有时相对于文字，可能用一个实际的参数和返回值就能立刻体现出函数的作用。而且有些特殊情况也可以通过这个方式来提醒阅读代码的人</li>
<li><strong>声明代码的意图</strong>：也就是说明这段代码存在的意义，你为什么当时是这么写的原因</li>
</ul>
<p>其实好的代码是自解释的，由于其命名的合理以及架构的清晰，几乎不需要注释来向阅读代码的人添加额外的信息，书中有一个公式可以很形象地表明一个好的代码本身的重要性：</p>
<blockquote>
<p>好代码 &gt; (坏代码 + 注释)</p>
</blockquote>
<h1 id="三-控制流和逻辑的改进"><a href="#三-控制流和逻辑的改进" class="headerlink" title="三. 控制流和逻辑的改进"></a>三. 控制流和逻辑的改进</h1><p>控制流在编码中占据着很重要的位置，它往往代表着一些核心逻辑和算法。因此，如果我们可以让控制流变得看上去更加“自然”，那么就会对阅读代码的人理解这些逻辑甚至是整个系统提供很大的帮助。</p>
<p>那么都有哪相关实践呢？</p>
<ul>
<li>使用符合人类自然语言的表达习惯</li>
<li>if/else语句块的顺序</li>
<li>使用return提前返回</li>
</ul>
<h2 id="使用符合人类自然语言的表达习惯"><a href="#使用符合人类自然语言的表达习惯" class="headerlink" title="使用符合人类自然语言的表达习惯"></a>使用符合人类自然语言的表达习惯</h2><p>写代码也是一个表达的过程，虽然表现形式不同，但是如果我们能够采用符合人类自然语言习惯的表达习惯来写代码，对阅读代码的人理解我们的代码是很有帮助的。</p>
<p>这里有两个比较典型的情景：</p>
<ol>
<li>条件语句中参数的顺序</li>
<li>条件语句中的正负逻辑</li>
</ol>
<h3 id="条件语句中参数的顺序："><a href="#条件语句中参数的顺序：" class="headerlink" title="条件语句中参数的顺序："></a>条件语句中参数的顺序：</h3><p>首先比较一下下面两段代码，哪一个更容易读懂？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//code 1</span></div><div class="line"><span class="keyword">if</span>(length &gt; <span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment">//code 2</span></div><div class="line"><span class="keyword">if</span>(<span class="number">10</span> &lt; length)</div></pre></td></tr></table></figure>
<p>大家习惯上应该会觉得code1容易读懂。</p>
<p>再来看下面一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//code 3</span></div><div class="line"><span class="keyword">if</span>(received_number &lt; standard_number) </div><div class="line"></div><div class="line"><span class="comment">//code 4</span></div><div class="line"><span class="keyword">if</span>( standard_number&lt; received_number)</div></pre></td></tr></table></figure>
<p>仔细看会发现，和上面那一组情况类似，大多数人还是会觉得code3更容易读懂。</p>
<p>那么code1 和 code3有什么共性呢？</p>
<p>它们的共性就是：<strong>左侧都是被询问的内容（通常是一个变量）；右侧都是用来做比较的内容（通常是一个常量）</strong></p>
<p>这应该是符合自然语言的一个顺序。比如我们一般会说“今天的气温大于20摄氏度”，而不习惯说“20摄氏度小于今天的气温”。</p>
<h3 id="条件语句中的正负逻辑："><a href="#条件语句中的正负逻辑：" class="headerlink" title="条件语句中的正负逻辑："></a>条件语句中的正负逻辑：</h3><p>在判断一些正负逻辑的时候，建议使用<code>if(result)</code>而不是<code>if(!result)</code>。</p>
<p>因为大脑比较容易处理正逻辑，比如我们可能比较习惯说“某某某是个男人”，而不习惯说“某某某不是个女人”。如果我们使用了负逻辑，大脑还要对它进行取反，相当于多做了一次处理。</p>
<h2 id="if-else语句块的顺序"><a href="#if-else语句块的顺序" class="headerlink" title="if/else语句块的顺序"></a>if/else语句块的顺序</h2><p>在写if/else语句的时候，可能会有很多不同的互斥情况（好多个<code>elseif</code>）。那么这些互斥的情况可以遵循哪些顺序呢？</p>
<ul>
<li><strong>先处理掉简单的情况，后处理复杂的情况</strong>：这样有助于阅读代码的人循序渐进地地理解你的逻辑，而不是一开始就吃掉一个胖子，耗费不少精力。</li>
<li><strong>先处理特殊或者可疑的情况，后处理正常的情况</strong>：这样有助于阅读代码的人会马上看到当前逻辑的边界条件以及需要注意的地方。</li>
</ul>
<h2 id="使用return提前返回"><a href="#使用return提前返回" class="headerlink" title="使用return提前返回"></a>使用return提前返回</h2><p>在一个函数或是方法里，可能有一些情况是比较特殊或者极端的，对结果的产生影响很大（甚至是终止继续进行）。如果存在这些情况，我们应该把他们写在前面，用return来提前返回（或者返回需要返回的返回值）。</p>
<p>这样做的好处是可以减少if/else语句的嵌套，也可以明确体现出：“哪些情况是引起异常的”。</p>
<p>再举一个<code>JSONModel</code>里的例子，在<code>initWithDictionary:error</code>方法里面就有很多return操作，它们都体现出了“在什么情况下是不能成功将字典转化为model对象”的；而且在方法的最后返回了对象，说明如果到了这一步，则在转化的过程中通过了层层考验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">-(id)initWithDictionary:(NSDictionary*)dict error:(NSError**)err</div><div class="line">&#123;</div><div class="line">    //check for nil input</div><div class="line">    if (!dict) &#123;</div><div class="line">        if (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //invalid input, just create empty instance</div><div class="line">    if (![dict isKindOfClass:[NSDictionary class]]) &#123;</div><div class="line">        if (err) *err = [JSONModelError errorInvalidDataWithMessage:@&quot;Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an &apos;NSDictionary&apos;.&quot;];</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //create a class instance</div><div class="line">    self = [self init];</div><div class="line">    if (!self) &#123;</div><div class="line"></div><div class="line">        //super init didn&apos;t succeed</div><div class="line">        if (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //check incoming data structure</div><div class="line">    if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //import the data from a dictionary</div><div class="line">    if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //run any custom model validation</div><div class="line">    if (![self validate:err]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //model is valid! yay!</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四-代码组织的改进"><a href="#四-代码组织的改进" class="headerlink" title="四. 代码组织的改进"></a>四. 代码组织的改进</h1><p>关于代码组织的改进，作者介绍了以下三种方法:</p>
<ul>
<li>抽取出与程序主要目的“不相关的子逻辑”</li>
<li>重新组织代码使它一次只做一件事情</li>
<li>借助自然语言描述来将想法变成代码</li>
</ul>
<h2 id="抽取出与程序主要目的“不相关的子逻辑”"><a href="#抽取出与程序主要目的“不相关的子逻辑”" class="headerlink" title="抽取出与程序主要目的“不相关的子逻辑”"></a>抽取出与程序主要目的“不相关的子逻辑”</h2><p>一个函数里面往往包含了其主逻辑与子逻辑，我们应该积极地发现并抽取出与主逻辑不相关的子逻辑。具体思考的步骤是：</p>
<ol>
<li>首先确认这段代码的高层次目标是什么（主要目标）？</li>
<li>对于每一行代码，都要反思一下：“它是直接为了目标而工作么？”</li>
<li>如果答案是肯定的并且这些代码占据着一定数量的行数，我们就应该将他们抽取到独立的函数中。</li>
</ol>
<p>比如某个函数的目标是<strong>为了寻找距离某个商家最近的地铁口</strong>，那么这其中一定会重复出现一些计算两组经纬度之间距离的子逻辑。但是这些子逻辑的具体实现是不应该出现在这个主函数里面的，因为这些细节与这个主函数的目标来讲应该是无关的。</p>
<p>即是说，像这种类似于工具方法的函数其实是脱离于某个具体的需求的：它可以用在其他的主函数中，也可以放在其他的项目里面。比如<strong>找到离运动场场最近的几个公交站</strong>这个需求等等。</p>
<p>而像这种“抽取子逻辑或工具方法”的做法有什么好处呢？</p>
<ul>
<li>提高了代码的可读性：将函数的调用与原来复杂的实现进行替换，让阅读代码的人很快能了解到该子逻辑的目的，让他们把注意力放在更高层的主逻辑上，而不会被子逻辑的实现（往往是复杂无味的）所影响。</li>
<li>便于修改和调试：因为一个项目中可能会多次调用该子逻辑（计算距离，计算汇率，保留小数点），当业务需求发生改变的时候只需要改变这一处就可以了，而且调试起来也非常容易。</li>
<li>便于测试：同理，也是因为可以被多次调用，在进行测试的时候就比较有针对性。</li>
</ul>
<p>从函数扩大到项目，其实在一个项目里面，有很多东西不当前这个项目所专有的，它们是可以用在其他项目中的一些“通用代码”。这些通用代码可以对当前的项目一无所知，可以被用在其他任何项目中去。</p>
<p>我们可以养成这个习惯，“把一般代码与项目专有代码分开”，并不断扩大我们的通用代码库来解决更多的一般性问题。</p>
<h2 id="重新组织代码使它一次只做一件事情"><a href="#重新组织代码使它一次只做一件事情" class="headerlink" title="重新组织代码使它一次只做一件事情"></a>重新组织代码使它一次只做一件事情</h2><p>一个比较大的函数或者功能可能由很多任务代码组合而来，在这个时候我们有必要将他们分为更小的函数来调用它们。</p>
<p>这样做的好处是：我们可以清晰地看到这个功能是人如何一步一步完成的，而且拆分出来的小的函数或许也可以用在其他的地方。</p>
<p>所以如果你遇到了比较难读懂的代码，可以尝试将它所做的所有任务列出来。可能马上你就会发现这其中有些任务可以转化成歹毒的函数或者类。而其他的部分可以简单的成为函数中的一个逻辑段落。</p>
<h2 id="借助自然语言描述来将想法变成代码"><a href="#借助自然语言描述来将想法变成代码" class="headerlink" title="借助自然语言描述来将想法变成代码"></a>借助自然语言描述来将想法变成代码</h2><p>在设计一个解决方案之前，如果你能够用自然语言把问题说清楚会对整个设计非常有帮助。因为如果直接从大脑中的想法转化为代码，可能会露掉一些东西。</p>
<p>但是如果你可以将整个问题和想法滴水不漏地说出来，就可能会发现一些之前没有想到的问题。这样可以不断完善你的思路和设计。</p>
<h1 id="五-最后想说的"><a href="#五-最后想说的" class="headerlink" title="五. 最后想说的"></a>五. 最后想说的</h1><p>这本书从变量的命名到代码的组织来讲解了一些让代码的可读性提高的一些实践方法。</p>
<p>其实笔者认为代码的可读性也可以算作是一种沟通能力的一种体现。因为写代码的过程也可以被看做是写代码的人与阅读代码的人的一种沟通，只不过这个沟通是单向的：代码的可读性高，可以说明写代码的人思路清晰，而且TA可以明确，高效地把自己的思考和工作内容以代码的形式表述出来。<br>所以笔者相信能写出可读性很高的代码的人，TA对于自己的思考和想法的描述能力一定不会很差。</p>
<p>如果你真的打算好好做编程这件事情，建议你从最小的事情上做起：好好为你的变量起个名字。不要再以“我英语不好”或者“没时间想名字”作为托辞；把态度端正起来，平时多动脑，多查字典，多看源码，自然就会了。</p>
<p>如果你连起个好的变量名都懒得查个字典，那你怎么证明你在遇到更难的问题的时候能够以科学的态度解决它？<br>如果你连编程里这种最小的事情都不好好做，那你又怎么证明你对编程是有追求的呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-63f87902508af82e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《编写可读代码的艺术》封面&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-为什么读这本书&quot;&gt;&lt;a href=&quot;#一-为什么读这本书&quot; class=&quot;headerlink&quot; title=&quot;一. 为什么读这本书&quot;&gt;&lt;/a&gt;一. 为什么读这本书&lt;/h1&gt;&lt;p&gt;很多同行在编写代码的时候往往只关注一些宏观上的主题：架构，设计模式，数据结构等等，却忽视了一些更细节上的点：比如变量如何命名与使用，控制流的设计，以及注释的写法等等。以上这些细节上的东西可以用&lt;strong&gt;代码的可读性&lt;/strong&gt;来概括。&lt;/p&gt;
&lt;p&gt;不同于宏观上的架构，设计模式等需要好几个类，好几个模块才能看出来：代码的可读性是能够立刻从微观上的，一个变量的命名，函数的逻辑划分，注释的信息质量里面看出来的。&lt;/p&gt;
&lt;p&gt;宏观层面上的东西固然重要，但是代码的可读性也属于评价代码质量的一个无法让人忽视的指标：它影响了阅读代码的成本（毕竟代码注意是给人看的），甚至会影响代码出错的概率！&lt;/p&gt;
&lt;p&gt;这里引用《编写可读代码的艺术》这本书里的一句话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个整体的软件系统而言，既需要宏观的架构决策，设计与指导原则，也必须重视围观的代码细节。在软件历史中，有许多影响深远的重大失败，其根源往往是编码细节出现了疏漏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此笔者认为代码的可读性可以作为考量一名程序员专业程度的指标。&lt;/p&gt;
&lt;p&gt;或许已经有很多同行也正在努力提高自己代码的可读性。然而这里有一个很典型的错觉（笔者之前就有这种错觉）是：越少的代码越容易让人理解。&lt;/p&gt;
&lt;p&gt;但是事实上，并不是代码越精简就越容易让人理解。相对于追求最小化代码行数，一个更好的提高可读性方法是&lt;strong&gt;最小化人们理解代码所需要的时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就引出了这本中的一个核心定理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可读性基本定理：代码的写法应当使别人理解它所需要的时间最小化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正式这句话深深地吸引了我，于是决定利用这两周的业余时间读完并总结了这本书。&lt;/p&gt;
&lt;p&gt;这本书讲的就是关于”如何提高代码的可读性“。&lt;br&gt;总结下来，这本书从浅入深，在三个层次告诉了我们如何让代码易于理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表层上的改进：在命名方法（变量名，方法名），变量声明，代码格式，注释等方面的改进。&lt;/li&gt;
&lt;li&gt;控制流和逻辑的改进：在控制流，逻辑表达式上让代码变得更容易理解。&lt;/li&gt;
&lt;li&gt;结构上的改进：善于抽取逻辑，借助自然语言的描述来改善代码。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/categories/BookNote/"/>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>结合一个开源的底部菜单组件来讲一下如何封装一个React Native组件</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/10/10/%E7%BB%93%E5%90%88%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E7%9A%84%E5%BA%95%E9%83%A8%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6%E6%9D%A5%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAReact%20Native%E7%BB%84%E4%BB%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/10/10/结合一个开源的底部菜单组件来讲一下如何封装一个React Native组件/</id>
    <published>2017-10-10T05:15:54.520Z</published>
    <updated>2017-11-13T04:22:06.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前几天写了一个React Native组件：一个可定制性比较高的底部弹出菜单（ActionSheet）。该组件符合React Native的特性：同时支持iOS和Android双平台，一份相同的代码会在两个平台上展示几乎完全相同的样式。</p>
<p>先看一下效果(上排为iOS模拟器，下排为Android模拟器)：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_3.png" alt=""></p>
<p>上图展示的是该组件的默认样式。由于该组件具有较高的定制性，所以只需要通过设置一些属性就可以得到更多不同的样式。</p>
<p>开源项目地址：<a href="https://github.com/knightsj/react-naive-highly-customizable-action-sheet">GitHub:react-naive-highly-customizable-action-sheet</a></p>
<a id="more"></a>
<h2 id="定制性介绍"><a href="#定制性介绍" class="headerlink" title="定制性介绍"></a>定制性介绍</h2><p>在该组件里：最顶部的标题，中间的选择项，最底部的取消项都是可有可无的，而且每一部分的字体，颜色，高度，距离，分割线颜色，圆角等也都是可以定制的。</p>
<p>先来看几个默认的样式：</p>
<h3 id="默认的样式："><a href="#默认的样式：" class="headerlink" title="默认的样式："></a>默认的样式：</h3><p>默认的样式是指使用者在不设置样式相关属性，只设置数据（文字）相关属性时展现的样式。该样式是微信，微博里使用的样式，也是我个人非常喜欢的样式。</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_1.gif" alt=""></p>
<h3 id="类似iOS原生-ActionSheet的样式"><a href="#类似iOS原生-ActionSheet的样式" class="headerlink" title="类似iOS原生 ActionSheet的样式"></a>类似iOS原生 ActionSheet的样式</h3><p>用户可以通过设置某些属性可以实现iOS默认的ActionSheet的样式：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_2.gif" alt=""></p>
<p>除此之外，用户还可以通过设置某些属性来实现各种其他的样式：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_3.gif" alt=""></p>
<p>下面结合使用方法来看一下如何通过代码来定制这些样式：</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p><code>npm install react-naive-highly-customizable-action-sheet</code></p>
<p>引用组件：</p>
<p><code>import ActionSheet from &#39;react-naive-highly-customizable-action-sheet&#39;</code></p>
<p>然后给该组件传入标题，选项文字数组，回调方法数组等实现一个ActionSheet的组件。</p>
<p>下面结合一下代码和demo截图讲解一下：</p>
<p>一个默认样式的例子:</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_11.png" alt=""></p>
<p>该样式的实现代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;ActionSheet</div><div class="line">   mainTitle=<span class="string">"There are three ways to contact. Please choose one to contact."</span></div><div class="line">   itemTitles = &#123;[<span class="string">"By phone"</span>,<span class="string">"By message"</span>,<span class="string">"By email"</span>]&#125;</div><div class="line">   selectionCallbacks = &#123;[<span class="keyword">this</span>.clickedByPhone,<span class="keyword">this</span>.clickedByMessage,<span class="keyword">this</span>.clickedByEmail]&#125;</div><div class="line">   mainTitleTextAlign = <span class="string">'center'</span></div><div class="line">   ref=&#123;(actionsheet)=&gt;&#123;<span class="keyword">this</span>.actionsheet = actionsheet&#125;&#125;</div><div class="line">/&gt;</div><div class="line">  </div><div class="line"><span class="comment">//弹出底部菜单</span></div><div class="line">showActionSheet()&#123;</div><div class="line">	<span class="keyword">this</span>.actionsheet.show();  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByPhone()&#123;</div><div class="line">   alert(<span class="string">'By Phone'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByMessage()&#123;</div><div class="line">    alert(<span class="string">'By Message'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByEmail()&#123;</div><div class="line">    alert(<span class="string">'By Email'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，</p>
<ul>
<li><code>mainTitle</code>：是最上方的标题。</li>
<li><code>itemTitles</code>：选项文字的数组。</li>
<li><code>selectionCallbacks</code>：点击选项后的回调函数数组。</li>
</ul>
<p>需要注意的是，选项文字的数组和回调函数数组里的元素应该是一一对应的。不过即使回调函数数组里的元素个数少于选项文字数组里的元素个数也不会引起崩溃。</p>
<p>一个iOS ActionSheet样式的例子：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_12.png" alt=""></p>
<p>该样式的实现代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> &lt;ActionSheet</div><div class="line">    mainTitle=<span class="string">"There are three ways to contact. Please choose one to contact."</span></div><div class="line">    itemTitles = &#123;[<span class="string">"By phone"</span>,<span class="string">"By message"</span>,<span class="string">"By email"</span>]&#125;</div><div class="line">    selectionCallbacks = &#123;[<span class="keyword">this</span>.clickedByPhone,<span class="keyword">this</span>.clickedByMessage,<span class="keyword">this</span>.clickedByEmail]&#125;</div><div class="line">    mainTitleTextAlign = <span class="string">'center'</span></div><div class="line">    contentBackgroundColor = <span class="string">'#EFF0F1'</span></div><div class="line">    bottomSpace = &#123;<span class="number">10</span>&#125;</div><div class="line">    cancelVerticalSpace = &#123;<span class="number">10</span>&#125;</div><div class="line">    borderRadius = &#123;<span class="number">5</span>&#125;</div><div class="line">    sideSpace = &#123;<span class="number">6</span>&#125;</div><div class="line">    itemTitleColor = <span class="string">'#006FFF'</span></div><div class="line">    cancelTitleColor = <span class="string">'#006FFF'</span></div><div class="line">    ref=&#123;(actionsheet)=&gt;&#123;<span class="keyword">this</span>.actionsheet = actionsheet&#125;&#125;</div><div class="line">/&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//弹出底部菜单</span></div><div class="line">showActionSheet()&#123;</div><div class="line">	<span class="keyword">this</span>.actionsheet.show();  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByPhone()&#123;</div><div class="line">   alert(<span class="string">'By Phone'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByMessage()&#123;</div><div class="line">    alert(<span class="string">'By Message'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByEmail()&#123;</div><div class="line">    alert(<span class="string">'By Email'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多其他的样式设定可以参考<a href="https://github.com/knightsj/react-naive-highly-customizable-action-sheet">demo</a>里的<code>Example</code>。</p>
<p>大致介绍完这个组件的功能和使用方法，下面来看一下该组件是如何封装的。</p>
<h2 id="React-Native组件的封装"><a href="#React-Native组件的封装" class="headerlink" title="React Native组件的封装"></a>React Native组件的封装</h2><h3 id="封装些什么"><a href="#封装些什么" class="headerlink" title="封装些什么"></a>封装些什么</h3><p>对于GUI编程里视图组件来说，无外乎是以下三个内容：</p>
<ol>
<li>数据</li>
<li>样式</li>
<li>交互</li>
</ol>
<p>而对于视图组件的封装，我个人的理解是：封装接收数据的形式，数据与样式之间的转化规则以及交互的逻辑。而这些都是从数据的接收开始的。没有数据的接收就没有UI的展示，更谈不上交互了。</p>
<p>所以在最开始从React Native视图组件的数据接收来说起是比较妥当的。</p>
<h3 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h3><p>在iOS开发中，给view提供数据的方式是通过设置属性或者实现数据源方法来做的。但是在React Native开发中，通常<strong>只能</strong>通过设置属性来传入该组件为了实现某个样式所需要的一些数据。比如在上面的两个例子里，标题，以及选项文字都是通过设置特定的属性来传入的。</p>
<p>而且，为了保证设置属性的类型正确，最好对属性做一个类型检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component, PropTypes&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> propTypes = &#123;</div><div class="line"> </div><div class="line">    <span class="attr">mainTitle</span>:PropTypes.string.isRequired,<span class="comment">//类型为字符串，且必须传入</span></div><div class="line">    mainTitleFont:PropTypes.number,<span class="comment">//类型为数字</span></div><div class="line">    mainTitleColor:PropTypes.string,<span class="comment">//类型为字符串</span></div><div class="line">    mainTitleTextAlign:PropTypes.oneOf([<span class="string">'center'</span>, <span class="string">'left'</span>]),<span class="comment">//二者选其一</span></div><div class="line">    hideCancel:PropTypes.bool,<span class="comment">//类型为布尔值</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下第一行的<code>mainTitle</code>属性，在上面将它设置为必须传入的属性。所以如果在这种情况下没有传入该属性，就会出现警告。</p>
<p>上面的只是我举的例子，在我封装的这个组件里没有任何属性是必须传入的。因为要提高定制性，所以所有属性都是可传可不传。</p>
<p>现在我们知道了如何将数据传入到组件里。但是这仅仅是第一步。因为组件所需要的数据可能不仅仅包括用户传入的这些数据，还包括一些通过用户传入的这些数据计算后得到的另一些数据，比如弹窗的总高度。不难理解，弹窗的总高度取决于标题的高度，选项的高度和选项的个数，以及取消项的高度总和。而这个数据显然是通过传入的标题，选项等数据后经过计算得到的。</p>
<p>而且，对于一些可以不一定需要用户传入的数据，可能组件自己也许要提供一下对应属性的默认值。</p>
<p>综上所述，对于数据处理部分，可以分为两类的处理：</p>
<ol>
<li>计算额外的数据。</li>
<li>提供对应属性的默认值。</li>
</ol>
<p>分别举两个在该组件中的代码（之间省略了部分内容）讲解一下。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="1-额外需要计算的数据"><a href="#1-额外需要计算的数据" class="headerlink" title="1. 额外需要计算的数据"></a>1. 额外需要计算的数据</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">componentWillMount()&#123;</div><div class="line">    </div><div class="line">     ...</div><div class="line">    <span class="comment">//Calculate Title Height</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.props.mainTitle)&#123;</div><div class="line">        <span class="keyword">this</span>.real_titleHeight = <span class="number">0</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.real_titleHeight = <span class="keyword">this</span>.state.mainTitleHeight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate Items height</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.props.itemTitles)&#123;</div><div class="line">        <span class="keyword">this</span>.real_itemsPartHeight = <span class="number">0</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.real_itemsPartHeight = (<span class="keyword">this</span>.state.itemHeight + <span class="keyword">this</span>.state.itemVerticalSpace) * <span class="keyword">this</span>.props.itemTitles.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate Cancel part height</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.hideCancel)&#123;</div><div class="line">        <span class="keyword">this</span>.real_cancelPartHeight = <span class="number">0</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.real_cancelPartHeight = <span class="keyword">this</span>.state.cancelVerticalSpace + <span class="keyword">this</span>.state.cancelHeight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// total content height</span></div><div class="line">    <span class="keyword">this</span>.totalHeight = <span class="keyword">this</span>.real_titleHeight +  <span class="keyword">this</span>.real_itemsPartHeight + <span class="keyword">this</span>.real_cancelPartHeight + <span class="keyword">this</span>.state.bottomSpace;</div><div class="line">     ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，<code>this.real_titleHeight</code>,<code>this.real_itemsPartHeight</code>,<code>this.real_cancelPartHeigh</code>,<code>this.totalHeight</code>都是在拿到属性以后，需要额外计算的数据。我把这些工作放在了<code>componentWillMount()</code>方法里面。</p>
<h4 id="2-提供对应属性的默认值"><a href="#2-提供对应属性的默认值" class="headerlink" title="2. 提供对应属性的默认值"></a>2. 提供对应属性的默认值</h4><p>如果用户没有传入标题文字的颜色，则提供一个默认的标题颜色：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line"><span class="keyword">super</span>(props);</div><div class="line">   <span class="keyword">this</span>.state = &#123;</div><div class="line">     ...</div><div class="line">     mainTitleColor:<span class="keyword">this</span>.props.mainTitleColor?<span class="keyword">this</span>.props.mainTitleColor:<span class="string">'gray'</span>,<span class="comment">//主标题颜色</span></div><div class="line">     cancelTitle:<span class="keyword">this</span>.props.cancelTitle?<span class="keyword">this</span>.props.cancelTitle:<span class="string">'Cancel'</span>,<span class="comment">//取消的文字</span></div><div class="line">     ...</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，如果用户没有设置<code>mainTitleColor</code>和<code>cancelTitle</code>这两个属性值，组件内部会提供相应的默认值。</p>
<h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><p>在React Native里，组件的<code>render()</code>函数负责渲染组件。因此这个函数里会使用之前计算好的数据来渲染组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">   retrun(  </div><div class="line">     &lt;View&gt;</div><div class="line">        &#123;this._renderTitleItem()&#125;</div><div class="line">        &#123;this._renderItemsPart()&#125;</div><div class="line">        &#123;this._renderCancelItem()&#125;</div><div class="line">    &lt;/View&gt;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//render title part</span></div><div class="line">_renderTitleItem()&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.props.mainTitle)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;TouchableWithoutFeedback&gt;</div><div class="line">                &lt;View style=&#123;[styles.contentViewStyle]&#125;&gt;</div><div class="line">                    &lt;Text&gt;&#123;this.props.mainTitle&#125;&lt;/Text&gt;</div><div class="line">                &lt;/View&gt;</div><div class="line">            &lt;/TouchableWithoutFeedback&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//render selection items part</span></div><div class="line">_renderItemsPart()&#123;</div><div class="line">    <span class="keyword">var</span> itemsArr = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="keyword">let</span> title = <span class="keyword">this</span>.state.itemTitles[i];</div><div class="line">    <span class="keyword">let</span> itemView =</div><div class="line">        &lt;View key=&#123;i&#125;&gt;</div><div class="line">            &#123;/* Seperate Line */&#125;</div><div class="line">            &#123;this._renderItemSeperateLine(showItemSeperateLine)&#125;</div><div class="line">            &#123;/* item for selection*/&#125;</div><div class="line">            &lt;TouchableOpacity onPress=&#123;this._didSelect.bind(this, i)&#125;&gt;</div><div class="line">                &lt;View style=&#123;[styles.contentViewStyle]&#125; key=&#123;i&#125;&gt;</div><div class="line">                    &lt;Text style=&#123;[styles.textStyle]&#125;&gt;&#123;title&#125;&lt;/Text&gt;</div><div class="line">                &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;</div><div class="line">        &lt;/View&gt;</div><div class="line">        itemsArr.push(itemView);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> itemsArr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//render cancel part</span></div><div class="line">_renderCancelItem()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;View style=&#123;&#123;width:this.contentWidth,height: this.real_cancelPartHeight&#125;&#125;&gt;</div><div class="line">          &#123;/* Seperate Line */&#125;</div><div class="line">          &#123;this._renderCancelSeperateLine(showCancelSeperateLine)&#125;</div><div class="line">          &#123;/* Cancel Item */&#125;</div><div class="line">            &lt;TouchableOpacity onPress=&#123;this._dismiss.bind(this)&#125;&gt;</div><div class="line">                &lt;View style=&#123;[styles.contentViewStyle]&#125;&gt;</div><div class="line">                    &lt;Text style=&#123;[styles.textStyle]&#125;&gt;&#123;this.state.cancelTitle&#125;&lt;/Text&gt;</div><div class="line">                &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>组件的交互可以分为两种：有外部回调的交互以及没有外部回调的交互。这个外部回调是指在组件外部所需要执行的函数。比如底部菜单组件：如果用户点击了某一项，菜单会回落，并调用该组件外部的函数（例如退出登录，清除缓存等等）。类比在iOS开发中，可以使用代理或者block的方式进行回调，而在React Native中实现回调的方式与iOS中block的方式类似。</p>
<h4 id="有回调的交互"><a href="#有回调的交互" class="headerlink" title="有回调的交互"></a>有回调的交互</h4><p>在React Native中，如果需要调用外部的函数，就需要在一开始的时候将该函数作为属性传入组件中。然后拦截用户的点击，调用相应的回调函数。这里面分为三个步骤：</p>
<ol>
<li>传入回调函数</li>
<li>拦截用户操作</li>
<li>调用回调函数</li>
</ol>
<p><strong>1. 传入回调函数：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> propTypes = &#123;</div><div class="line">  </div><div class="line">    <span class="comment">//selection items callback</span></div><div class="line">    selectionCallbacks:PropTypes.array,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>selectionCallbacks</code>是对应选择项的回调函数数组属性。这里因为选择项数量不确定，所以用数组来保存回调函数。</p>
</blockquote>
<p><strong>2. 拦截用户操作(点击)：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;TouchableOpacity onPress=&#123;<span class="keyword">this</span>._didSelect.bind(<span class="keyword">this</span>, i)&#125;  activeOpacity = &#123;<span class="number">0.9</span>&#125;&gt;</div><div class="line">    &lt;View style=&#123;styles.contentViewStyle&#125; key=&#123;i&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;title&#125;&lt;/Text&gt;</div><div class="line">    &lt;/View&gt;</div><div class="line">&lt;<span class="regexp">/TouchableOpacity&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，使用了<code>TouchableOpacity</code>组件让<code>View</code>组件获得可以被点击的能力，并且绑定了函数<code>_select(index)</code>。</p>
</blockquote>
<p><strong>3. 调用回调函数：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取出相应的回调函数并调用</span></div><div class="line">_select(i) &#123;</div><div class="line">    <span class="keyword">let</span> callback = <span class="keyword">this</span>.state.selectionCallbacks[i];</div><div class="line">    <span class="keyword">if</span>(callback)&#123;</div><div class="line">        &#123;callback()&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，_didSelect(index)函数是某个选项被点击后调用的函数。该函数拿到传入的index值，从callback数组里面获取对应index的回调函数并调用。而且为了避免崩溃，还判断了callback是否为空。</p>
</blockquote>
<h4 id="没有回调的交互"><a href="#没有回调的交互" class="headerlink" title="没有回调的交互"></a>没有回调的交互</h4><p>如果这个交互没有回调就比较简单了，在组件内部做就可以了。比如点击取消后的回落事件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;TouchableOpacity onPress=&#123;this._dismiss.bind(this)&#125; activeOpacity = &#123;0.9&#125;&gt;</div><div class="line">    &lt;View style=&#123;styles.contentViewStyle&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;this.state.cancelTitle&#125;&lt;/Text&gt;</div><div class="line">    &lt;/View&gt;</div><div class="line">&lt;/TouchableOpacity&gt;</div><div class="line"></div><div class="line">//dismiss ActionSheet</div><div class="line">_dismiss() &#123;</div><div class="line">    if (!this.state.hide) &#123;</div><div class="line">        this._fade();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里除了使菜单回落以外，再点击取消的时候还给了用户反馈：点击时背景色的透明度改变。实现方法是利用的<code>TouchableOpacity</code>的<code>activeOpacity = {0.9}</code></p>
<p>OK，现在讲完了数据和交互，再来看一下React Native是如何支持动画效果的（因为用到了所以就顺带讲一下了）。</p>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>一般来说，底部菜单在弹出和回落的时候是有动画效果的，React Native的动画效果可以用其内置的<code>Animated</code>库来实现。</p>
<p>结合菜单弹出的例子来说明一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//animation of showing</span></div><div class="line">_appear() &#123;</div><div class="line">    Animated.parallel([</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.opacity, <span class="comment">//动画改编的变量</span></div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,  <span class="comment">//动画时长，单位是毫秒</span></div><div class="line">                toValue: <span class="number">0.7</span>,   <span class="comment">//终点值</span></div><div class="line">            &#125;</div><div class="line">        ),</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.offset,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,</div><div class="line">                <span class="attr">toValue</span>: <span class="number">1</span>,</div><div class="line">            &#125;</div><div class="line">        )</div><div class="line">    ]).start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这里，</p>
<ul>
<li><p><code>Animated.parallel</code>函数负责执行<strong>同时执行的组合动画</strong>。既然是组合动画，那么传入的就应该是一个动画的数组。仔细看一下就会发现这里有两个<code>Animated.timing</code>函数。</p>
</li>
<li><p><code>Animated.timing</code>函数负责执行以时间为单位的动画。从注释上不难看出，在这里同时执行的两个动画是：</p>
<ul>
<li><code>this.state.opacity</code>值在200毫秒内，从0到0.7渐变的动画。</li>
<li><code>this.state.offset</code>值在200毫秒内，从0到1渐变的动画。</li>
</ul>
</li>
<li><p>最底部的<code>start()</code>函数触发了这个组合动画。</p>
<p>​</p>
</li>
</ul>
<blockquote>
<p>这里没有提供起点值，因为在这里直接获取的是传入变量的当前值。</p>
</blockquote>
<p>相对底部菜单的弹出动画，来看一下底部菜单的回落动画：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//animation of fading</span></div><div class="line">_fade() &#123;</div><div class="line">    Animated.parallel([</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.opacity,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,</div><div class="line">                <span class="attr">toValue</span>: <span class="number">0</span>,</div><div class="line">            &#125;</div><div class="line">        ),</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.offset,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,</div><div class="line">                <span class="attr">toValue</span>: <span class="number">0</span>,</div><div class="line">            &#125;</div><div class="line">        )</div><div class="line">    ]).start(<span class="function">(<span class="params">finished</span>) =&gt;</span> <span class="keyword">this</span>.setState(&#123;<span class="attr">hide</span>: <span class="literal">true</span>&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有关动画的知识可以查看官方文档[React Native :动画](<a href="http://reactnative.cn/docs/0.48/animations.html#conte" target="_blank" rel="external">http://reactnative.cn/docs/0.48/animations.html#conte</a></p>
<p>其实到这里，对于组件的封装就基本讲完了，讲解的内容还是集中在数据这一块，组件是怎么画出来的就不讲解了。因为毕竟每个组件将数据转化为样式的代码是不一样的，学会一个弹出菜单的画法对于画其他的组件没有太大的借鉴意义。但是对于一个通用组件来说，其定制性必须达到一定标准才可以。所以相对于讲解“组件是如何画出来的”，我认为讲一下“提高组件定制性”应该更实际一些。</p>
<h3 id="为提高定制性所做的工作："><a href="#为提高定制性所做的工作：" class="headerlink" title="为提高定制性所做的工作："></a>为提高定制性所做的工作：</h3><p>最开始做这个控件也仅仅只能设置标题，选项以及回调函数，样式也只有这一种：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_11.png" alt=""></p>
<p>但是为了提高定制性，支持更多的样式，也为了自己能更好地了解React Native，就决定挑战一下，看定制性能提高到什么程度。</p>
<p>如上文所说，在React Native里，组件的数据传递是通过设置其属性来实现的。所以如果想要提高组件的定制性就需要增加该组件的属性。</p>
<p>看一下该组件的所有属性：</p>
<ul>
<li><code>itemTitles</code><em>(Array)</em>:选择项的标题数组</li>
<li><code>selectionCallbacks</code><em>(Array)</em>：点击选项的回调数组</li>
</ul>
<ul>
<li><code>mainTitle</code><em>(String)</em>:标题文字</li>
<li><code>mainTitleFont</code><em>(Number)</em>:标题字体</li>
<li><code>mainTitleColor</code><em>(String)</em>:标题颜色</li>
<li><code>mainTitleHeight</code><em>(Number)</em>:标题栏高度</li>
<li><code>mainTitleTextAlign</code><em>(String)</em>:标题对齐方式</li>
<li><code>mainTitlePadding</code><em>(Number)</em>:标题内边距</li>
<li><code>itemTitleFont</code><em>(Number)</em>:选择项字体</li>
<li><code>itemTitleColor</code><em>(String)</em>:选择项颜色</li>
<li><code>itemHeight</code><em>(Number)</em>:选择栏高度</li>
</ul>
<ul>
<li><code>cancelTitle</code><em>(String)</em>:取消项标题，默认为’Cancel’</li>
<li><code>cancelTitleFont</code><em>(Number)</em>:取消标题字体</li>
<li><code>cancelTitleColor</code><em>(String)</em>:取消标题颜色</li>
<li><code>cancelHeight</code><em>(Number)</em>:取消栏高度</li>
<li><code>hideCancel</code><em>(Bool)</em>:是否隐藏取消项（默认不隐藏）</li>
</ul>
<ul>
<li><code>fontWeight</code><em>(String)</em>:所有文字的字体粗细（同时设置标题，选择项，取消项的字体粗细）</li>
<li><code>titleFontWeight</code><em>(String)</em>:标题的字体粗细，默认为’normal’</li>
<li><code>itemFontWeight</code><em>(String)</em>:选择项的字体粗细，默认为’normal’</li>
<li><code>cancelFontWeight</code><em>(String)</em>:取消项的字体粗细，默认为’bold’</li>
</ul>
<ul>
<li><code>contentBackgroundColor</code><em>(String)</em>:所有项目的背景色（同时设置标题，选择项，取消项的背景色）</li>
<li><code>titleBackgroundColor</code><em>(String)</em>:标题的背景色（默认是白色）</li>
<li><code>itemBackgroundColor</code><em>(String)</em>:选择项的背景色（默认是白色）</li>
<li><code>cancelBackgroundColor</code><em>(String)</em>:取消项的背景色（默认是白色）</li>
<li><code>itemSpaceColor</code><em>(String)</em>:选择项之间的分割线颜色（默认是浅灰色）</li>
<li><code>cancelSpaceColor</code><em>(String)</em>:取消项和最后一个选择项之间的分割线颜色（默认是浅灰色）</li>
</ul>
<ul>
<li><code>itemVerticalSpace</code><em>(Number)</em>:选择项之间分割线的高度</li>
</ul>
<ul>
<li><code>cancelVerticalSpace</code><em>(Number)</em>:取消项和最后一个选择项之间的分割线的高度</li>
<li><code>bottomSpace</code><em>(Number)</em>:屏幕底部距离取消项底部的距离</li>
<li><code>sideSpace</code><em>(Number)</em>:弹出框左右侧边距离屏幕左右侧边的距离</li>
</ul>
<ul>
<li><code>borderRadius</code><em>(Number)</em>:弹出框的圆角</li>
</ul>
<ul>
<li><code>maskOpacity</code><em>(Number)</em>:mask的透明度（默认为0.3）</li>
</ul>
<p>不难看出，该组件的三个部分（标题，选项，取消）里，每个部分都有各自对应的属性可以设置。因为在设计这个组件的时候就将这三个部分高度解耦了：每个部分都互不影响，有各自的数据（除了少数可以共同使用的数据），并分别进行绘制。</p>
<p>比如，我们可以设置：</p>
<h4 id="每个部分文字内容，字体大小，高度"><a href="#每个部分文字内容，字体大小，高度" class="headerlink" title="每个部分文字内容，字体大小，高度"></a>每个部分文字内容，字体大小，高度</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_4.png" alt=""></p>
<h4 id="背景颜色（可以统一设置，也可以单独设置）"><a href="#背景颜色（可以统一设置，也可以单独设置）" class="headerlink" title="背景颜色（可以统一设置，也可以单独设置）"></a>背景颜色（可以统一设置，也可以单独设置）</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_5.png" alt=""></p>
<h4 id="分割线高度，距离底部的高度，距离屏幕侧边的距离"><a href="#分割线高度，距离底部的高度，距离屏幕侧边的距离" class="headerlink" title="分割线高度，距离底部的高度，距离屏幕侧边的距离"></a>分割线高度，距离底部的高度，距离屏幕侧边的距离</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_6.png" alt=""></p>
<h4 id="分割线的颜色"><a href="#分割线的颜色" class="headerlink" title="分割线的颜色"></a>分割线的颜色</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_7.png" alt=""></p>
<p>上面这些图片的效果对应的代码在<a href="https://github.com/knightsj/react-naive-highly-customizable-action-sheet">demo</a>中都有提供(具体查看Example文件夹)。</p>
<p>另外该组件也支持一些比较极端的情况，虽然可能需求上极少遇到，但还是提供了支持。</p>
<h4 id="极端情况："><a href="#极端情况：" class="headerlink" title="极端情况："></a>极端情况：</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_13.png" alt=""></p>
<p>高度解耦的程度可以通过这最后一张图看出来：主标题，选择项，取消项都可以根据传入属性的情况来展示，互不影响。而且在都不设置的情况下，只展示了灰色的底部mask。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>写这个组件一共花了3天的时间，其实第一天就已经完成了默认样式的开发。而后2天主要做的是提高定制性的工作。因为定制性的工作是与数据处理和应用分不开的，而自己对JavaScript语法了解得不是很好，所以期间写了不少的bug。值得庆幸的是，由于React Native本身搭建UI的能力很强，效率很高，所以数据处理好了之后工作量就不大了。</p>
<p>毕竟是自己封装的第一个React Native组件，我相信它还是有很多提升空间的，比如数据处理这一块可能有不妥的地方，还需要各位能给出宝贵的意见和建议。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;前几天写了一个React Native组件：一个可定制性比较高的底部弹出菜单（ActionSheet）。该组件符合React Native的特性：同时支持iOS和Android双平台，一份相同的代码会在两个平台上展示几乎完全相同的样式。&lt;/p&gt;
&lt;p&gt;先看一下效果(上排为iOS模拟器，下排为Android模拟器)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/as_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图展示的是该组件的默认样式。由于该组件具有较高的定制性，所以只需要通过设置一些属性就可以得到更多不同的样式。&lt;/p&gt;
&lt;p&gt;开源项目地址：&lt;a href=&quot;https://github.com/knightsj/react-naive-highly-customizable-action-sheet&quot;&gt;GitHub:react-naive-highly-customizable-action-sheet&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="React Native" scheme="https://github.com/knightsj/knightsj.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>从一个实战项目来看一下React Native开发的几个关键技术点</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/08/30/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%8BReact%20Native%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/08/30/从一个实战项目来看一下React Native开发的几个关键技术点/</id>
    <published>2017-08-30T05:32:14.000Z</published>
    <updated>2017-08-30T05:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行了2个星期的基础学习（Flexbox, React.js, JSX, JavaScript）之后，想通过一个实战项目来提高React Native的开发水平，于是找到了下面这个项目：</p>
<h1 id="一-项目介绍"><a href="#一-项目介绍" class="headerlink" title="一. 项目介绍"></a>一. 项目介绍</h1><p>这是我在学习<a href="http://www.devio.org/" target="_blank" rel="external">贾鹏辉</a>老师在慕课网上的一个很火的<a href="http://coding.imooc.com/class/89.html" target="_blank" rel="external">React Native实战的教程</a>后，写出的课程Demo。该课程是慕课网里很火的一个React Native课程，当初在看了课程介绍和课程安排觉得讲解的点还是很全的，所以毫不犹豫地买了下来。</p>
<p>从看视频，敲代码到重构，改bug，大概花了2个多星期的时间，除了调用友盟的SDK以及CodePush集成之外，其他的部分都基本完成了，而且同时可以在iOS和Android设备上运行：<br><img src="http://oih3a9o4n.bkt.clouddn.com/rn_13.png" alt="上排是iOS模拟器 | 下排是Android模拟器"></p>
<p>而且比较吸引人的是该项目可以实现多个主题的切换：<br><img src="http://oih3a9o4n.bkt.clouddn.com/rn_15.png" alt="多主题切换"></p>
<blockquote>
<p>切换的技术实现会在下文给出。</p>
</blockquote>
<p>用一个动图来过一遍大致的需求：<br><img src="http://oih3a9o4n.bkt.clouddn.com/github%E5%AE%A2%E6%88%B7%E7%AB%AF_4.gif" alt=""></p>
<p>Demo GitHub地址：<a href="https://github.com/knightsj/GitHubPopular-SJ">GitHubPopular-SJ</a><br>可以按照README文件里的方法运行该项目。</p>
<blockquote>
<p>已经贾老师允许上传到GitHub</p>
</blockquote>
<p>值得一提的是：这确实是一门物有所值的课程，可以让想入门React Native的开发者少走很多弯路。虽然我上传的Demo可以实现视频里大部分功能，但是经过调试，修改后的代码信息量还是很有限的，而且老师在视频中讲解的很多关于实际开发的知识点在代码中并没有体现出来，所以还是建议各位报名参加课程来提高自己的开发水平。</p>
<a id="more"></a>
<h1 id="二-React-Native开发的几个关键技术点"><a href="#二-React-Native开发的几个关键技术点" class="headerlink" title="二. React Native开发的几个关键技术点"></a>二. React Native开发的几个关键技术点</h1><p>首先用一张思维导图来看一下第二节讲的内容：<br><img src="http://oih3a9o4n.bkt.clouddn.com/rn_16_1.png" alt=""></p>
<h2 id="2-1-组件化的思想"><a href="#2-1-组件化的思想" class="headerlink" title="2.1 组件化的思想"></a>2.1 组件化的思想</h2><p>React Native是React在移动端的跨平台方案。如果想更快地理解和掌握React Native开发，就必须先了解React。</p>
<p>React是FaceBook开源的一个前端框架，它起源于 Facebook 的内部项目，并于 2013 年 5 月开源。因为React 拥有较高的性能，代码逻辑非常简单，所以越来越多的人已开始关注和使用它，目前该框架在Github上已经有7万+star。</p>
<p>React采用组件化的方式开发，通过将view构建成组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。有一句话说的很形象：在React中，构建应用就像搭积木一样。</p>
<p>因此，如果想掌握React Native，就必须先了解React中的组件。</p>
<p>那么问题来了，什么是组件呢？</p>
<p>在React中，在UI上每一个功能相对独立的模块就会被定义为组件。  相对小的组件可以通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建。</p>
<p>因此，整个UI是一个通过小组件构成的大组件，而且每个组件只关心自己部分的逻辑，彼此独立。</p>
<p>React认为一个组件应该具有如下特征：</p>
<ul>
<li>可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件；</li>
<li>可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景；</li>
<li>可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；</li>
</ul>
<p>举个🌰，我们看一下这个Demo使用的导航栏：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_1_1_1.png" alt=""></p>
<p>封装好的导航栏就可以被称之为一个组件，它符合上述三个特点：</p>
<ol>
<li>可组合：可以将导航栏组件放在页面组件中作为页面组件的子组件。而且在导航栏组件的内部，也有按钮组件等子组件。</li>
<li>可重用：如果封装好了该组件，就可以放在任意需要导航栏的页面（组件）使用，也可以放在其他项目中使用。</li>
<li>可维护：因为具有独立的功能和展示逻辑，所以便于定位和修改。</li>
</ol>
<p>在了解了组件的基本概念以后，我们来看一下组件其他的一些相关知识。</p>
<h2 id="2-2-组件的属性与状态"><a href="#2-2-组件的属性与状态" class="headerlink" title="2.2 组件的属性与状态"></a>2.2 组件的属性与状态</h2><p>在React Native（React.js）里，组件所持有的数据分为两种：</p>
<ol>
<li>属性（props）：组件的props是不可变的，它只能从其他的组件（例如父组件）传递过来。</li>
<li>状态（state）：组件的state是可变的，它负责处理与用户的交互。在通过用户点击事件等操作以后，如果使得当前组件的某个state发生了改变，那么当前组件就会触发<code>render()</code>方法刷新自己。</li>
</ol>
<p>举一个这个项目的收藏页面来说：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_2_1_1.png" alt=""></p>
<p>我们可以看到这个页面有两个子页面，一个是‘最热’页面（组件），另一个是‘趋势‘页面（组件）。那么这两个组件都有什么props和state呢？</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>首先看一下props：<br>由于props是从其父组件传递过来的，那么可想而知，props的声明应该是在当前组件的父组件里来做。在React Native中，通常props的声明是和当前组件的声明放在一起的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最热子页面</span></div><div class="line">&lt;FavoriteTabPage  &#123;...this.props&#125; tabLabel=<span class="string">'最热'</span> flag=&#123;FlAG_STORAGE.flag_popular&#125;/&gt;</div><div class="line"></div><div class="line"><span class="comment">//趋势子页面</span></div><div class="line">&lt;FavoriteTabPage  &#123;...this.props&#125; tabLabel=<span class="string">'趋势'</span> flag=&#123;FlAG_STORAGE.flag_trending&#125;/&gt;</div></pre></td></tr></table></figure>
<p>在这里，收藏页面是父组件，而最热页面和趋势页面是其子组件。在收藏页面组件里声明了最热页面和趋势页面的组件。</p>
<p>而且我们也可以看到，最热页面和趋势页面组件都用的是同一个组件：<code>FavoriteTabPage</code>，而这两个页面的不同点只在于传入的两个props的不同：<code>tabLabel</code>和<code>flag</code>。</p>
<p>而在<code>FavoriteTabPage</code>组件内部，如果想调用flag这个props，可以使用<code>this.props.flag</code>来调用。</p>
<p>再来看一下state：</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>下面是最热和趋势页面的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FavoriteTabPage</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//组件的构造方法</span></div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state=&#123;</div><div class="line">            <span class="attr">dataSource</span>:<span class="keyword">new</span> ListView.DataSource(&#123;<span class="attr">rowHasChanged</span>:<span class="function">(<span class="params">r1,r2</span>)=&gt;</span>r1!==r2&#125;),</div><div class="line">            <span class="attr">isLoading</span>:<span class="literal">false</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面定义了两个state:</p>
<ol>
<li>dataSource:列表的数据源</li>
<li>isLoading:是否正在刷新</li>
</ol>
<p>这两个state都是将来可能经常变化的。比如在网络请求以后，列表的数据源会被替换掉，这个时候就要调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">     <span class="comment">//把新的值newDataArr对象传给dataSource</span></div><div class="line">      dataSource:newDataArr</div><div class="line"> &#125;)</div></pre></td></tr></table></figure></p>
<p>来触发<code>render()</code>方法来刷新列表组件。</p>
<h2 id="2-3-组件的生命周期"><a href="#2-3-组件的生命周期" class="headerlink" title="2.3 组件的生命周期"></a>2.3 组件的生命周期</h2><p>和iOS开发里<code>ViewController</code>的生命周期类似，组件也有生命周期，大致分为三大阶段：</p>
<ul>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ul>
<blockquote>
<p>DOM是前端的一个概念，暂时可以粗略理解为一个页面的树形结构。</p>
</blockquote>
<p>在每个阶段都有相应的状态和与之对应的回调函数，具体可以看下图：</p>
<p><img src="https://raw.githubusercontent.com/crazycodeboy/RNStudyNotes/master/React%20Native%E4%B9%8BReact%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B/images/component-lifecycle.jpg" alt="组件的生命周期"></p>
<blockquote>
<p>上图来自：<a href="http://www.devio.org/2016/08/10/React-Native%E4%B9%8BReact%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B-(%E4%B8%AD" target="_blank" rel="external">贾鹏辉的技术博客：React Native之React速学教程(中)</a>/)</p>
</blockquote>
<p>从上图中我们可以看到，React 为每个状态都提供了两种回调函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用。</p>
<p>在这里讲一下这其中几个重要的回调函数：</p>
<h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><p>该函数是组件的渲染回调函数，该函数是必须实现的，并且必须返回一个组件或一个包含多个子组件的组件。</p>
<blockquote>
<p>注意：该函数可以被调用多次：初始化时的渲染以及state改变以后的渲染都会调用这个函数。</p>
</blockquote>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h4><p>在初始化渲染执行之后立刻调用一次，也就是说，在这个函数调用时，当前组件已经渲染完毕了，相当于iOS开发中<code>ViewController</code>里的<code>viewDidLoad</code>方法。</p>
<blockquote>
<p>我们通常在这个方法里执行网络请求操作。</p>
</blockquote>
<h4 id="componentWillReceiveProps-object-nextProps"><a href="#componentWillReceiveProps-object-nextProps" class="headerlink" title="componentWillReceiveProps(object nextProps)"></a>componentWillReceiveProps(object nextProps)</h4><p>在当前组件接收到新的 props 的时候调用。此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。新的props可以从参数里取到，老的 props 可以通过 this.props 获取到。</p>
<blockquote>
<p>注意：在初始化渲染的时候，该方法不会调用。</p>
</blockquote>
<h4 id="shouldComponentUpdate-object-nextProps-object-nextState"><a href="#shouldComponentUpdate-object-nextProps-object-nextState" class="headerlink" title="shouldComponentUpdate(object nextProps, object nextState):"></a>shouldComponentUpdate(object nextProps, object nextState):</h4><p>在接收到新的 props 或者 state，将要渲染之前调用。如果确定新的 props 和 state 不会导致组件更新，则此处应该 返回 false，这样组件就不会更新，减少了性能上不必要的损耗。</p>
<blockquote>
<p>注意：该方法在初始化渲染的时候不会调用。</p>
</blockquote>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h4><p>在组件从 DOM 中移除的时候立刻被调用。例如当前页面点击返回键跳转到上一页面的时候就会调用。</p>
<blockquote>
<p>我们通常在这个方法里移除通知。具体做法在后文会提到。</p>
</blockquote>
<p>到此，已经讲解了一些组件相关的知识，下面来看一下我们如何使用组件来搭建界面。</p>
<h2 id="2-4-使用组件来搭建界面"><a href="#2-4-使用组件来搭建界面" class="headerlink" title="2.4 使用组件来搭建界面"></a>2.4 使用组件来搭建界面</h2><p>在这里我们举几个例子来看一下在React Native里搭建View的方式。</p>
<p>首先我们来看一下最热页面的cell是如何布局的：</p>
<h3 id="2-41-搭建cell组件"><a href="#2-41-搭建cell组件" class="headerlink" title="2.41 搭建cell组件"></a>2.41 搭建cell组件</h3><p>首先举一个在最热标签页面列表里的一个cell为例，讲解一下一个简单的UI组件是如何实现的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_4_1_1.png" alt="最热标签页面的cell"></p>
<p>我们把该组件定名为：<code>RespositoryCell</code>，结合代码来看一下具体的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RespositoryCell</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line"> </div><div class="line">    ...</div><div class="line">    </div><div class="line">    render()&#123;</div><div class="line"></div><div class="line">        <span class="comment">//获取当前cell的数据赋值给item</span></div><div class="line">        <span class="keyword">let</span> item = <span class="keyword">this</span>.props.projectModel.item?<span class="keyword">this</span>.props.projectModel.item:<span class="keyword">this</span>.props.projectModel;</div><div class="line"></div><div class="line">        <span class="comment">//收藏按钮</span></div><div class="line">        <span class="keyword">let</span> favoriteButton = &lt;TouchableOpacity</div><div class="line">            onPress=&#123;()=&gt;this.onPressFavorite()&#125;</div><div class="line">        &gt;</div><div class="line">            &lt;Image</div><div class="line">                style=&#123;[styles.favoriteImageStyle,this.props.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                source=&#123;this.state.favoriteIcon&#125;</div><div class="line">            /&gt;</div><div class="line">        &lt;/TouchableOpacity&gt;</div><div class="line"></div><div class="line">        return(</div><div class="line">            &lt;TouchableOpacity</div><div class="line">                 onPress=&#123;this.props.onSelect&#125;</div><div class="line">                 style=&#123;styles.container&#125;</div><div class="line">            &gt;</div><div class="line">                //整个cell的view</div><div class="line">                &lt;View style=&#123;styles.cellContainerViewStyle&#125;&gt;</div><div class="line"></div><div class="line">                    //1. 项目名称</div><div class="line">                    &lt;Text style=&#123;styles.repositoryTitleStyle&#125;&gt;&#123;item.full_name&#125;&lt;/Text&gt;</div><div class="line"></div><div class="line">                    //2. 项目介绍</div><div class="line">                    &lt;Text style=&#123;styles.repositoryDescriptionStyle&#125;&gt;&#123;item.description&#125;&lt;/Text&gt;</div><div class="line"></div><div class="line">                    //3. 底部 container</div><div class="line">                    &lt;View style=&#123;styles.bottomContainerViewStyle&#125;&gt;</div><div class="line"></div><div class="line">                        //3.1 作者container</div><div class="line">                        &lt;View style=&#123;styles.authorContainerViewStyle&#125;&gt;</div><div class="line"></div><div class="line">                            //3.11 作者名称</div><div class="line">                            &lt;Text style=&#123;styles.bottomTextStyle&#125;&gt;Author:&lt;/Text&gt;</div><div class="line"></div><div class="line">                            //3.12 作者头像</div><div class="line">                            &lt;Image</div><div class="line">                                style=&#123;styles.authorAvatarImageStyle&#125;</div><div class="line">                                source=&#123;&#123;uri:item.owner.avatar_url&#125;&#125;</div><div class="line">                             /&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line"></div><div class="line">                        //3.2 star container</div><div class="line">                        &lt;View style=&#123;styles.starContainerViewStyle&#125;&gt;</div><div class="line">                //3.21 star标题</div><div class="line">                            &lt;Text style=&#123;styles.bottomTextStyle&#125;&gt;Starts:&lt;/Text&gt;</div><div class="line">                       //3.21 star数量</div><div class="line">                            &lt;Text style=&#123;styles.bottomTextStyle&#125;&gt;&#123;item.stargazers_count&#125;&lt;/Text&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line"></div><div class="line">                        //3.3 收藏按钮</div><div class="line">                        &#123;favoriteButton&#125;</div><div class="line">                     &lt;/View&gt;</div><div class="line">                 &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里省略了处理交互事件等的函数，为了让大家集中在cell的布局和样式上。</p>
</blockquote>
<ul>
<li>这里声明了<code>RespositoryCell</code>组件，它继承于<code>Component</code>，也就是组件类，即是说，声明组件的时候必须都要继承与这个类。</li>
<li>集中看一下该组件的render方法，它返回的是该组件的实际布局：在语法上使用JSX，类似于HTML的标签式语法，很清楚地将cell的层级展现了出来：<ul>
<li>最外层被一个<code>View</code>组件包裹着，里面第一层有三个子组件：两个<code>Text</code>组件和一个作为底部背景的<code>View</code>组件。</li>
<li>底部背景的<code>View</code>组件又有三个子组件：<code>View</code>组件（显示作者信息），<code>View</code>组件（显示star信息）,收藏按钮。</li>
</ul>
</li>
</ul>
<p>试着结合代码来看一下下面的图片，可以看出组件的实际布局与代码的布局是高度一致的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_5_2.png" alt="Cell 布局 "></p>
<p>然而仅仅定义组件的层级关系是不够的，我们还需要定义组件的样式（例如图片组件的大小样式等等），这时候就通过定义一个样式的对象（通常使用常量对象）来定义一些需要使用的样式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//样式常量</span></div><div class="line"><span class="keyword">const</span> styles =StyleSheet.create(&#123;</div><div class="line"></div><div class="line">    <span class="comment">//项目cell的背景view的style       </span></div><div class="line">    cellContainerViewStyle:&#123;</div><div class="line">          </div><div class="line">        <span class="comment">//背景色</span></div><div class="line">        backgroundColor:<span class="string">'white'</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//内边距</span></div><div class="line">        padding:<span class="number">10</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//外边距</span></div><div class="line">        marginTop:<span class="number">4</span>,</div><div class="line">        <span class="attr">marginLeft</span>:<span class="number">6</span>,</div><div class="line">        <span class="attr">marginRight</span>:<span class="number">6</span>,</div><div class="line">        <span class="attr">marginVertical</span>:<span class="number">2</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//边框</span></div><div class="line">        borderWidth:<span class="number">0.3</span>,</div><div class="line">        <span class="attr">borderColor</span>:<span class="string">'#dddddd'</span>,</div><div class="line">        <span class="attr">borderRadius</span>:<span class="number">1</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//iOS的阴影</span></div><div class="line">        shadowColor:<span class="string">'#b5b5b5'</span>,</div><div class="line">        <span class="attr">shadowOffset</span>:&#123;<span class="attr">width</span>:<span class="number">3</span>,<span class="attr">height</span>:<span class="number">2</span>&#125;,</div><div class="line">        <span class="attr">shadowOpacity</span>:<span class="number">0.4</span>,</div><div class="line">        <span class="attr">shadowRadius</span>:<span class="number">1</span>,</div><div class="line">      </div><div class="line">        <span class="comment">//Android的阴影</span></div><div class="line">        elevation:<span class="number">2</span></div><div class="line">    &#125;,</div><div class="line">  </div><div class="line">    <span class="comment">//项目标题的style</span></div><div class="line">    repositoryTitleStyle:&#123;</div><div class="line">        <span class="attr">fontSize</span>:<span class="number">15</span>,</div><div class="line">        <span class="attr">marginBottom</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">color</span>:<span class="string">'#212121'</span>,</div><div class="line">    &#125;,</div><div class="line">  </div><div class="line">    <span class="comment">//项目介绍的style  </span></div><div class="line">    repositoryDescriptionStyle:&#123;</div><div class="line">        <span class="attr">fontSize</span>:<span class="number">12</span>,</div><div class="line">        <span class="attr">marginBottom</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">color</span>:<span class="string">'#757575'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//底部container的style</span></div><div class="line">    bottomContainerViewStyle:&#123;</div><div class="line">        <span class="attr">flexDirection</span>:<span class="string">'row'</span>,</div><div class="line">        <span class="attr">justifyContent</span>:<span class="string">'space-between'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//作者container的style</span></div><div class="line">    authorContainerViewStyle:&#123;</div><div class="line">        <span class="attr">flexDirection</span>:<span class="string">'row'</span>,</div><div class="line">        <span class="attr">alignItems</span>:<span class="string">'center'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//作者头像图片的style</span></div><div class="line">    authorAvatarImageStyle:&#123;</div><div class="line">        <span class="attr">width</span>:<span class="number">16</span>,</div><div class="line">        <span class="attr">height</span>:<span class="number">16</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//星星container的style</span></div><div class="line">    starContainerViewStyle: &#123;</div><div class="line">        <span class="attr">flexDirection</span>:<span class="string">'row'</span>,</div><div class="line">        <span class="attr">alignItems</span>:<span class="string">'center'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//底部文字的style</span></div><div class="line">    bottomTextStyle:&#123;</div><div class="line">       <span class="attr">fontSize</span>:<span class="number">11</span>,</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//收藏按钮的图片的style</span></div><div class="line">    favoriteImageStyle:&#123;</div><div class="line">        <span class="attr">width</span>:<span class="number">18</span>,</div><div class="line">        <span class="attr">height</span>:<span class="number">18</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在上面这段代码里定义了<code>RespositoryCell</code>组件所使用的所有样式，通过将其赋值给对应子组件的style属性来实现对组件样式的修改，例如我们看一下项目标题的组件和其样式的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;styles.repositoryTitleStyle&#125;&gt;&#123;item.full_name&#125;&lt;<span class="regexp">/Text&gt;</span></div></pre></td></tr></table></figure>
<p>在这里，我们首先定义了一个Text组件用来显示项目的标题。然后将<code>styles.repositoryTitleStyle</code>赋给了当前Text组件的style,而标题的具体内容，则通过<code>item.full_name</code>来获取。</p>
<p>需要注意的是，在JSX的语法中，对象需要被{}来包裹住，否则会被认为是常量。比如，如果这里写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;styles.repositoryTitleStyle&#125;&gt;item.full_name&lt;<span class="regexp">/Text&gt;</span></div></pre></td></tr></table></figure>
<p>那么所有项目cell的标题则都会显示为’’item.full_name’’，有图有真相：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_5_1_1.png" alt=""></p>
<p>这是初学者比较常犯的错误，所以要注意：在搭建页面的时候，一定要区分是对象还是常量。如果是对象就必须要用大括号括起来！如果是对象就必须要用大括号括起来！如果是对象就必须要用大括号括起来！</p>
<blockquote>
<p>这里每个样式里面的长，宽，内外边距，以及<code>flexDirection</code>等flexBox相关的布局属性就不介绍了。可以通过查找本文最后的相关链接来学习。</p>
</blockquote>
<h3 id="2-42-搭建静态表格页"><a href="#2-42-搭建静态表格页" class="headerlink" title="2.42 搭建静态表格页"></a>2.42 搭建静态表格页</h3><p>在React Native中搭建个人页，设置页这种静态表格页面的时候，可以用<code>ScrollView</code>组件包裹各种封装好的cell组件的形式实现。看一下这个Demo的个人页的效果图和代码实现：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_6_1_1.png" alt="个人页"></p>
<p>我们在项目中新建一个JavaScript文件，取名为取名为<code>MinePage.js</code> 。该文件就是个人页面的实现。结合代码来看一下它的实现（删除了处理点击cell的逻辑处理代码）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//区域一：引用区：</span></div><div class="line"><span class="comment">//引用React，Component(组件类)以及React Native中自带的组件</span></div><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    StyleSheet,</div><div class="line">    Text,</div><div class="line">    View,</div><div class="line">    Image,</div><div class="line">    ScrollView,</div><div class="line">    TouchableHighlight,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="comment">//引入项目中定义的其他组件(页面组件)和常量，路径为相对路径</span></div><div class="line"><span class="keyword">import</span> NavigationBar <span class="keyword">from</span> <span class="string">'../../common/NavigationBar'</span></div><div class="line"><span class="keyword">import</span> &#123;MORE_MENU&#125; <span class="keyword">from</span> <span class="string">'../../common/MoreMenu'</span></div><div class="line"><span class="keyword">import</span> GlobalStyles <span class="keyword">from</span> <span class="string">'../../../res/styles/GlobalStyles'</span></div><div class="line"><span class="keyword">import</span> ViewUtil <span class="keyword">from</span> <span class="string">'../../util/ViewUtils'</span></div><div class="line"><span class="keyword">import</span> &#123;FLAG_LANGUAGE&#125;<span class="keyword">from</span> <span class="string">'../../dao/LanguageDao'</span></div><div class="line"><span class="keyword">import</span> AboutPage <span class="keyword">from</span> <span class="string">'./AboutPage'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> CustomKeyPage <span class="keyword">from</span> <span class="string">'./CustomKeyPage'</span></div><div class="line"><span class="keyword">import</span> SortPage <span class="keyword">from</span> <span class="string">'./SortKeyPage'</span></div><div class="line"><span class="keyword">import</span> AboutMePage <span class="keyword">from</span> <span class="string">'./AboutMePage'</span></div><div class="line"><span class="keyword">import</span> CustomThemePage <span class="keyword">from</span> <span class="string">'./CustomThemePage'</span></div><div class="line"><span class="keyword">import</span> BaseComponent <span class="keyword">from</span> <span class="string">'../../base/BaseCommon'</span></div><div class="line"></div><div class="line"><span class="comment">//区域二：页面组件定义区域：</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MinePage</span> <span class="keyword">extends</span> <span class="title">BaseComponent</span> </span>&#123;</div><div class="line"></div><div class="line"> ...</div><div class="line">    </div><div class="line">    <span class="comment">//渲染页面中List中每个cell的统一函数</span></div><div class="line">    createSettingItem(tag,icon,text)&#123;</div><div class="line">        <span class="keyword">return</span> ViewUtil.createSettingItem(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.onClick(tag),icon,text,<span class="keyword">this</span>.state.theme.styles.tabBarSelectedIcon,<span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span> &lt;View style=&#123;GlobalStyles.listViewContainerStyle&#125;&gt;</div><div class="line">            &lt;NavigationBar</div><div class="line">                title=&#123;'我的'&#125;</div><div class="line">                style=&#123;this.state.theme.styles.navBar&#125;</div><div class="line">            /&gt;</div><div class="line">            &lt;ScrollView&gt;</div><div class="line"></div><div class="line">                &#123;/*=============项目信息Section=============*/&#125;</div><div class="line">                &lt;TouchableHighlight</div><div class="line">                    underlayColor= 'transparent'</div><div class="line">                    onPress=&#123;()=&gt;this.onClick(MORE_MENU.About)&#125;</div><div class="line">                &gt;</div><div class="line">                    &lt;View style=&#123;styles.itemInfoItemStyle&#125;&gt;</div><div class="line">                        &lt;View style=&#123;&#123;flexDirection:'row',alignItems:'center'&#125;&#125;&gt;</div><div class="line">                            &lt;Image source=&#123;require('../../../res/images/ic_trending.png')&#125;</div><div class="line">                                   style=&#123;[&#123;width:40,height:40,marginRight:10&#125;,this.state.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                            /&gt;</div><div class="line">                            &lt;Text&gt;GitHub Popular 项目信息&lt;/Text&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line">                        &lt;Image source=&#123;require('../../../res/images/ic_tiaozhuan.png')&#125;</div><div class="line">                            style=&#123;[&#123;height:22,width:22&#125;,this.state.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                        /&gt;</div><div class="line">                    &lt;/View&gt;</div><div class="line">                &lt;/TouchableHighlight&gt;</div><div class="line">                &#123;/*分割线*/&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*=============趋势管理Section=============*/&#125;</div><div class="line">                &lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;趋势管理&lt;/Text&gt;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*自定义语言*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Custom_Language,require('../../../res/images/ic_custom_language.png'),'自定义语言')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*语言排序*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Sort_Language,require('../../../res/images/ic_swap_vert.png'),'语言排序')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*=============标签管理Section=============*/&#125;</div><div class="line">                &lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;标签管理&lt;/Text&gt;</div><div class="line"></div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*自定义标签*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Custom_Key,require('../../../res/images/ic_custom_language.png'),'自定义标签')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*标签排序*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Sort_Key,require('../../../res/images/ic_swap_vert.png'),'标签排序')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*标签移除*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Remove_Key,require('../../../res/images/ic_remove.png'),'标签移除')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*=============设置Section=============*/&#125;</div><div class="line">                &lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;设置&lt;/Text&gt;</div><div class="line">                &#123;/*自定义主题*/&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Custom_Theme,require('../../../res/images/ic_view_quilt.png'),'自定义主题')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*展示自定义主题页面*/&#125;</div><div class="line">                &#123;this.renderCustomTheme()&#125;</div><div class="line">            &lt;/ScrollView&gt;</div><div class="line">        &lt;/View&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//区域三：定义页面组件样式区：</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line"></div><div class="line">    itemInfoItemStyle:&#123;</div><div class="line">        flexDirection:'row',</div><div class="line">        justifyContent:'space-between',</div><div class="line">        alignItems:'center',</div><div class="line">        padding:10,</div><div class="line">        height:76,</div><div class="line">        backgroundColor:'white'</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    groupTitleStyle:&#123;</div><div class="line">        marginLeft:10,</div><div class="line">        marginTop:15,</div><div class="line">        marginBottom:6,</div><div class="line">        color:'gray'</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以看到一个页面组件的全貌，它大致分为三个区域：</p>
<ol>
<li>引用区域</li>
<li>定义组件区域</li>
<li>定义样式区域</li>
</ol>
<p>下面两个区域在上一节已经介绍过。第一个区域，引用区域一般写在组件文件的开头，在这里一般是需要引入该组件需要的其他组件或者常量。</p>
<p>现在看一下该组件的<code>render()</code>函数，它返回了用来包裹整个页面的<code>View</code>组件，该组件有两个子组件</p>
<ul>
<li>NavigationBar组件（导航栏），传入了两个props：title和style。</li>
<li>ScrollView组件，包裹了项目信息Cell的View组件，分割线，项目Cell的View组件。需要注意的是，每个cell的组件都比较类似，所以在这里将生成它的代码封装起来做一个函数来调用：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">createSettingItem(tag,icon,text)&#123;</div><div class="line">        <span class="keyword">return</span>  ViewUtil.createSettingItem(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.onClick(tag),icon,text,<span class="keyword">this</span>.state.theme.styles.tabBarSelectedIcon,<span class="literal">null</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到这个函数传入的参数有三个：用来作标记的tag，图片 和标题文字。它的返回值通过调用ViewUtil组件的<code>createSettingItem</code>方法来实现。这个方法用于统一生成类似布局的cell。</p>
<p>看一下这个函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="comment">//ViewUtils.js</span></div><div class="line"><span class="keyword">static</span> createSettingItem(callBack,icon,text,tintColor,expandableIcon)&#123;</div><div class="line"></div><div class="line">        <span class="comment">//如果不传入icon，则不显示</span></div><div class="line">        <span class="keyword">let</span> image = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">if</span> (icon)&#123;</div><div class="line">            image = &lt;Image</div><div class="line">                source=&#123;icon&#125;</div><div class="line">                resizeMode='stretch'</div><div class="line">                style=&#123;[&#123;width:18,height:18,marginRight:10&#125;,tintColor]&#125;</div><div class="line">            /&gt;</div><div class="line">        &#125;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;&#123;backgroundColor:'white'&#125;&#125;&gt;</div><div class="line">                &lt;TouchableHighlight</div><div class="line">                    onPress=&#123;callBack&#125;</div><div class="line">                    underlayColor= 'transparent'</div><div class="line">                &gt;</div><div class="line">                    &lt;View style=&#123;styles.settingItemContainerStyle&#125;&gt;</div><div class="line">                        &lt;View style=&#123;&#123;flexDirection:'row',alignItems:'center'&#125;&#125;&gt;</div><div class="line">                            &#123;image&#125;</div><div class="line">                            &lt;Text&gt;&#123;text&#125;&lt;/Text&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line">                        &lt;Image source=&#123;expandableIcon?expandableIcon:require('../../res/images/ic_tiaozhuan.png')&#125;</div><div class="line">                               style=&#123;[&#123;marginRight:0,height:22,width:22&#125;,tintColor]&#125;//要用括号</div><div class="line">                        /&gt;</div><div class="line">                    &lt;/View&gt;</div><div class="line">                &lt;/TouchableHighlight&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数有5个参数：</p>
<ul>
<li>callback：点击cell时调用的方法，需要父组件传入</li>
<li>icon：cell左侧的图片</li>
<li>text：cell标题</li>
<li>tintColor：cell的主题颜色</li>
<li>expandableIcon:cell右侧的图片（三角箭头）</li>
</ul>
<p>因为在React Native中没有特定的<code>Button</code>组件，所以实现组件的点击都是通过被<code>TouchableHighlight</code>等可点击组件包裹来实现的。</p>
<p>常用的可以实现点击效果的是<code>View</code>组件和<code>Text</code>组件。</p>
<p>注意一下<code>TouchableHighlight</code>里面传入的两个props：</p>
<ol>
<li>如果需要在点击时颜色不变，可以将它的<code>underlayColor</code>设为<code>transparent</code>。</li>
<li>可以把点击时触发的函数传给它的<code>onPress</code>属性。所以，如果该cell被点击了，就会触发传入的callback。这个callback就等于当初传过来的箭头函数：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ViewUtil.createSettingItem(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.onClick(tag),icon,text,<span class="keyword">this</span>.state.theme.styles.tabBarSelectedIcon,<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>该函数是在个人页被调用的，用来实现点击cell时的跳转等操作。</p>
<blockquote>
<p>注意，在这个ViewUtils类中，我们可以定义很多常用的View组件，例如这种设置页面的cell，导航栏上的返回按钮等等。</p>
</blockquote>
<p>现在cell的实现讲完了，下面讲一下分割线和session的title。</p>
<p>先来看一下分割线：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>它的样式调用了<code>GlobalStyles</code>的<code>cellBottomLineStyle</code>。因为<code>GlobalStyles</code>是全局的样式文件（单独写在了一个js文件中），可以使用它来专门管理一些常用的样式。这样一来，我们就不需要在不同页面的组件页面里面重复声明样式常量了。</p>
<p>我们看一下如何定义全局的样式文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GlobalStyles.js</span></div><div class="line"><span class="built_in">module</span>.exports =&#123;</div><div class="line"></div><div class="line">    <span class="comment">//cell分割线样式</span></div><div class="line">    cellBottomLineStyle: &#123;</div><div class="line">        <span class="attr">height</span>: <span class="number">0.4</span>,</div><div class="line">        <span class="attr">opacity</span>:<span class="number">0.5</span>,</div><div class="line">        <span class="attr">backgroundColor</span>: <span class="string">'darkgray'</span>,</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//cell背景色样式</span></div><div class="line">    cell_container: &#123;</div><div class="line">        <span class="attr">flex</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">backgroundColor</span>: <span class="string">'white'</span>,</div><div class="line">        <span class="attr">padding</span>: <span class="number">10</span>,</div><div class="line">        <span class="attr">marginLeft</span>: <span class="number">5</span>,</div><div class="line">        <span class="attr">marginRight</span>: <span class="number">5</span>,</div><div class="line">        <span class="attr">marginVertical</span>: <span class="number">3</span>,</div><div class="line">        <span class="attr">borderColor</span>: <span class="string">'#dddddd'</span>,</div><div class="line">        <span class="attr">borderStyle</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">borderWidth</span>: <span class="number">0.5</span>,</div><div class="line">        <span class="attr">borderRadius</span>: <span class="number">2</span>,</div><div class="line">        <span class="attr">shadowColor</span>: <span class="string">'gray'</span>,</div><div class="line">        <span class="attr">shadowOffset</span>: &#123;<span class="attr">width</span>:<span class="number">0.5</span>, <span class="attr">height</span>: <span class="number">0.5</span>&#125;,</div><div class="line">        <span class="attr">shadowOpacity</span>: <span class="number">0.4</span>,</div><div class="line">        <span class="attr">shadowRadius</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">elevation</span>:<span class="number">2</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//当前屏幕高度</span></div><div class="line">    window_height:height,</div><div class="line">    <span class="comment">//当前屏幕宽度</span></div><div class="line">    window_width:width,</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因为使用了<code>module.exports</code>方法，在这里定义的全局样式可以在外部随意使用。</p>
<p>最后，Section Title的View就比较简单了，就是一个带有灰色文字的<code>View</code>组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;趋势管理&lt;/Text&gt;</div></pre></td></tr></table></figure>
<h3 id="2-43-搭建app基本骨架：TabBar-NavigationBar"><a href="#2-43-搭建app基本骨架：TabBar-NavigationBar" class="headerlink" title="2.43 搭建app基本骨架：TabBar + NavigationBar"></a>2.43 搭建app基本骨架：TabBar + NavigationBar</h3><p>做移动开发的朋友们应该比较了解，底部TabBar，顶部NavigationBar是移动app很主流的一个全局界面方案。然而在原生的React Native组件里面，没有将二者整合在一起的组件。幸运的是，有一个第三方组件比较好的将二者整合到了一起：<a href="https://github.com/happypancake/react-native-tab-navigator">react-native-tab-navigator</a>.</p>
<p>在它的主页告诉我们其导入方式是在项目主目录下执行：<code>npm install react-native-tab-navigator —save</code>命令。但是我建议使用<code>yarn</code>来引入所有第三方的组件：<code>yarn add react-native-tab-navigator</code>。因为使用npm命令安装第三方组件的时候有时会出现问题。而且建议引入第三方组件的时候都是用<code>yarn</code>来操作，比较保险一点。</p>
<p>在确认<code>react-native-tab-navigator</code>组件下载到了npm文件夹以后，就可以在项目中导入使用了。下面来看一下使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导入 react-native-tab-navigator 组件，取名为 TabNavigator(随意取名)</span></div><div class="line"><span class="keyword">import</span> TabNavigator <span class="keyword">from</span> <span class="string">'react-native-tab-navigator'</span>;</div><div class="line"></div><div class="line"><span class="comment">//每个tab对应的唯一标识，可以在外部获取</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> FLAG_TAB = &#123;</div><div class="line">    <span class="attr">flag_popularTab</span>: <span class="string">'flag_popularTab'</span>,</div><div class="line">    <span class="attr">flag_trendingTab</span>: <span class="string">'flag_trendingTab'</span>,</div><div class="line">    <span class="attr">flag_favoriteTab</span>: <span class="string">'flag_favoriteTab'</span>,</div><div class="line">    <span class="attr">flag_myTab</span>: <span class="string">'flag_myTab'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">BaseComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">      </div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> selectedTab = <span class="keyword">this</span>.props.selectedTab?<span class="keyword">this</span>.props.selectedTab:FLAG_TAB.flag_popularTab</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">selectedTab</span>:selectedTab,</div><div class="line">            <span class="attr">theme</span>:<span class="keyword">this</span>.props.theme</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _renderTab(Component, selectedTab, title, renderIcon) &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;TabNavigator.Item</div><div class="line">                selected=&#123;this.state.selectedTab === selectedTab&#125;</div><div class="line">                title=&#123;title&#125;</div><div class="line">                selectedTitleStyle=&#123;this.state.theme.styles.selectedTitleStyle&#125;</div><div class="line">                renderIcon=&#123;() =&gt; &lt;Image style=&#123;styles.tabItemImageStyle&#125;</div><div class="line">                                         source=&#123;renderIcon&#125;/&gt;&#125;</div><div class="line">                renderSelectedIcon=&#123;() =&gt; &lt;Image</div><div class="line">                    style=&#123;[styles.tabItemImageStyle,this.state.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                    source=&#123;renderIcon&#125;/&gt;&#125;</div><div class="line">                    onPress=&#123;() =&gt; this.onSelected(selectedTab)&#125;&gt;</div><div class="line">                &lt;Component &#123;...this.props&#125; theme=&#123;this.state.theme&#125; homeComponent=&#123;this&#125;/&gt;</div><div class="line">            &lt;/TabNavigator.Item&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">                &lt;TabNavigator</div><div class="line">                    tabBarStyle=&#123;&#123;opacity: 0.9,&#125;&#125;</div><div class="line">                    sceneStyle=&#123;&#123;paddingBottom: 0&#125;&#125;</div><div class="line">                &gt;</div><div class="line">                    &#123;this._renderTab(PopularPage, FLAG_TAB.flag_popularTab, '最热', require('../../../res/images/ic_polular.png'))&#125;</div><div class="line">                    &#123;this._renderTab(TrendingPage, FLAG_TAB.flag_trendingTab, '趋势', require('../../../res/images/ic_trending.png'))&#125;</div><div class="line">                    &#123;this._renderTab(FavoritePage, FLAG_TAB.flag_favoriteTab, '收藏', require('../../../res/images/ic_favorite.png'))&#125;</div><div class="line">                    &#123;this._renderTab(MinePage, FLAG_TAB.flag_myTab, '我的', require('../../../res/images/ic_my.png'))&#125;</div><div class="line">                &lt;/TabNavigator&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我省略了其他的代码，只保留了关于搭建<code>TabBar &amp;&amp; NavigationBar</code>的代码。</p>
<p>这里定义的是<code>HomePage</code>组件，是这个Demo用来管理这些tab的组件。</p>
<p>因为这个Demo一共有四个tab，所以将渲染的tab的代码抽取出来作为单独的一个函数：<code>_renderTab</code>。该函数有四个参数：</p>
<ul>
<li>Component：当前tab被点击后显示的组件。</li>
<li>selectedTab：当前tab的唯一标识。</li>
<li>title：当前tab的标题。</li>
<li>renderIcon：当前tab的图标。</li>
</ul>
<p>在<code>_renderTab</code>方法里，我们返回一个<code>TabNavigator.Item</code>组件，除了一些关于tab的props的定义以外，我们将属于该tab的组件填充了进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Component &#123;...this.props&#125; theme=&#123;this.state.theme&#125; homeComponent=&#123;this&#125;/&gt;</div></pre></td></tr></table></figure>
<p>在这里，{…this.props}是将当前<code>HomePage</code>的所有props赋给这个<code>Component</code>。还有另外两个props也定义了进去：<code>theme</code>和<code>homeComponent</code>。</p>
<p>这里用一个常量定义了四个tab的唯一标识，需要注意的是，这个常量是可以被其他组件获得的，以为它被<code>export</code>字段修饰了。</p>
<p>另外，还需要注意一下<code>HomePage</code>有一个属性是<code>selectedTab</code>，它用来标记当前选择的tab是哪一个。在<code>constructor</code>方法里做了一个判断，如果没有从外部组件传进来<code>selectedTab</code>，则需要初始化为<code>FLAG_TAB.flag_popularTab</code>。</p>
<h2 id="2-5-组件间通信"><a href="#2-5-组件间通信" class="headerlink" title="2.5 组件间通信"></a>2.5 组件间通信</h2><p>既然React项目是以组件为单位搭建的，那么一定少不了组件之间的数据和事件的传递，也就是组件之间的通信。</p>
<p>组件间通信分为两大类：</p>
<ol>
<li><p>有直接关系或间接关系的组件之间通信</p>
</li>
<li><p>无直接关系或间接关系的组件之间通信</p>
</li>
</ol>
<p>   ​</p>
<h3 id="2-51-有直接关系或间接关系的组件之间通信"><a href="#2-51-有直接关系或间接关系的组件之间通信" class="headerlink" title="2.51 有直接关系或间接关系的组件之间通信"></a>2.51 有直接关系或间接关系的组件之间通信</h3><p>我个人是这么理解父组件和子组件的关系的：</p>
<p>如果A组件包含了B组件，或者说在A组件里创建了B组件，那么A组件就是B组件的父组件；反过来B组件就是A组件的子组件，是有直接关系的组件。</p>
<p>比如：</p>
<ul>
<li><p>一个界面的导航栏组件是整个页面组件的子组件，因为这个导航栏组件被包含在了当前的页面组件当中。</p>
</li>
<li><p>从这个页面跳转到的下一个页面是当前页面的子组件：因为被包含在了当前页面组件的<code>Navigator</code>里。</p>
<p>​</p>
</li>
</ul>
<p>再加上子组件和子组件的通信，直接或间接关系组件之间的通信就分为下面这三种情况：</p>
<ol>
<li><p>父组件向子组件传递数据和事件。</p>
</li>
<li><p>子组件向父组件传递消息和事件。</p>
</li>
<li><p>子组件向子组件传递消息和事件。</p>
<p>​</p>
</li>
</ol>
<h4 id="父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。"><a href="#父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。" class="headerlink" title="父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。"></a>父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。</h4><p>在上面我们看到，在给页面布局的时候我们使用了导航栏组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;NavigationBar</div><div class="line">      title=&#123;<span class="string">'我的'</span>&#125;</div><div class="line">      style=&#123;<span class="keyword">this</span>.state.theme.styles.navBar&#125;</div><div class="line"> /&gt;</div></pre></td></tr></table></figure>
<p>在这里，当前页面组件将<code>&#39;我的&#39;</code>对象，以及<code>this.state.theme.styles.navBar</code>对象分别赋值给了导航栏组件。而导航栏接收到这两个值以后，在其内部可以通过<code>this.props.title</code>和<code>this.props.style</code>来获取到这两个值。这样一来，就实现了父组件向子组件传递数据的功能。</p>
<h4 id="子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现"><a href="#子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现" class="headerlink" title="子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现"></a>子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现</h4><p>举一个点击最热标签页面的一个cell进行回调后实现界面跳转的例子：</p>
<p>既然这个cell组件是在最热标签页面组件中生成的，那么cell组件就是其子组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ListView组件生成每个cell的函数</span></div><div class="line">renderRow(projectModel)&#123;</div><div class="line">  <span class="keyword">return</span> &lt;RespositoryCell</div><div class="line">            key = &#123;projectModel.item.id&#125;</div><div class="line">            theme=&#123;this.state.theme&#125;</div><div class="line">            projectModel=&#123;projectModel&#125;</div><div class="line">            onSelect = &#123;()=&gt;this.onSelectRepository(projectModel)&#125;</div><div class="line">            onFavorite=&#123;(item,isFavorite)=&gt;this.onFavorite(item,isFavorite)&#125;/&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>renderRow()</code>函数是<code>ListView</code>组件用来渲染每一行Cell的函数，必须返回一个Cell组件才可以。在这里我们自定义了一个<code>RespositoryCell</code>组件作为其Cell组件。</p>
<p>我们可以看到，这里面有5个props被赋值了，其中，<code>onSelect</code>和<code>onFavorite</code>被赋予了函数：</p>
<ul>
<li><code>onSelect</code>回调的是点击cell之后在最热标签页面里跳转页面的函数<code>onSelectRepository()</code>。</li>
<li><code>onFavorite</code>则回调的是更改最热标签页面对应收藏按钮状态的函数<code>onFavorite</code>（未被收藏时是空心的星；被收藏的话是实心的星）。</li>
</ul>
<p>下面在<code>RespositoryCell</code>组件内部看一下这两个函数是如何回调的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> item = <span class="keyword">this</span>.props.projectModel.item?<span class="keyword">this</span>.props.projectModel.item:<span class="keyword">this</span>.props.projectModel;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> favoriteButton = &lt;TouchableOpacity</div><div class="line">            &#123;/*调用点击收藏的回调函数*/&#125;</div><div class="line">            onPress=&#123;()=&gt;this.onPressFavorite()&#125;</div><div class="line">        &gt;</div><div class="line">            &lt;Image</div><div class="line">                style=&#123;[styles.favoriteImageStyle,this.props.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                source=&#123;this.state.favoriteIcon&#125;</div><div class="line">            /&gt;</div><div class="line">        &lt;/TouchableOpacity&gt;</div><div class="line"></div><div class="line">        return(</div><div class="line">            &lt;TouchableOpacity</div><div class="line">                 &#123;/*点击cell的回调函数*/&#125;</div><div class="line">                 onPress=&#123;this.props.onSelect&#125;</div><div class="line">                 style=&#123;styles.container&#125;</div><div class="line">            &gt;</div><div class="line">               &lt;View style=&#123;styles.cellContainerViewStyle&#125;&gt;</div><div class="line">                   ...</div><div class="line">                   &#123;favoriteButton&#125;</div><div class="line">               &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">          </div><div class="line">   onPressFavorite()&#123;</div><div class="line">        this.setFavoriteState(!this.state.isFavorite);</div><div class="line">        //点击收藏的回调函数</div><div class="line">        this.props.onFavorite(this.props.projectModel.item,!this.state.isFavorite)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>由上一节我们知道，父组件给子组件的props传值后，子组件里面对应的props就被赋值了。在这<code>RespositoryCell</code>组件里面就是<code>this.props.onSelect</code>和<code>this.props.onFavorite</code>。这两个函数被赋给了两个<code>TouchableOpacity</code>组件的<code>onPress</code>里面。这里的<code>()=&gt;</code>可以理解为为传递事件，表示当该控件被点击后的事件。</p>
<p>不同的是，<code>this.props.onFavorite()</code>是可以将两个值回传给其父组件。细心的同学会发现，在给<code>RespositoryCell</code>传值的时候，是有两个返回值存在的。</p>
<blockquote>
<p>注意，在这里的<code>TouchableOpacity</code>和上文提到的<code>TouchableHighlight</code>类似，都可以让非可点击组件变成可点击组件。区别在于配合<code>TouchableOpacity</code>使用时，点击后无高亮效果。而<code>TouchableHighlight</code>默认是有高亮效果的。</p>
</blockquote>
<p>OK，现在我们知道了父组件和子组件是如何传递数据和事件了：</p>
<ul>
<li>父组件到子组件：通过直接给属性赋值</li>
<li>子组件到父组件：通过父组件给子组件传递回调函数</li>
</ul>
<p>需要注意的是，上面讲的都是直接关系的父子组件，其实还有间接关系的组件，也就是两个组件之间有一个或多个组件连接着，比如父组件的子组件的子组件。这些组件之间的通信都可以通过上述的方法来实现，只不过是中间跨过多少层的区别而已。</p>
<blockquote>
<p>需要注意的是，这里说的父组件和子组件的通信，不仅仅包括这种直接关系，还包括间接关系，而间接关系的组件就是该组件与其子组件的子组件的关系。</p>
</blockquote>
<p>所以无论中间隔了多少组件，只要是存在于这种关系链上的组件，都可以用上述两种方式来传递数据和事件。</p>
<h4 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h4><p>虽然不是包含于被包含，由谁创建了谁的关系，但是同一父组件下的几个子组件（兄弟组件）也算得上是有间接关系了（中间夹着共同的父组件）。</p>
<p>那么在同一父组件下的两个子组件是如何传递数据呢？</p>
<p>答案是通过二者所共享的父组件的state来传递数据的</p>
<p>因为我们知道触发组件的渲染是通过<code>setState</code>方法的。因此，如果两个子组件都使用了他们的父组件的同一个state来渲染自己。</p>
<p>那么当其中一个子组件触发了<code>setState</code>,更新了这个共享的父组件的state，继而触发了父组件的<code>render()</code>方法，那么这两个子组件都会依据这个更新后的<code>state</code>来刷新自己，这样一来，就实现了子组件的数据传递。</p>
<p>到现在就讲完了有直接或间接关系的组件之间的通信，下面来讲一下无直接关系或间接关系的组件之间的通信：</p>
<h3 id="2-52-无直接关系和间接关系的组件之间通信"><a href="#2-52-无直接关系和间接关系的组件之间通信" class="headerlink" title="2.52 无直接关系和间接关系的组件之间通信"></a>2.52 无直接关系和间接关系的组件之间通信</h3><p>如果两个组件从属于不同的关系链既没有直接关系，也没有间接关系（例如不同模块下的两个页面组件），那么想实现通信的话，就需要通过通知机制，或者本地持久化方案来实现。在这里先介绍一下通知机制，而本地持久化会在下面单拿出一节来专门讲解。</p>
<p>通知机制可以通过这个Demo的收藏功能来讲解：</p>
<p>先大致介绍一下收藏的需求：</p>
<ol>
<li>在最热标签页或者语言趋势页面如果点击了收藏按钮，那么在收藏页面就会增加被收藏的项目（注意，点击收藏按钮后不进行网络请求，也就是说，收藏页面是没有网络请求的）。</li>
<li>而如果在收藏页面中取消了收藏，就需要在最热标签页面或语言趋势页面中对应的项目里面更新取消收藏的效果（同样没有网络请求）。</li>
</ol>
<p>因为这三个页面从属于不同模块， 而且又不是以网络请求的方式刷新列表，所以如果要满足上述需求，就需要使用通知或者本地存储的方式来实现。</p>
<p>在这个Demo中，第一个需求采用的是本地持久化方案，第二个需求采用的是通知机制。本地持久化方案我会在下一节单独介绍，在本节先讲一下在React Native里如何使用通知机制：</p>
<p>在React Native里面有专门的组件专门负责通知这一功能，它的名字是：<code>DeviceEventEmitter</code>，它是React Native内置的组件，我们可以直接将它导入到工程里。导入的方式和其他内置的组件一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    StyleSheet,</div><div class="line">    Text,</div><div class="line">    View,</div><div class="line">    Image,</div><div class="line">    DeviceEventEmitter,</div><div class="line">    TouchableOpacity</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div></pre></td></tr></table></figure>
<p>既然是通知，那么自然有接收的一方，也有发送的一方，这两个组件都需要引入该通知组件。</p>
<p>在接收的一方需要注册某个通知：</p>
<p>比如在该Demo里面，如果在收藏页面修改了收藏的状态，就要给最热标签页面发送一个通知。所以首先就需要在最热标签页面注册一个通知，注册通知后才能确保将来可以收到某个频道上的通知</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    ...</div><div class="line">    this.listener = DeviceEventEmitter.addListener(<span class="string">'favoriteChanged_popular'</span>,()=&gt; &#123;</div><div class="line">            <span class="keyword">this</span>.isFavoriteChanged = <span class="literal">true</span>;</div><div class="line">     &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里通过给<code>DeviceEventEmitter</code>的<code>addListener</code>方法传入两个参数来进行通知的注册：</p>
<ul>
<li>第一个参数是通知的频道，用来区别其他的通知。</li>
<li>第二个参数是需要调用的函数：在这里只是将<code>this.isFavoriteChanged</code>赋值为YES。它的目的是在于将来如果该值等于YES，就进行界面的再渲染，更新收藏状态。</li>
</ul>
<p>需要注意的是，有注册，就要有注销，在组件被卸载之前，需要将监听解除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillUnmount() &#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.listener)&#123;</div><div class="line">         <span class="keyword">this</span>.listener.remove();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们搞定了通知的注册，就可以在程序的任意地方发送通知了。在该需求中，我们需要拦截住在收藏页面里对项目的收藏按钮的点击，只要点击了，就发送通知：告知最热标签页面收藏的状态改变了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">onFavorite(item,isFavorite)&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    DeviceEventEmitter.emit(&apos;favoriteChanged_popular&apos;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，拦截了收藏按钮的点击。还记得么？这里<code>onFavorite()</code>函数就是上面说的点击收藏按钮的回调。</p>
<p>我们在这里发送了通知，只需传入频道名称即可。</p>
<p>是不是很easy？</p>
<p>OK，到这里我们讲完了组件间的通信这一块，简单回想一下各种关系的组件之间的通信方案。</p>
<p>下面我们来讲一下在React Native里的本地持久化的方案。</p>
<h2 id="2-6-本地持久化"><a href="#2-6-本地持久化" class="headerlink" title="2.6 本地持久化"></a>2.6 本地持久化</h2><p>类似于iOS 中的<code>NSUserDefault</code>， AsyncStorage 是React Native中的 Key-Value 存储系统，可以做本地持久化。</p>
<p>首先看它主要的几个接口：</p>
<h3 id="2-61-AsyncStorage常用接口"><a href="#2-61-AsyncStorage常用接口" class="headerlink" title="2.61 AsyncStorage常用接口"></a>2.61 AsyncStorage常用接口</h3><h4 id="根据键来获取值，获取的结果会放在回调函数中："><a href="#根据键来获取值，获取的结果会放在回调函数中：" class="headerlink" title="根据键来获取值，获取的结果会放在回调函数中："></a>根据键来获取值，获取的结果会放在回调函数中：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> getItem(key: string, <span class="attr">callback</span>:(error, result))</div></pre></td></tr></table></figure>
<h4 id="根据键来设置值："><a href="#根据键来设置值：" class="headerlink" title="根据键来设置值："></a>根据键来设置值：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> setItem(key: string, <span class="attr">value</span>: string, <span class="attr">callback</span>:(error))</div></pre></td></tr></table></figure>
<h4 id="根据键来移除项："><a href="#根据键来移除项：" class="headerlink" title="根据键来移除项："></a>根据键来移除项：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> removeItem(key: string, <span class="attr">callback</span>:(error))</div></pre></td></tr></table></figure>
<h4 id="获取所有的键："><a href="#获取所有的键：" class="headerlink" title="获取所有的键："></a>获取所有的键：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> getAllKeys(callback:(error, keys))</div></pre></td></tr></table></figure>
<h4 id="设置多项，其中-keyValuePairs-是字符串的二维数组，比如：-‘k1’-‘val1’-‘k2’-‘val2’-："><a href="#设置多项，其中-keyValuePairs-是字符串的二维数组，比如：-‘k1’-‘val1’-‘k2’-‘val2’-：" class="headerlink" title="设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]："></a>设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> multiSet(keyValuePairs, <span class="attr">callback</span>:(errors))</div></pre></td></tr></table></figure>
<h4 id="获取多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-："><a href="#获取多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-：" class="headerlink" title="获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]："></a>获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> multiGet(keys, <span class="attr">callback</span>:(errors, result))</div></pre></td></tr></table></figure>
<h4 id="删除多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-："><a href="#删除多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-：" class="headerlink" title="删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]："></a>删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> multiRemove(keys, <span class="attr">callback</span>:(errors))</div></pre></td></tr></table></figure>
<h4 id="清除所有的项目："><a href="#清除所有的项目：" class="headerlink" title="清除所有的项目："></a>清除所有的项目：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> clear(callback:(error))</div></pre></td></tr></table></figure>
<h3 id="2-62-AsyncStorage使用注意事项"><a href="#2-62-AsyncStorage使用注意事项" class="headerlink" title="2.62 AsyncStorage使用注意事项"></a>2.62 AsyncStorage使用注意事项</h3><p>需要注意的是，在使用AsyncStorage的时候，setItem里面传入的数组或字典等对象需要使用<code>JSON.stringtify()</code>方法把他们解析成JSON字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AsyncStorage.setItem(<span class="keyword">this</span>.favoriteKey,<span class="built_in">JSON</span>.stringify(favoriteKeys));</div></pre></td></tr></table></figure>
<blockquote>
<p>这里,favoriteKeys是一个数组。</p>
</blockquote>
<p>反过来，在getItem方法里获取数组或字典等对象的时候需要使用<code>JSON.parse</code>方法将他们解析成对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AsyncStorage.getItem(<span class="keyword">this</span>.favoriteKey,(error,result)=&gt;&#123;</div><div class="line">     <span class="keyword">if</span> (!error) &#123;</div><div class="line">          <span class="keyword">var</span> favoriteKeys=[];</div><div class="line">          <span class="keyword">if</span> (result) &#123;</div><div class="line">                favoriteKeys=<span class="built_in">JSON</span>.parse(result);</div><div class="line">          &#125;</div><div class="line">     ...</div><div class="line">      &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>这里，result被解析出来后是一个数组。</p>
</blockquote>
<h3 id="2-7-网络请求"><a href="#2-7-网络请求" class="headerlink" title="2.7 网络请求"></a>2.7 网络请求</h3><p>在React Native中，经常使用Fetch函数来实现网络请求，它支持GET和POST请求并返回一个Promise对象，这个对象包含一个正确的结果和一个错误的结果。</p>
<p>来看一下用Fetch发起的POST请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'http://www.***.cn/v1/friendList'</span>, &#123;</div><div class="line">          <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">          <span class="attr">headers</span>: &#123; <span class="comment">//header</span></div><div class="line">                <span class="string">'token'</span>: <span class="string">''</span></div><div class="line">            &#125;,</div><div class="line">          <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123; <span class="comment">//参数</span></div><div class="line">                <span class="string">'start'</span>: <span class="string">'0'</span>,</div><div class="line">                <span class="string">'limit'</span>: <span class="string">'20'</span>,</div><div class="line">            &#125;)</div><div class="line"> &#125;)</div><div class="line">            .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json()) <span class="comment">//把response转为json</span></div><div class="line">            .then(<span class="function">(<span class="params">responseData</span>) =&gt;</span> &#123; <span class="comment">// 上面的转好的json</span></div><div class="line">                 <span class="comment">//using responseData</span></div><div class="line">            &#125;)</div><div class="line">            .catch(<span class="function">(<span class="params">error</span>)=&gt;</span> &#123;</div><div class="line">                alert(<span class="string">'返回错误'</span>);</div><div class="line">            &#125;)</div></pre></td></tr></table></figure>
<p>从上面的代码中，我们可以大致看到：Fetch函数中，第一个参数是请求url，第二个参数是一个字典，包括方法，请求头，请求体等信息。</p>
<p>随后的<code>then</code>和<code>catch</code>分别捕捉了fetch函数的返回值：一个Promise对象的<code>正确结果</code>和<code>错误结果</code>。注意，这里面有两个<code>then</code>，其中第二个<code>then</code>把第一个<code>then</code>的结果拿了过来。而第一个<code>then</code>做的事情是把网络请求的结果转化为JSON对象。</p>
<p>那么什么是Promise对象呢？</p>
<p>Promise 是异步编程的一种解决方案，Promise对象可以获取某个异步操作的消息。它里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>它分为三种状态：</p>
<p><code>Pending</code>（进行中）、<code>Resolved</code>（已成功）和<code>Rejected</code>（已失败）</p>
<p>它的构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>：</p>
<p><code>resolve</code>函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；。<br><code>reject</code>函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>举个例子来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ... some code</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里resolve和reject的结果会分别被配套使用的Fetch函数的.then和.catch捕捉。</p>
<p>我个人的理解是：如果某个异步操作的返回值是一个Promise对象，那么我们就可以分别使用<code>.then</code>和<code>.catch</code>来捕捉正确和错误的结果。</p>
<p>再看一下GET请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fetch(url)</div><div class="line">    .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</div><div class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</div><div class="line">         resolve(result);</div><div class="line">     &#125;)</div><div class="line"></div><div class="line">     .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</div><div class="line">         reject(error)</div><div class="line">     &#125;)</div></pre></td></tr></table></figure>
<p>因为只是GET请求，所以不需要配置请求体，而且因为这个fetch函数返回值是一个Promise对象， 所以我们可以用<code>.then</code>和<code>.catch</code>来捕捉正确和错误的结果。</p>
<p>在项目中，我们可以创建一个抓们负责网络请求的工具HttpUtils类，封装GET和POST请求。看一下一个简单的封装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtls</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> get(url)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">            fetch(url)</div><div class="line">                .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</div><div class="line">                .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</div><div class="line">                    resolve(result);</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">                .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> post(url, data) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</div><div class="line">            fetch(url,&#123;</div><div class="line">                <span class="attr">method</span>:<span class="string">'POST'</span>,</div><div class="line">                <span class="attr">header</span>:&#123;</div><div class="line">                    <span class="string">'Accept'</span>:<span class="string">'application/json'</span>,</div><div class="line">                    <span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>,</div><div class="line">                &#125;,</div><div class="line">                <span class="attr">body</span>:<span class="built_in">JSON</span>.stringify(data)</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">                .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</div><div class="line">                    resolve(result);</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">                .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-8-离线缓存"><a href="#2-8-离线缓存" class="headerlink" title="2.8 离线缓存"></a>2.8 离线缓存</h3><p>离线缓存技术可以利用上文提到的<code>Fetch</code>和<code>AsyncStorage</code>实现，将请求url作为key，将返回的结果作为值存入本地数据里。</p>
<p>在下一次请求之前查询是否有缓存，缓存是否过期，如果有缓存并且没有过期，则拿到缓存之后，立即返回进行处理。否则继续进行网络请求。</p>
<p>而且即使没有网络，最终返回错误，也可以拿到缓存数据，立即返回。</p>
<p>来看一下在该项目里面是如何实现离线缓存的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取数据</span></div><div class="line">    fetchRespository(url) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">//首先获取本地缓存</span></div><div class="line">            <span class="keyword">this</span>.fetchLocalRespository(url)</div><div class="line">                .then(<span class="function">(<span class="params">wrapData</span>)=&gt;</span> &#123;</div><div class="line">                    <span class="comment">//本地缓存获取成功</span></div><div class="line">                <span class="keyword">if</span> (wrapData) &#123;</div><div class="line">                    <span class="comment">//缓存对象存在</span></div><div class="line">                    resolve(wrapData,<span class="literal">true</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//缓存对象不存在，进行网络请求</span></div><div class="line">                    <span class="keyword">this</span>.fetchNetRepository(url)</div><div class="line"></div><div class="line">                        <span class="comment">//网路请求成功</span></div><div class="line">                        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</div><div class="line">                            resolve(data);</div><div class="line">                        &#125;)</div><div class="line">                        <span class="comment">//网路请求失败</span></div><div class="line">                        .catch(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</div><div class="line">                            reject(e);</div><div class="line">                        &#125;)</div><div class="line">                &#125;</div><div class="line">            &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</div><div class="line">                    <span class="comment">//本地缓存获取失败，进行网络请求</span></div><div class="line">                    <span class="keyword">this</span>.fetchNetRepository(url)</div><div class="line"></div><div class="line">                        <span class="comment">//网路请求成功</span></div><div class="line">                        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">                            resolve(result);</div><div class="line">                        &#125;)</div><div class="line">                        <span class="comment">//网路请求失败</span></div><div class="line">                        .catch(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</div><div class="line">                            reject(e);</div><div class="line">                        &#125;)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在上面的方法中，包含了获取本地缓存和网络请求的两个方法。</p>
<p>首先是尝试获取本地缓存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//获取本地缓存</span></div><div class="line">    fetchLocalRespository(url)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">            <span class="comment">// 获取本地存储</span></div><div class="line">            AsyncStorage.getItem(url, (error, result)=&gt;&#123;</div><div class="line">                <span class="keyword">if</span> (!error)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">//必须使用parse解析成对象</span></div><div class="line">                        resolve(<span class="built_in">JSON</span>.parse(result));</div><div class="line">                    &#125;<span class="keyword">catch</span> (e)&#123;</div><div class="line">                        <span class="comment">//解析失败</span></div><div class="line">                        reject(e);</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//获取缓存失败</span></div><div class="line">                    reject(error);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>AsyncStorage.getItem</code>方法的结果也可以使用Promise对象来包装。因此，<code>this.fetchLocalRespository(url)</code>的结果也就可以被<code>.then</code>和<code>.catch</code>捕捉到了。</p>
</blockquote>
<p>如果获取本地缓存失败，就会调用网络请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    fetchNetRepository(url)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">            fetch(url)</div><div class="line">                .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</div><div class="line">                .catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</div><div class="line">                    reject(error);</div><div class="line">                &#125;).then(<span class="function">(<span class="params">responseData</span>)=&gt;</span>&#123;</div><div class="line">                    resolve(responseData);</div><div class="line">                 &#125;)</div><div class="line">             &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-9-主题更换"><a href="#2-9-主题更换" class="headerlink" title="2.9 主题更换"></a>2.9 主题更换</h3><p>这个Demo有一个主题更换的需求，在主题设置页点击某个颜色之后，全app的颜色方案就会改变：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_14.png" alt=""></p>
<p>我们只需要将四个模块的第一个页面的主题修改即可，因为第二个页面的主题都是从第一个页面传进去的，所以只要第一个页面的主题改变了即可。</p>
<p>但是，我们应该不能在选择新主题之后同时向这四个页面都发送通知，命令它们修改自己的页面，而是应该采取一个更加优雅的方法来解决这个问题：使用父类。</p>
<p>新建一个<code>BaseCommon.js</code>页面，作为这四个页面的父类。在这个父类里面接收主题更改的通知，并更新自己的主题。这样一来，继承它的这四个页面就都会刷新自己：</p>
<p>来看一下这个父类的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    DeviceEventEmitter</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;ACTION_HOME&#125; <span class="keyword">from</span> <span class="string">'../pages/Entry/HomePage'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state=&#123;</div><div class="line">            <span class="attr">theme</span>:<span class="keyword">this</span>.props.theme,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="keyword">this</span>.baseListener = DeviceEventEmitter.addListener(<span class="string">'ACTION_BASE'</span>,(action,parmas)=&gt;<span class="keyword">this</span>.changeThemeAction(action,parmas));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//卸载前移除通知</span></div><div class="line">    componentWillUnmount() &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.baseListener)&#123;</div><div class="line">            <span class="keyword">this</span>.baseListener.remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//接收通知</span></div><div class="line">    changeThemeAction(action,params)&#123;</div><div class="line">        <span class="keyword">if</span> (ACTION_HOME.A_THEME === action)&#123;</div><div class="line">            <span class="keyword">this</span>.onThemeChange(params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//更新theme</span></div><div class="line">    onThemeChange(theme)&#123;</div><div class="line">        <span class="keyword">if</span>(!theme)<span class="keyword">return</span>;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            <span class="attr">theme</span>:theme</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在更新主题页面的更新主题事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">onSelectTheme(themeKey) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.themeDao.save(ThemeFlags[themeKey]);</div><div class="line">        <span class="keyword">this</span>.props.onClose();</div><div class="line">        DeviceEventEmitter.emit(<span class="string">'ACTION_BASE'</span>,ACTION_HOME.A_THEME,ThemeFactory.createTheme(</div><div class="line">            ThemeFlags[themeKey]</div><div class="line">        ))</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-10-功能调试"><a href="#2-10-功能调试" class="headerlink" title="2.10 功能调试"></a>2.10 功能调试</h3><p>我们可以使用浏览器的开发者工具来调试React Native项目，可以通过打断点的方式来看数据信息以及方法的调用：</p>
<ol>
<li>首先在iOS模拟器中点击<code>command + D</code>，然后再弹出菜单里点击<code>Debug JS Remotely</code>。随后就打开了浏览器进入了调试。</li>
</ol>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_8_1_1.png" alt=""></p>
<ol>
<li>浏览器一般会展示下面的页面，然后点击<code>command + option + J</code>进入真生的调试界面。</li>
</ol>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_9.png" alt=""></p>
<ol>
<li>点击最上方的<code>Sources</code>，然后点击左侧<code>debuggerWorker.js</code>下的<code>localhost:8081</code>，就可以看到目录文件。点击需要调试的文件，在行数栏就可以打断点了。</li>
</ol>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_10_1.png" alt=""></p>
<h3 id="2-11-适配iOS和Android平台"><a href="#2-11-适配iOS和Android平台" class="headerlink" title="2.11 适配iOS和Android平台"></a>2.11 适配iOS和Android平台</h3><p>因为React Native讲求的是一份代码跑在两个平台上，而客观上这两个平台又有一些不一样的地方，所以就需要在别要的时候做一下两个平台的适配。</p>
<p>例如导航栏：在iOS设备中是存在导航栏的，而安卓设备上是没有的。所以在定制导航栏的时候，在不同平台下给导航栏设置不同的高度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    StyleSheet,</div><div class="line">    Platform,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> NAV_BAR_HEIGHT_IOS = <span class="number">44</span>;</div><div class="line"><span class="keyword">const</span> NAV_BAR_HEIGHT_ANDROID = <span class="number">50</span>;</div><div class="line"></div><div class="line">navBarStyle: &#123;</div><div class="line">        <span class="attr">flexDirection</span>: <span class="string">'row'</span>,</div><div class="line">        <span class="attr">alignItems</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">justifyContent</span>: <span class="string">'space-between'</span>,</div><div class="line">        <span class="attr">height</span>: Platform.OS === <span class="string">'ios'</span> ? NAV_BAR_HEIGHT_IOS : NAV_BAR_HEIGHT_ANDROID,</div><div class="line"> &#125;,</div></pre></td></tr></table></figure>
<p>上面的<code>Platform</code>是React Native内置的用于区分平台的库，可以在引入后直接使用。</p>
<p>建议在调试程序的时候，同时打开iOS和Android的模拟器进行调试，因为有些地方可能在某个平台上是没问题的，但是另一个平台上有问题，这就需要使用<code>Platform</code>来区分平台。</p>
<h3 id="2-12-组织项目结构"><a href="#2-12-组织项目结构" class="headerlink" title="2.12 组织项目结构"></a>2.12 组织项目结构</h3><p>在终端输入<code>react-native demo --version 0.44.0</code>命令以后，就会初始化一个React Native版本为0.44.0的项目。这个最初项目里面直接就包含了iOS和Android的工程文件夹，可以用对应的IDE打开后编译运行。</p>
<p>在新建一个React Native项目之后的根目录结构是这样的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_11.png" alt=""></p>
<p>或者也可以根目录下输入<code>react-native run-ios</code>或者<code>react-native run-android</code>指令， 就会自动打开模拟器运行项目(前提是安装了相应的开发环境)。</p>
<p>但是一个比较完整的项目仅仅有这些类别的文件是不够的，还需要一些工具类，模型类，资源等文件。为了很好地区分它们，使项目结构一目了然，需要组织好项目文件夹以及类的命名，下面是我将教程里的文件夹命名和结构稍加修改后的一个方案，可供大家参考：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_12.png" alt=""></p>
<p>  ​</p>
<h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><p>从最开始的FlexBox布局的学习到现在这个项目的总结完成有了快两个月的时间了。我在这里说一下这段学习过程中的一些感受：</p>
<h3 id="关于学习成本"><a href="#关于学习成本" class="headerlink" title="关于学习成本"></a>关于学习成本</h3><p>我觉得这一点应该是所有未接触到React Native的人最关心的一点了，所以我将它放到了总结里的第一位。我在这里取两种典型的群体来做比较：</p>
<ol>
<li>只会某种Native开发但是不会JavaScript等前端知识的人群。</li>
<li>只会前端知识但是不会任何一种Native开发的人群。</li>
</ol>
<p>对于这两种人群来说，在React Native的学习过程中成本都不小。但不同的是，这两种人群的学习成本在整个学习过程中的不同阶段是不一样的。怎么说呢？</p>
<p>对于第一种人群，因为缺乏前端相关知识，所以在组建的布局，以及JavaScript的语法上会有点吃力。而这两点恰恰是React Native学习的敲门砖，因此，对于这种群体，在学习React Native的初期会比较吃力，学习成本很大。</p>
<h3 id="关于如何配合视频来学习"><a href="#关于如何配合视频来学习" class="headerlink" title="关于如何配合视频来学习"></a>关于如何配合视频来学习</h3><p>在结合视频学习的时候一定要跟上思路，如果讲师是边写代码边讲解，就一定要弄清楚每一行代码的意义在哪里，为什么要这么写，千万不要怕浪费时间而快速略过。停下脚步来思考实际上是节省时间：因为如果你不试着去理解代码和讲师的思路，在后来你会越来越看不懂，反而浪费大量时间重新回头看。</p>
<p>所以我认为最好是先听一遍讲师讲的内容，理清思路，然后再动手写代码，这样效率会比较高，在将来出现的问题也会更少。</p>
<h1 id="四-学习参考资料"><a href="#四-学习参考资料" class="headerlink" title="四. 学习参考资料"></a>四. 学习参考资料</h1><p>下面是我近1个半月以来收集的比较好的React Native入门资料和博客，分享给大家：</p>
<ul>
<li><a href="http://reactnative.cn/" target="_blank" rel="external">React Native中文网</a></li>
<li><a href="http://www.devio.org/" target="_blank" rel="external">贾鹏辉的技术博客</a></li>
<li><a href="http://www.jianshu.com/p/fa0874be0827" target="_blank" rel="external">Marno:给所有开发者的React Native详细入门指南</a></li>
<li><a href="http://www.w3cplus.com/css3/a-guide-to-flexbox.html" target="_blank" rel="external">大漠:一个完整的Flexbox指南</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">阮一峰:Flex 布局教程：语法篇</a></li>
<li><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="external">八段代码彻底掌握 Promise</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰：Promise对象</a></li>
<li><a href="http://www.jianshu.com/p/454f2e6f28e9#rd" target="_blank" rel="external">asce1885:React Native 高质量学习资料汇总</a></li>
<li><a href="https://juejin.im/post/591ec246da2f60005d30654c" target="_blank" rel="external">世锋日上:ReactNative 学习资源大汇集</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行了2个星期的基础学习（Flexbox, React.js, JSX, JavaScript）之后，想通过一个实战项目来提高React Native的开发水平，于是找到了下面这个项目：&lt;/p&gt;
&lt;h1 id=&quot;一-项目介绍&quot;&gt;&lt;a href=&quot;#一-项目介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 项目介绍&quot;&gt;&lt;/a&gt;一. 项目介绍&lt;/h1&gt;&lt;p&gt;这是我在学习&lt;a href=&quot;http://www.devio.org/&quot;&gt;贾鹏辉&lt;/a&gt;老师在慕课网上的一个很火的&lt;a href=&quot;http://coding.imooc.com/class/89.html&quot;&gt;React Native实战的教程&lt;/a&gt;后，写出的课程Demo。该课程是慕课网里很火的一个React Native课程，当初在看了课程介绍和课程安排觉得讲解的点还是很全的，所以毫不犹豫地买了下来。&lt;/p&gt;
&lt;p&gt;从看视频，敲代码到重构，改bug，大概花了2个多星期的时间，除了调用友盟的SDK以及CodePush集成之外，其他的部分都基本完成了，而且同时可以在iOS和Android设备上运行：&lt;br&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/rn_13.png&quot; alt=&quot;上排是iOS模拟器 | 下排是Android模拟器&quot;&gt;&lt;/p&gt;
&lt;p&gt;而且比较吸引人的是该项目可以实现多个主题的切换：&lt;br&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/rn_15.png&quot; alt=&quot;多主题切换&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;切换的技术实现会在下文给出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用一个动图来过一遍大致的需求：&lt;br&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/github%E5%AE%A2%E6%88%B7%E7%AB%AF_4.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Demo GitHub地址：&lt;a href=&quot;https://github.com/knightsj/GitHubPopular-SJ&quot;&gt;GitHubPopular-SJ&lt;/a&gt;&lt;br&gt;可以按照README文件里的方法运行该项目。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已经贾老师允许上传到GitHub&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;值得一提的是：这确实是一门物有所值的课程，可以让想入门React Native的开发者少走很多弯路。虽然我上传的Demo可以实现视频里大部分功能，但是经过调试，修改后的代码信息量还是很有限的，而且老师在视频中讲解的很多关于实际开发的知识点在代码中并没有体现出来，所以还是建议各位报名参加课程来提高自己的开发水平。&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://github.com/knightsj/knightsj.github.io/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="https://github.com/knightsj/knightsj.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>YTKNetwork源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/07/18/YTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/07/18/YTKNetwork源码解析/</id>
    <published>2017-07-18T05:35:08.000Z</published>
    <updated>2017-07-18T05:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS开发来说，就算是没有用过<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork框架</a>，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。</p>
<p>在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。</p>
<h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h1><hr>
<p>先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKRequest架构图"></p>
<blockquote>
<p>在这里简单说明一下：</p>
<ol>
<li>YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 </li>
<li>YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。</li>
<li>我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。</li>
<li>YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。</li>
</ol>
</blockquote>
<p>OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。</p>
<a id="more"></a>
<h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h1><hr>
<p>YTKNetwork框架采用的设计模式是<strong>命令模式（Command Pattern）</strong>。</p>
<p>首先看一下命令模式的定义：</p>
<blockquote>
<p>命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>摘自：<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a></p>
</blockquote>
<p>看一下命令模式的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令模式类图.png"></p>
<p>图中英文的含义：</p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td>抽象命令类    </td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>命令类的实现类（子类）</td>
</tr>
<tr>
<td>Invoker</td>
<td>调用者    </td>
</tr>
<tr>
<td>Receiver</td>
<td>命令接收者（执行者)</td>
</tr>
<tr>
<td>Client</td>
<td>客户端</td>
</tr>
</tbody>
</table>
<p>详细介绍一下：</p>
<ol>
<li>命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
</ol>
<p>可能还是觉得有点抽象，在这里举一个<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a>里的例子，一个客人在餐厅点餐的过程：</p>
<ol>
<li>你将点的菜写在订单里，交给了服务员。</li>
<li>服务员将订单交给厨师。</li>
<li>厨师做好菜之后将做好的菜交给服务员。</li>
<li>最后服务员把菜递给你。</li>
</ol>
<p>在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。<br>所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。</p>
<p>结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Command</th>
<th>ConcreteCommand</th>
<th>Invoker</th>
<th>Receiver</th>
<th>Client</th>
</tr>
</thead>
<tbody>
<tr>
<td>餐厅</td>
<td>空白订单</td>
<td>填入菜名的订单</td>
<td>服务员</td>
<td>厨师</td>
<td>客人</td>
</tr>
<tr>
<td>YTKNetwork</td>
<td>YTKBaseRequest</td>
<td>CustomRequest</td>
<td>YTKNetworkAgent</td>
<td>AFNetworking</td>
<td>ViewController/ViewModel</td>
</tr>
</tbody>
</table>
<p>可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。</p>
<p>另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。</p>
<p>相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。</p>
<h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><hr>
<p>在真正讲解源码之前，我先详细说一下各个类的职责:</p>
<h2 id="3-1-责任介绍"><a href="#3-1-责任介绍" class="headerlink" title="3.1 责任介绍"></a>3.1 责任介绍</h2><table>
<thead>
<tr>
<th>类名</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKRequest</td>
<td>YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。</td>
</tr>
<tr>
<td>YTKNetworkConfig</td>
<td>被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。</td>
</tr>
<tr>
<td>YTKNetworkPrivate</td>
<td>提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。</td>
</tr>
<tr>
<td>YTKNetworkAgent</td>
<td>真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。</td>
</tr>
<tr>
<td>YTKBatchRequest</td>
<td>可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。</td>
</tr>
<tr>
<td>YTKBatchRequestAgent</td>
<td>负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。</td>
</tr>
<tr>
<td>YTKChainRequest</td>
<td>可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。</td>
</tr>
<tr>
<td>YTKChainRequestAgent</td>
<td>负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。</td>
</tr>
</tbody>
</table>
<p>OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。</p>
<h2 id="3-2-单个请求"><a href="#3-2-单个请求" class="headerlink" title="3.2 单个请求"></a>3.2 单个请求</h2><h3 id="3-21-单个请求的配置"><a href="#3-21-单个请求的配置" class="headerlink" title="3.21 单个请求的配置"></a>3.21 单个请求的配置</h3><p><a href="https://github.com/yuantiku/YTKNetwork/blob/master/Docs/BasicGuide_cn.md">官方的教程</a>建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application </div><div class="line">   didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">   YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];</div><div class="line">   config.baseUrl = <span class="string">@"http://yuantiku.com"</span>;</div><div class="line">   config.cdnUrl = <span class="string">@"http://fen.bi"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RegisterApi.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"YTKRequest.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RegisterApi</span> : <span class="title">YTKRequest</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RegisterApi.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"RegisterApi.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RegisterApi</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_username;</div><div class="line">    <span class="built_in">NSString</span> *_password;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//初始化的时候将两个参数值传入</span></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _username = username;</div><div class="line">        _password = password;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需要和baseUrl拼接的地址</span></div><div class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</div><div class="line">    <span class="comment">// “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息</span></div><div class="line">    <span class="keyword">return</span> <span class="string">@"/iphone/register"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求方法，某人是GET</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求体</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。</p>
<h3 id="3-22-单个请求的发起"><a href="#3-22-单个请求的发起" class="headerlink" title="3.22 单个请求的发起"></a>3.22 单个请求的发起</h3><p>还是刚才的注册API，在实例化以后，直接调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法）就可以发起它：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">        &#125; failure:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是以block的形式回调，YTKNetwork也支持代理的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        api.delegate = <span class="keyword">self</span>;</div><div class="line">        [api start];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有两点需要注意的是：</p>
<ol>
<li>必须给自定义请求类（RegisterApi）调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法），才能真正发起请求。</li>
<li>在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。</li>
</ol>
<p>知道了YTKRequest请求是如何在外部发起的，我们现在从<code>startWithCompletionBlockWithSuccess:failure</code>方法开始，来看一下YTKNetwork都做了什么：</p>
<p>首先来到YTKBaseRequest类（因为最早是由它定义的该方法）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line"><span class="comment">//传入成功和失败的block,并保存起来</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="comment">//保存成功和失败的回调block，便于将来调用</span></div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    <span class="comment">//发起请求</span></div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//保存成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                              failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当保存完成功和失败的block以后，调用<code>start</code>方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了<code>start</code>方法，但是由于YTKRequest类是它的子类并也实现了<code>start</code>方法，所以这里最先走的是YTKRequest类的<code>start</code>方法）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理）</span></div><div class="line">    _dataFromCache = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//5. 回调之前的操作</span></div><div class="line">        <span class="comment">//5.1 缓存处理</span></div><div class="line">        [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line">        </div><div class="line">        <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">        [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line">        </div><div class="line">        YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//6. 执行回调</span></div><div class="line">        <span class="comment">//6.1 请求完成的代理</span></div><div class="line">        [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">        <span class="comment">//6.2 请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">            strongSelf.successCompletionBlock(strongSelf);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">        [strongSelf clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个<code>start</code>方法里，它做的是请求之前缓存的查询和检查工作:</p>
<ul>
<li>如果忽略缓存，或者缓存获取失败，调用<code>startWithoutCache</code>方法（参考1-3的情况），发起请求。</li>
<li>如果能成功获取到缓存，则直接回调（参考4-7的情况）。</li>
</ul>
<p>我们来看一下每一步的具体实现：</p>
<ol>
<li><code>ignoreCache</code>属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。</li>
<li><code>resumableDownloadPath</code>是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。</li>
<li><code>loadCacheWithError：</code>方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒）</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache time"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 是否有缓存的元数据，如果没有，返回错误</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheMetadata]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid metadata. Cache may not exist"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，再验证是否有效</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateCacheWithError:error]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，而且有效，再验证是否能取出来</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheData]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache data"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。</p>
<p>我们来看一下上面关于缓存的元数据的获取方法：<code>loadCacheMetadata</code>方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheMetadata &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheMetadataFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            <span class="comment">//将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata</span></div><div class="line">            _cacheMetadata = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            YTKLog(<span class="string">@"Load cache metadata failed, reason = %@"</span>, exception.reason);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。<br>YTKCacheMetadata类被定义在YTKRequest.m文件里面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">long</span> <span class="keyword">long</span> version;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。<br>因此，<code>loadCacheMetadata</code>方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的<code>cacheMetadata</code>属性上。</p>
<p>现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 是否大于过期时间</span></div><div class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</div><div class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</div><div class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache expired"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 缓存的版本号是否符合</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</div><div class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache version mismatch"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 敏感信息是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</div><div class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</div><div class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></div><div class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache sensitive data mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// app的版本是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</div><div class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</div><div class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"App version mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果每项元数据信息都能通过，再在<code>loadCacheData</code>方法里面验证缓存是否能被取出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheData &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</div><div class="line">        _cacheData = data;</div><div class="line">        _cacheString = [[<span class="built_in">NSString</span> alloc] initWithData:_cacheData encoding:<span class="keyword">self</span>.cacheMetadata.stringEncoding];</div><div class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.responseSerializerType) &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Do nothing.</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                _cacheJSON = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:_cacheData options:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span> error:&amp;error];</div><div class="line">                <span class="keyword">return</span> error == <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                _cacheXML = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:_cacheData];</div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。</p>
<p>当确认缓存可以成功取出后，手动设置<code>dataFromCache</code>属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。</p>
<p>然后在真正回调之前做了如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="comment">//5. 回调之前的操作</span></div><div class="line">    <span class="comment">//5.1 缓存处理</span></div><div class="line">    [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">    [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line"></div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.1：<code>requestCompletePreprocessor</code>方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//保存响应数据到缓存</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//保存响应数据到缓存</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line"><span class="comment">//保存响应数据到缓存</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// New data will always overwrite old data.</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到, <code>requestCompletePreprocessor</code>方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要<code>cacheTimeInSeconds</code>方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是<code>isDataFromCache</code>方法返回NO。<br>但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。</p>
</blockquote>
<p>接着看下5.2：<code>requestCompleteFilter</code>方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompleteFilter &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">         strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，在用户同时实现了代理和block的情况下，二者都会被调用。</p>
</blockquote>
<p>到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。</p>
<p>反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么：</p>
<p>仔细看一下上面的<code>start</code>方法，我们会发现，如果缓存不满足条件时，会直接调用<code>startWithoutCache</code>方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么在<code>startWithoutCache</code>方法里都做了什么呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)startWithoutCache &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 清除缓存</span></div><div class="line">    [<span class="keyword">self</span> clearCacheVariables];</div><div class="line">    </div><div class="line">    <span class="comment">//2. 调用父类的发起请求</span></div><div class="line">    [<span class="keyword">super</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清除当前请求对应的所有缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearCacheVariables &#123;</div><div class="line">    _cacheData = <span class="literal">nil</span>;</div><div class="line">    _cacheXML = <span class="literal">nil</span>;</div><div class="line">    _cacheJSON = <span class="literal">nil</span>;</div><div class="line">    _cacheString = <span class="literal">nil</span>;</div><div class="line">    _cacheMetadata = <span class="literal">nil</span>;</div><div class="line">    _dataFromCache = <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，首先清除了关于缓存的所有数据，然后调用父类的<code>start</code>方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m:</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 告诉Accessories即将回调了（其实是即将发起请求）</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步里的Accessories是一些遵从<ytkrequestaccessory>代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里：</ytkrequestaccessory></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来跟踪请求的状态的代理。</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YTKRequestAccessory</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to start.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStart:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to stop. This method is called</span></div><div class="line"><span class="comment">///  before executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request has already stoped. This method is called</span></div><div class="line"><span class="comment">///  after executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestDidStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。</p>
<p>接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task</span></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户自定义的requestURL</span></div><div class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//响应的统一处理</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//序列化失败，则认定为请求失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSAssert</span>(request.requestTask != <span class="literal">nil</span>, <span class="string">@"requestTask should not be nil"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Retain request</span></div><div class="line">    YTKLog(<span class="string">@"Add request: %@"</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</div><div class="line">    </div><div class="line">    <span class="comment">//2. 将request放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line">    </div><div class="line">    <span class="comment">//3. 开始task</span></div><div class="line">    [request.requestTask resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法挺长的，但是请不要被吓到，它总共分为三个部分：</p>
<ul>
<li>第一部分是获取当前请求对应的task并赋给request的<code>requestTask</code>属性（以后提到的request，都为用户自定义的当前请求类的实例）。</li>
<li>第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。</li>
<li>第三部分是启动task。</li>
</ul>
<p>下面我来依次讲解每个部分：</p>
<p><strong>第一部分：获取当前请求对应的task并赋给request</strong>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//统一处理请求响应</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里判断了用户是否自定义了request：</p>
<ol>
<li>如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。</li>
<li>如果不是，则调用YTKRequest自己的生成task的方法。</li>
</ol>
<p>第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，<code>sessionTaskForRequest: error :</code>方法内部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//根据不同请求类型，序列化类型，和请求参数来返回NSURLSessionTask</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获得请求类型（GET，POST等）</span></div><div class="line">    YTKRequestMethod method = [request requestMethod];</div><div class="line"></div><div class="line">    <span class="comment">//2. 获得请求url</span></div><div class="line">    <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line"></div><div class="line">    <span class="comment">//3. 获得请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line">    </div><div class="line">    <span class="comment">//4. 获得request serializer</span></div><div class="line">    AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据不同的请求类型来返回对应的task</span></div><div class="line">    <span class="keyword">switch</span> (method) &#123;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodGET:</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</div><div class="line">                <span class="comment">//下载任务</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath requestSerializer:requestSerializer URLString:url parameters:param progress:request.resumableDownloadProgressBlock error:error];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//普通get请求</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPOST:</div><div class="line">            <span class="comment">//POST请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodHEAD:</div><div class="line">            <span class="comment">//HEAD请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"HEAD"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPUT:</div><div class="line">            <span class="comment">//PUT请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PUT"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodDELETE:</div><div class="line">            <span class="comment">//DELETE请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"DELETE"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPATCH:</div><div class="line">            <span class="comment">//PATCH请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PATCH"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法：</p>
<ol>
<li>获得请求类型（GET，POST等）：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  YTKRequestMethod method = [request requestMethod];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>requestMethod</code>方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。</p>
<p>它的枚举类型在YTKBaseRequest.h里面定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.h</span></div><div class="line"><span class="comment">///  HTTP Request method.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestMethod) &#123;</div><div class="line">    YTKRequestMethodGET = <span class="number">0</span>,</div><div class="line">    YTKRequestMethodPOST,</div><div class="line">    YTKRequestMethodHEAD,</div><div class="line">    YTKRequestMethodPUT,</div><div class="line">    YTKRequestMethodDELETE,</div><div class="line">    YTKRequestMethodPATCH,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用户可以根据实际的需求在自定义request类里面重写这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterAPI.m</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.获得请求url：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//返回当前请求url</span></div><div class="line">- (<span class="built_in">NSString</span> *)buildRequestUrl:(YTKBaseRequest *)request &#123;</div><div class="line">   </div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="comment">//用户自定义的url（不包括在YTKConfig里面设置的base_url）</span></div><div class="line">    <span class="built_in">NSString</span> *detailUrl = [request requestUrl];</div><div class="line">    <span class="built_in">NSURL</span> *temp = [<span class="built_in">NSURL</span> URLWithString:detailUrl];</div><div class="line">    </div><div class="line">    <span class="comment">// 存在host和scheme的url立即返回正确</span></div><div class="line">    <span class="keyword">if</span> (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</div><div class="line">        <span class="keyword">return</span> detailUrl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果需要过滤url，则过滤</span></div><div class="line">    <span class="built_in">NSArray</span> *filters = [_config urlFilters];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *baseUrl;</div><div class="line">    <span class="keyword">if</span> ([request useCDN]) &#123;</div><div class="line">        <span class="comment">//如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN</span></div><div class="line">        <span class="keyword">if</span> ([request cdnUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request cdnUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config cdnUrl];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl</span></div><div class="line">        <span class="keyword">if</span> ([request baseUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request baseUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config baseUrl];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果末尾没有/，则在末尾添加一个／</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:baseUrl];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (baseUrl.length &gt; <span class="number">0</span> &amp;&amp; ![baseUrl hasSuffix:<span class="string">@"/"</span>]) &#123;</div><div class="line">        url = [url URLByAppendingPathComponent:<span class="string">@""</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:detailUrl relativeToURL:url].absoluteString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.获得请求参数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">      <span class="comment">//获取用户提供的请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户提供的构造请求体的block（默认是没有的）</span></div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterApi.m</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.获得request serializer</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   <span class="comment">//4. 获得request serializer</span></div><div class="line">   AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    AFHTTPRequestSerializer *requestSerializer = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//HTTP or JSON</span></div><div class="line">    <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123;</div><div class="line">        requestSerializer = [AFHTTPRequestSerializer serializer];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123;</div><div class="line">        requestSerializer = [AFJSONRequestSerializer serializer];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//超时时间</span></div><div class="line">    requestSerializer.timeoutInterval = [request requestTimeoutInterval];</div><div class="line">    </div><div class="line">    <span class="comment">//是否允许数据服务</span></div><div class="line">    requestSerializer.allowsCellularAccess = [request allowsCellularAccess];</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要验证</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray];</div><div class="line">    <span class="keyword">if</span> (authorizationHeaderFieldArray != <span class="literal">nil</span>) &#123;</div><div class="line">        [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject</div><div class="line">                                                          password:authorizationHeaderFieldArray.lastObject];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要自定义 HTTPHeaderField</span></div><div class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary];</div><div class="line">    <span class="keyword">if</span> (headerFieldValueDictionary != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *httpHeaderField <span class="keyword">in</span> headerFieldValueDictionary.allKeys) &#123;</div><div class="line">            <span class="built_in">NSString</span> *value = headerFieldValueDictionary[httpHeaderField];</div><div class="line">            [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> requestSerializer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。</p>
<p>到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:<span class="literal">nil</span> error:error];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终返回NSURLSessionDataTask实例</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//根据有无构造请求体的block的情况来获取request</span></div><div class="line">    <span class="keyword">if</span> (block) &#123;</div><div class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获得request以后来获取dataTask</span></div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    dataTask = [_manager dataTaskWithRequest:request</div><div class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</div><div class="line">                               <span class="comment">//响应的统一处理</span></div><div class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</div><div class="line">                           &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。</p>
<p>OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在<code>addRequest：</code>方法里接下来做的是对序列化失败的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//序列化失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。</p>
<p>继续往下走，到了优先级的映射部分：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestPriority) &#123;</div><div class="line">    YTKRequestPriorityLow = <span class="number">-4</span>L,</div><div class="line">    YTKRequestPriorityDefault = <span class="number">0</span>,</div><div class="line">    YTKRequestPriorityHigh = <span class="number">4</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。</p>
<p>到这里，我们拿到了task的实例并设置好了优先级，紧接着就是<code>addRequest:</code>方法里的第二个部分：<br>YTKNetworkAgent将request实例放在了一个字典中，保存起来：</p>
<p><strong>第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//将request实例放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">  [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addRequestToRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    _requestsRecord[@(request.requestTask.taskIdentifier)] = request;</div><div class="line">    Unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#define Lock() pthread_mutex_lock(&amp;_lock)</span></div><div class="line"><span class="meta">#define Unlock() pthread_mutex_unlock(&amp;_lock)</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。</p>
</blockquote>
<p>在当前的request被保存以后，就到了最后一步，正式发起请求：</p>
<p><strong>第三部分：启动task</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   [request.requestTask resume];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。</p>
<p>那么接下来我们看一下YTKNetwork是如何处理请求的回调的。</p>
<p>眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：<code>handleRequestResult:responseObject:error:</code>。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//统一处理请求结果，包括成功和失败的情况</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task对应的request</span></div><div class="line">    Lock();</div><div class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</div><div class="line">    Unlock();</div><div class="line"></div><div class="line">    <span class="comment">//如果不存在对应的request，则立即返回</span></div><div class="line">    <span class="keyword">if</span> (!request) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    。。。</div><div class="line"></div><div class="line">    <span class="comment">//2. 获取request对应的response</span></div><div class="line">    request.responseObject = responseObject;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 获取responseObject，responseData和responseString</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        </div><div class="line">       <span class="comment">//3.1 获取 responseData</span></div><div class="line">        request.responseData = responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//3.2 获取responseString</span></div><div class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">         <span class="comment">//3.3 获取responseObject（或responseJSONObject）</span></div><div class="line">        <span class="comment">//根据返回的响应的序列化的类型来得到对应类型的响应</span></div><div class="line">        <span class="keyword">switch</span> (request.responseSerializerType)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Default serializer. Do nothing.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                request.responseJSONObject = request.responseObject;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调</span></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="comment">//如果该方法传入的error不为nil</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = error;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        <span class="comment">//如果序列化失败了</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = serializationError;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//即使没有error而且序列化通过，也要验证request是否有效</span></div><div class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</div><div class="line">        requestError = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单讲解一下上面的代码：</p>
<ul>
<li>首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。</li>
<li>然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。</li>
<li>再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。</li>
<li>最后根据succeed的值来进行成功和失败的回调。</li>
</ul>
<p>这里先重点介绍一下是如何判断json的有效性的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//判断code是否符合范围和json的有效性</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateResult:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 判断code是否在200~299之间</span></div><div class="line">    <span class="built_in">BOOL</span> result = [request statusCodeValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!result) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid status code"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//2. result 存在的情况判断json是否有效</span></div><div class="line">    <span class="keyword">id</span> json = [request responseJSONObject];</div><div class="line">    <span class="keyword">id</span> validator = [request jsonValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (json &amp;&amp; validator) &#123;</div><div class="line">        <span class="comment">//通过json和validator来判断json是否有效</span></div><div class="line">        result = [YTKNetworkUtils validateJSON:json withValidator:validator];</div><div class="line">        </div><div class="line">        <span class="comment">//如果json无效</span></div><div class="line">        <span class="keyword">if</span> (!result) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid JSON format"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，首先，用<code>statusCodeValidator</code>方法判断响应的code是否在正确的范围:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseReqiest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)statusCodeValidator &#123;</div><div class="line">    <span class="built_in">NSInteger</span> statusCode = [<span class="keyword">self</span> responseStatusCode];</div><div class="line">    <span class="keyword">return</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt;= <span class="number">299</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSInteger</span>)responseStatusCode &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.response.statusCode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再判断json的有效性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkUtils.m</span></div><div class="line"><span class="comment">//判断json的有效性</span></div><div class="line">+ (<span class="built_in">BOOL</span>)validateJSON:(<span class="keyword">id</span>)json withValidator:(<span class="keyword">id</span>)jsonValidator &#123;</div><div class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">        [jsonValidator isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSDictionary</span> * dict = json;</div><div class="line">        <span class="built_in">NSDictionary</span> * validator = jsonValidator;</div><div class="line">        <span class="built_in">BOOL</span> result = <span class="literal">YES</span>;</div><div class="line">        <span class="built_in">NSEnumerator</span> * enumerator = [validator keyEnumerator];</div><div class="line">        <span class="built_in">NSString</span> * key;</div><div class="line">        <span class="keyword">while</span> ((key = [enumerator nextObject]) != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">id</span> value = dict[key];</div><div class="line">            <span class="keyword">id</span> format = validator[key];</div><div class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]</div><div class="line">                || [value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                result = [<span class="keyword">self</span> validateJSON:value withValidator:format];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:format] == <span class="literal">NO</span> &amp;&amp;</div><div class="line">                    [value isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] == <span class="literal">NO</span>) &#123;</div><div class="line">                    result = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">               [jsonValidator isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSArray</span> * validatorArray = (<span class="built_in">NSArray</span> *)jsonValidator;</div><div class="line">        <span class="keyword">if</span> (validatorArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSArray</span> * array = json;</div><div class="line">            <span class="built_in">NSDictionary</span> * validator = jsonValidator[<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> array) &#123;</div><div class="line">                <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> validateJSON:item withValidator:validator];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:jsonValidator]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。</p>
<p>在验证返回的JSON数据是否有效以后，就可以进行回调了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先来分别看一下请求成功的处理和失败的处理：</p>
<p>请求成功的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block</span></div><div class="line">- (<span class="keyword">void</span>)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//写入缓存 </span></div><div class="line">        [request requestCompletePreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理,用户自定义</span></div><div class="line">        [request requestCompleteFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，则调用成功的代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFinished:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了成功回调的代码，则调用</span></div><div class="line">        <span class="keyword">if</span> (request.successCompletionBlock) &#123;</div><div class="line">            request.successCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经结束了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下<code>requestCompletePreprocessor</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//写入缓存文件</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">//写入缓存文件</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存文件</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// 1. 保存request的responseData到cacheFilePath</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 2. 保存request的metadata到cacheMetadataFilePath</span></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先看一下写入缓存操作的执行条件：当<code>cacheTimeInSeconds</code>方法返回大于0并且<code>isDataFromCache</code>为NO的时候会进行写入缓存。</p>
<p><code>cacheTimeInSeconds</code>方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。</p>
<p><code>isDataFromCache</code>属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：<code>isDataFromCache</code>的默认值是NO。在请求发起之前，-<br>查询缓存的时候：</p>
<ul>
<li>如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。</li>
<li>如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。</li>
</ul>
<p>即是说，如果发送了请求，则<code>isDataFromCache</code>一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。</p>
<p>因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。</p>
<p>我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：<br>第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种：</p>
<ol>
<li>缓存的版本，默认返回为0，用户可以自定义。</li>
<li>敏感数据，类型为id，默认返回nil，用户可以自定义。</li>
<li>NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
<li>元数据的创建时间。</li>
<li>app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
</ol>
<p>在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过<code>cacheMetadataFilePath</code>方法获取。</p>
<p>现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="comment">//纯NSData数据缓存的文件名</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</div><div class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</div><div class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</div><div class="line">    <span class="keyword">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</div><div class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Method:%ld Host:%@ Url:%@ Argument:%@"</span>,</div><div class="line">                             (<span class="keyword">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</div><div class="line">    <span class="keyword">return</span> cacheFileName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//纯NSData数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [<span class="keyword">self</span> cacheFileName];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//元数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.metadata"</span>, [<span class="keyword">self</span> cacheFileName]];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建用户保存所有YTKNetwork缓存的文件夹</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//获取全路径</span></div><div class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@"LazyRequestCache"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</div><div class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//创建文件夹</span></div><div class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。</p>
<p>而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。</p>
<p>为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存和缓存元数据的文件"></p>
<p>而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。</p>
<p>OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line"></div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">        strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用<code>clearCompletionBlock</code>方法将block清空。该方法的实现是在YTKBaseRequest里：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求失败</span></div><div class="line">- (<span class="keyword">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    request.error = error;</div><div class="line">    YTKLog(<span class="string">@"Request %@ failed, status code = %ld, error = %@"</span>,</div><div class="line">           <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]), (<span class="keyword">long</span>)request.responseStatusCode, error.localizedDescription);</div><div class="line"></div><div class="line">    <span class="comment">// 储存未完成的下载数据</span></div><div class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</div><div class="line">    <span class="keyword">if</span> (incompleteDownloadData) &#123;</div><div class="line">        [incompleteDownloadData writeToURL:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Load response from file and clean up if download task failed.</span></div><div class="line">    <span class="comment">//如果下载任务失败，则取出对应的响应文件并清空</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = request.responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件</span></div><div class="line">        <span class="keyword">if</span> (url.isFileURL &amp;&amp; [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:url.path]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//将url的data和string赋给request</span></div><div class="line">            request.responseData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">            request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:url error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空request</span></div><div class="line">        request.responseObject = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//请求失败的预处理，YTK没有定义，需要用户定义</span></div><div class="line">        [request requestFailedPreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理</span></div><div class="line">        [request requestFailedFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，就调用代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFailed:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了失败回调的block代码，就调用block</span></div><div class="line">        <span class="keyword">if</span> (request.failureCompletionBlock) &#123;</div><div class="line">            request.failureCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经停止了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到<code>resumableDownloadPath</code>里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。</p>
<p>到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKNetwork流程图"></p>
<p>我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.h</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request;</div><div class="line"></div><div class="line"><span class="comment">///  取消所有添加的request</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests;</div></pre></td></tr></table></figure></p>
<p>首先我们看下取消某个request这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line">    <span class="comment">//获取request的task，并取消</span></div><div class="line">    [request.requestTask cancel];</div><div class="line">    <span class="comment">//从字典里移除当前request</span></div><div class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">    <span class="comment">//清理所有block</span></div><div class="line">    [request clearCompletionBlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从字典里移除某request</span></div><div class="line">- (<span class="keyword">void</span>)removeRequestFromRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)];</div><div class="line">    YTKLog(<span class="string">@"Request queue size = %zd"</span>, [_requestsRecord count]);</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取消所有在字典里添加的request：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests &#123;</div><div class="line">    Lock();</div><div class="line">    <span class="built_in">NSArray</span> *allKeys = [_requestsRecord allKeys];</div><div class="line">    Unlock();</div><div class="line">    <span class="keyword">if</span> (allKeys &amp;&amp; allKeys.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *copiedKeys = [allKeys <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *key <span class="keyword">in</span> copiedKeys) &#123;</div><div class="line">            Lock();</div><div class="line">            YTKBaseRequest *request = _requestsRecord[key];</div><div class="line">            Unlock();</div><div class="line">            <span class="comment">//stop每个请求</span></div><div class="line">            [request stop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个stop方法是在YTKBaseRequest里面定义的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories将要回调了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//清空代理</span></div><div class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//调用agent的取消某个request的方法</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories回调完成了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。</p>
<h2 id="3-3-批量请求和链式请求"><a href="#3-3-批量请求和链式请求" class="headerlink" title="3.3 批量请求和链式请求"></a>3.3 批量请求和链式请求</h2><p>YTKNetwork支持的批量请求有两种：</p>
<ol>
<li>批量请求：多个请求几乎同时发起。</li>
<li>链式请求：当前个请求结束后才能发起下一个请求。</li>
</ol>
<p>其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？</p>
<p>我们首先来看一下YTKNetwork是如何实现批量请求的。</p>
<h3 id="3-31批量请求"><a href="#3-31批量请求" class="headerlink" title="3.31批量请求"></a>3.31批量请求</h3><p>YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的<code>_requestArray</code>实例变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithRequestArray:(<span class="built_in">NSArray</span>&lt;YTKRequest *&gt; *)requestArray &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//保存为属性</span></div><div class="line">        _requestArray = [requestArray <span class="keyword">copy</span>];</div><div class="line"></div><div class="line">        <span class="comment">//批量请求完成的数量初始化为0</span></div><div class="line">        _finishedCount = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败</span></div><div class="line">        <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">            <span class="keyword">if</span> (![req isKindOfClass:[YTKRequest <span class="keyword">class</span>]]) &#123;</div><div class="line">                YTKLog(<span class="string">@"Error, request item must be YTKRequest instance."</span>);</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化以后，我们就可以调用<code>start</code>方法来发起当前YTKBatchRequest实例所管理的所有请求了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="comment">//batch请求开始</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                                    failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                              failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果batch里第一个请求已经成功结束，则不能再start</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Batch request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//最开始设定失败的request为nil</span></div><div class="line">    _failedRequest = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//使用YTKBatchRequestAgent来管理当前的批量请求</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:<span class="keyword">self</span>];</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//遍历所有request，并开始请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        req.delegate = <span class="keyword">self</span>;</div><div class="line">        [req clearCompletionBlock];</div><div class="line">        [req start];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们可以看出：<br>1.在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的<code>start</code>方法会立即返回，否则可以无限制start。<br>2.YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequestAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addBatchRequest:(YTKBatchRequest *)request &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        [_requestArray addObject:request];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的<code>_requestArray</code>并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。</p>
<p>发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。</p>
<p>YTKRequest子类成功的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="meta">#pragma mark - Network Request Delegate</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//某个request成功后，首先让_finishedCount + 1</span></div><div class="line">    _finishedCount++;</div><div class="line">    </div><div class="line">    <span class="comment">//如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount == _requestArray.count) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//调用即将结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求成功的代理</span></div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFinished:)]) &#123;</div><div class="line">            [_delegate batchRequestFinished:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//调用批量请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (_successCompletionBlock) &#123;</div><div class="line">            _successCompletionBlock(<span class="keyword">self</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空成功和失败的block</span></div><div class="line">        [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">        [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。</p>
<p>接下来我们看一下某个请求失败的处理：</p>
<p>YTKReques子类失败的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    _failedRequest = request;</div><div class="line">    </div><div class="line">    <span class="comment">//调用即将结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//停止batch里所有的请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest *req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        [req stop];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的代理</span></div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFailed:)]) &#123;</div><div class="line">        [_delegate batchRequestFailed:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的block</span></div><div class="line">    <span class="keyword">if</span> (_failureCompletionBlock) &#123;</div><div class="line">        _failureCompletionBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//清空成功和失败的block</span></div><div class="line">    [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line"></div><div class="line">    <span class="comment">//调用请求结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。<br>而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。</p>
<p>总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。</p>
<p>现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。</p>
<h3 id="3-32链式请求"><a href="#3-32链式请求" class="headerlink" title="3.32链式请求"></a>3.32链式请求</h3><p>和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。</p>
<p>但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//下一个请求的index</span></div><div class="line">        _nextRequestIndex = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//保存链式请求的数组</span></div><div class="line">        _requestArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//保存回调的数组</span></div><div class="line">        _requestCallbackArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//空回调，用来填充用户没有定义的回调block</span></div><div class="line">        _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123;</div><div class="line">            <span class="comment">// do nothing</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是它提供了添加和删除request的接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//在当前chain添加request和callback</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//保存当前请求</span></div><div class="line">    [_requestArray addObject:request];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (callback != <span class="literal">nil</span>) &#123;</div><div class="line">        [_requestCallbackArray addObject:callback];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称</span></div><div class="line">        [_requestCallbackArray addObject:_emptyCallback];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。</p>
<p>我们接着看一下链式请求的发起：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="comment">//如果第1个请求已经结束，就不再重复start了</span></div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果请求队列数组里面还有request，则取出并start</span></div><div class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">        <span class="comment">//取出当前request并start</span></div><div class="line">        [<span class="keyword">self</span> startNextRequest];</div><div class="line">        <span class="comment">//在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain）</span></div><div class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request array is empty."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，YTKChainRequest用<code>_nextRequestIndex</code>来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。</p>
<p>这里<code>startNextRequest</code>方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)startNextRequest &#123;</div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</div><div class="line">        _nextRequestIndex++;</div><div class="line">        request.delegate = <span class="keyword">self</span>;</div><div class="line">        [request clearCompletionBlock];</div><div class="line">        [request start];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法有两个作用：</p>
<ol>
<li>第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界）</li>
<li>第二个作用是如果可以进行下一个request，则发起该request。并将<code>_nextRequestIndex</code>+1。</li>
</ol>
<p>所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。</p>
<p>现在我们知道了YTKChainRequest的发送，接下来看一下回调部分:</p>
<p>和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//某个request请求成功的代理的实现</span></div><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 取出当前的request和callback，进行回调</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</div><div class="line">    callback(<span class="keyword">self</span>, request);<span class="comment">//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面</span></div><div class="line">    </div><div class="line">    <span class="comment">//2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</div><div class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</div><div class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用<code>startNextRequest</code>方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了：</p>
<ul>
<li>如果没有了，则调用当前YTKChainRequest的最终成功的回调。</li>
<li>如果还有，则发起接下来的request（按顺序）。</li>
</ul>
<p>接下来我们再看一下某个request失败的代理的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//某个reqeust请求失败的代理</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFailed:failedBaseRequest:)]) &#123;</div><div class="line">        [_delegate chainRequestFailed:<span class="keyword">self</span> failedBaseRequest:request];</div><div class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。</p>
<p>现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//终止当前的chain</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line"></div><div class="line">    <span class="comment">//首先调用即将停止的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//然后stop当前的请求，再清空chain里所有的请求和回掉block</span></div><div class="line">    [<span class="keyword">self</span> clearRequest];</div><div class="line"></div><div class="line">    <span class="comment">//在YTKChainRequestAgent里移除当前的chain</span></div><div class="line">    [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line"></div><div class="line">    <span class="comment">//最后调用已经结束的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>stop</code>方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用<code>clearReuqest</code>方法，将当前request停止，再将请求队列数组和callback数组清空。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearRequest &#123;</div><div class="line">    <span class="comment">//获取当前请求的index</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (currentRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[currentRequestIndex];</div><div class="line">        [request stop];</div><div class="line">    &#125;</div><div class="line">    [_requestArray removeAllObjects];</div><div class="line">    [_requestCallbackArray removeAllObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在YTKChainRequestAgent单例里面，将自己移除掉。</p>
<h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4. 最后的话"></a>4. 最后的话</h1><hr>
<p>不知不觉写了好多，请原谅我一如既往啰嗦的风格~</p>
<p>阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。</p>
<p>我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。</p>
<p>所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。</p>
<p>希望这篇文章能对读者们有所帮助~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于iOS开发来说，就算是没有用过&lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot;&gt;YTKNetwork框架&lt;/a&gt;，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。&lt;/p&gt;
&lt;p&gt;在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。&lt;/p&gt;
&lt;h1 id=&quot;1-架构&quot;&gt;&lt;a href=&quot;#1-架构&quot; class=&quot;headerlink&quot; title=&quot;1. 架构&quot;&gt;&lt;/a&gt;1. 架构&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;先上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;YTKRequest架构图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这里简单说明一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 &lt;/li&gt;
&lt;li&gt;YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。&lt;/li&gt;
&lt;li&gt;我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。&lt;/li&gt;
&lt;li&gt;YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代码规范</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/06/14/iOS%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/06/14/iOS 代码规范/</id>
    <published>2017-06-14T05:11:18.000Z</published>
    <updated>2017-06-14T05:24:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-a9d78ce3d5e7114f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配图来自：nipic.com"></p>
<p>利用上周的业余时间把这篇规范整理了出来，我会将这篇规范作为我们iOS团队的代码规范，并且还会根据读者的反馈，项目的实践和研究的深入做不定时更新，还希望各位朋友看了多多指正和批评。</p>
<p>这篇规范一共分为三个部分：</p>
<ol>
<li>核心原则：介绍了这篇代码规范所遵循的核心原则。</li>
<li>通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。</li>
<li>iOS规范：仅适用于iOS的代码规范（使用Objective-C语言）。</li>
</ol>
<a id="more"></a>
<h1 id="一-核心原则"><a href="#一-核心原则" class="headerlink" title="一. 核心原则"></a>一. 核心原则</h1><h2 id="原则一：代码应该简洁易懂，逻辑清晰"><a href="#原则一：代码应该简洁易懂，逻辑清晰" class="headerlink" title="原则一：代码应该简洁易懂，逻辑清晰"></a>原则一：代码应该简洁易懂，逻辑清晰</h2><p>因为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机：</p>
<ul>
<li>不要过分追求技巧，降低程序的可读性。</li>
<li>简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。</li>
</ul>
<h2 id="原则二：面向变化编程，而不是面向需求编程。"><a href="#原则二：面向变化编程，而不是面向需求编程。" class="headerlink" title="原则二：面向变化编程，而不是面向需求编程。"></a>原则二：面向变化编程，而不是面向需求编程。</h2><p>需求是暂时的，只有变化才是永恒的。<br>本次迭代不能仅仅为了当前的需求，写出扩展性强，易修改的程序才是负责任的做法，对自己负责，对公司负责。</p>
<h2 id="原则三：先保证程序的正确性，防止过度工程"><a href="#原则三：先保证程序的正确性，防止过度工程" class="headerlink" title="原则三：先保证程序的正确性，防止过度工程"></a>原则三：先保证程序的正确性，防止过度工程</h2><p>过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑扩展，重用的问题，使得工程过度复杂。<br>引用《<a href="http://www.jianshu.com/p/7645a5ea7f46" target="_blank" rel="external">王垠：编程的智慧</a>》里的话：</p>
<blockquote>
<ol>
<li>先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。</li>
<li>先写出可用的代码，反复推敲，再考虑是否需要重用的问题。</li>
<li>先写出可用，简单，明显没有bug的代码，再考虑测试的问题。</li>
</ol>
</blockquote>
<h1 id="二-通用规范"><a href="#二-通用规范" class="headerlink" title="二. 通用规范"></a>二. 通用规范</h1><h2 id="关于大括号"><a href="#关于大括号" class="headerlink" title="关于大括号"></a>关于大括号</h2><hr>
<ul>
<li>控制语句(if,for,while,switch)中，大括号开始与行尾</li>
<li>函数中，大括号要开始于行首</li>
</ul>
<p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//控制语句</span></div><div class="line">white(someCondition)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数</span></div><div class="line"><span class="keyword">void</span> function(param1,param2)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr>
<h3 id="1-运算符与变量之间的间隔"><a href="#1-运算符与变量之间的间隔" class="headerlink" title="1. 运算符与变量之间的间隔"></a>1. 运算符与变量之间的间隔</h3><h4 id="1-1-一元运算符与变量之间没有空格："><a href="#1-1-一元运算符与变量之间没有空格：" class="headerlink" title="1.1  一元运算符与变量之间没有空格："></a>1.1  一元运算符与变量之间没有空格：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!bValue</div><div class="line">~iValue</div><div class="line">++iCount</div><div class="line">*strSource</div><div class="line">&amp;fSum</div></pre></td></tr></table></figure>
<h4 id="1-2-二元运算符与变量之间必须有空格"><a href="#1-2-二元运算符与变量之间必须有空格" class="headerlink" title="1.2 二元运算符与变量之间必须有空格"></a>1.2 二元运算符与变量之间必须有空格</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fWidth = <span class="number">5</span> + <span class="number">5</span>;</div><div class="line">fLength = fWidth * <span class="number">2</span>;</div><div class="line">fHeight = fWidth + fLength;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div></pre></td></tr></table></figure>
<h3 id="2-多个不同的运算符同时存在时应该使用括号来明确优先级"><a href="#2-多个不同的运算符同时存在时应该使用括号来明确优先级" class="headerlink" title="2. 多个不同的运算符同时存在时应该使用括号来明确优先级"></a>2. 多个不同的运算符同时存在时应该使用括号来明确优先级</h3><p>在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。<br>因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。</p>
<p>来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4</p>
<p>这里的<code>&lt;&lt;</code>是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 1 <em> 3 - 4<br>但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 1 </em> 3 - 4)。<br>所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr>
<h3 id="1-一个变量有且只有一个功能，尽量不要把一个变量用作多种用途"><a href="#1-一个变量有且只有一个功能，尽量不要把一个变量用作多种用途" class="headerlink" title="1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途"></a>1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途</h3><h3 id="2-变量在使用前应初始化，防止未初始化的变量被引用"><a href="#2-变量在使用前应初始化，防止未初始化的变量被引用" class="headerlink" title="2. 变量在使用前应初始化，防止未初始化的变量被引用"></a>2. 变量在使用前应初始化，防止未初始化的变量被引用</h3><h3 id="3-局部变量应该尽量接近使用它的地方"><a href="#3-局部变量应该尽量接近使用它的地方" class="headerlink" title="3. 局部变量应该尽量接近使用它的地方"></a>3. 局部变量应该尽量接近使用它的地方</h3><p>推荐这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> index = ...;</div><div class="line">  <span class="comment">//Do something With index</span></div><div class="line"></div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = ...;</div><div class="line">  <span class="comment">//Do something With count</span></div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> index = ...;</div><div class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = ...;</div><div class="line">  <span class="comment">//Do something With index</span></div><div class="line"></div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="comment">//Do something With count</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><hr>
<h3 id="1-必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。"><a href="#1-必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。" class="headerlink" title="1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。"></a>1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。</h3><p>推荐这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hintStr;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &lt; <span class="number">3</span>) &#123;</div><div class="line">  hintStr = <span class="string">"Good"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  hintStr = <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hintStr;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &lt; <span class="number">3</span>) &#123;</div><div class="line"> hintStr = <span class="string">"Good"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-不要使用过多的分支，要善于使用return来提前返回错误的情况"><a href="#2-不要使用过多的分支，要善于使用return来提前返回错误的情况" class="headerlink" title="2. 不要使用过多的分支，要善于使用return来提前返回错误的情况"></a>2. 不要使用过多的分支，要善于使用return来提前返回错误的情况</h3><p>推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)someMethod &#123; </div><div class="line">  <span class="keyword">if</span> (!goodCondition) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)someMethod &#123; </div><div class="line">  <span class="keyword">if</span> (goodCondition) &#123;</div><div class="line">    <span class="comment">//Do something</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比较典型的例子我在JSONModel里遇到过：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>)err</div><div class="line">&#123;</div><div class="line">   <span class="comment">//方法1. 参数为nil</span></div><div class="line">   <span class="keyword">if</span> (!dict) &#123;</div><div class="line">     <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></div><div class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法3. 初始化</span></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//初始化失败</span></div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。</p>
</blockquote>
<h3 id="3-条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值"><a href="#3-条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值" class="headerlink" title="3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值"></a>3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let nameContainsSwift = sessionName.hasPrefix(<span class="string">"Swift"</span>)</div><div class="line">let isCurrentYear = sessionDateCompontents.year == <span class="number">2014</span></div><div class="line">let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear</div><div class="line"><span class="keyword">if</span> (isSwiftSession) &#123; </div><div class="line">   <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( sessionName.hasPrefix(<span class="string">"Swift"</span>) &amp;&amp; (sessionDateCompontents.year == <span class="number">2014</span>) ) &#123; </div><div class="line">    <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-条件语句的判断应该是变量在左，常量在右"><a href="#4-条件语句的判断应该是变量在左，常量在右" class="headerlink" title="4. 条件语句的判断应该是变量在左，常量在右"></a>4. 条件语句的判断应该是变量在左，常量在右</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( count == <span class="number">6</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( object == <span class="literal">nil</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !object ) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="number">6</span> == count) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="literal">nil</span> == object ) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-每个分支的实现代码都必须被大括号包围"><a href="#5-每个分支的实现代码都必须被大括号包围" class="headerlink" title="5. 每个分支的实现代码都必须被大括号包围"></a>5. 每个分支的实现代码都必须被大括号包围</h3><p>推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error) &#123;</div><div class="line">  <span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error)</div><div class="line">    <span class="keyword">return</span> success;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error) <span class="keyword">return</span> success;</div></pre></td></tr></table></figure>
<h3 id="6-条件过多，过长的时候应该换行"><a href="#6-条件过多，过长的时候应该换行" class="headerlink" title="6. 条件过多，过长的时候应该换行"></a>6. 条件过多，过长的时候应该换行</h3><p>推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition1() &amp;&amp; </div><div class="line">    condition2() &amp;&amp; </div><div class="line">    condition3() &amp;&amp; </div><div class="line">    condition4()) &#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><hr>
<h3 id="1-不可在for循环内修改循环变量，防止for循环失去控制。"><a href="#1-不可在for循环内修改循环变量，防止for循环失去控制。" class="headerlink" title="1. 不可在for循环内修改循环变量，防止for循环失去控制。"></a>1. 不可在for循环内修改循环变量，防止for循环失去控制。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)&#123;</div><div class="line">   ...</div><div class="line">   logicToChange(index)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-避免使用continue和break。"><a href="#2-避免使用continue和break。" class="headerlink" title="2. 避免使用continue和break。"></a>2. 避免使用continue和break。</h3><p>continue和break所描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。</p>
<p>其实最好不要让这两个东西出现，因为我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的：</p>
<h4 id="2-1-如果出现了continue，只需要把continue的条件取反即可"><a href="#2-1-如果出现了continue，只需要把continue的条件取反即可" class="headerlink" title="2.1 如果出现了continue，只需要把continue的条件取反即可"></a>2.1 如果出现了continue，只需要把continue的条件取反即可</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filteredProducts = <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">    <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    &#125;</div><div class="line">    filteredProducts.append(level)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，通过判断字符串里是否含有“bad”这个prefix来过滤掉一些值。其实我们是可以通过取反，来避免使用continue的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">    <span class="keyword">if</span> !level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">      filteredProducts.append(level)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-2-消除while里的break：将break的条件取反，并合并到主循环里"><a href="#2-2-消除while里的break：将break的条件取反，并合并到主循环里" class="headerlink" title="2.2  消除while里的break：将break的条件取反，并合并到主循环里"></a>2.2  消除while里的break：将break的条件取反，并合并到主循环里</h4><p>在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以在最开始的条件语句中将其排除。</p>
<p>while里的break：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition1) &#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">if</span> (condition2) &#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>取反并合并到主条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition1 &amp;&amp; !condition2) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-在有返回值的方法里消除break：将break转换为return立即返回"><a href="#2-3-在有返回值的方法里消除break：将break转换为return立即返回" class="headerlink" title="2.3 在有返回值的方法里消除break：将break转换为return立即返回"></a>2.3 在有返回值的方法里消除break：将break转换为return立即返回</h4><p>有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasBadProductIn</span><span class="params">(products: Array&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = <span class="literal">false</span>    </div><div class="line">    <span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">        <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">            result = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遇到错误条件直接返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasBadProductIn</span><span class="params">(products: Array&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">        <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。</p>
<h2 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h2><hr>
<h3 id="1-每个分支都必须用大括号括起来"><a href="#1-每个分支都必须用大括号括起来" class="headerlink" title="1. 每个分支都必须用大括号括起来"></a>1. 每个分支都必须用大括号括起来</h3><p>推荐这样写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (integer) &#123;  </div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:  &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">   &#125;</div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">  <span class="keyword">case</span> <span class="number">2</span>: &#123;  </div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">case</span> <span class="number">3</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">default</span>:&#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-使用枚举类型时，不能有default分支，-除了使用枚举类型以外，都必须有default分支"><a href="#2-使用枚举类型时，不能有default分支，-除了使用枚举类型以外，都必须有default分支" class="headerlink" title="2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支"></a>2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="type">RWTLeftMenuTopItemType</span> menuType = <span class="type">RWTLeftMenuTopItemMain</span>;  </div><div class="line"><span class="keyword">switch</span> (menuType) &#123;  </div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemMain</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">   &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemShows</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemSchedule</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><hr>
<h3 id="1-一个函数的长度必须限制在50行以内"><a href="#1-一个函数的长度必须限制在50行以内" class="headerlink" title="1. 一个函数的长度必须限制在50行以内"></a>1. 一个函数的长度必须限制在50行以内</h3><p>通常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。</p>
<h3 id="2-一个函数只做一件事（单一原则）"><a href="#2-一个函数只做一件事（单一原则）" class="headerlink" title="2. 一个函数只做一件事（单一原则）"></a>2. 一个函数只做一件事（单一原则）</h3><p>每个函数的职责都应该划分的很明确（就像类一样）。</p>
<p>推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataConfiguration()</div><div class="line">viewConfiguration()</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dataConfiguration</span><span class="params">()</span></span></div><div class="line">&#123;   </div><div class="line">   ...</div><div class="line">   viewConfiguration()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-对于有返回值的函数（方法），每一个分支都必须有返回值"><a href="#3-对于有返回值的函数（方法），每一个分支都必须有返回值" class="headerlink" title="3. 对于有返回值的函数（方法），每一个分支都必须有返回值"></a>3. 对于有返回值的函数（方法），每一个分支都必须有返回值</h3><p>推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(condition1)&#123;</div><div class="line">        <span class="keyword">return</span> count1</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</div><div class="line">        <span class="keyword">return</span> count2</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">       <span class="keyword">return</span> defaultCount</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(condition1)&#123;</div><div class="line">        <span class="keyword">return</span> count1</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</div><div class="line">        <span class="keyword">return</span> count2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-对输入参数的正确性和有效性进行检查，参数错误立即返回"><a href="#4-对输入参数的正确性和有效性进行检查，参数错误立即返回" class="headerlink" title="4. 对输入参数的正确性和有效性进行检查，参数错误立即返回"></a>4. 对输入参数的正确性和有效性进行检查，参数错误立即返回</h3><p>推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(param1,param2)</span></span></div><div class="line">&#123;</div><div class="line">      <span class="keyword">if</span>(param1 is unavailable)&#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      <span class="keyword">if</span>(param2 is unavailable)&#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     <span class="comment">//Do some right thing</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数"><a href="#5-如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数" class="headerlink" title="5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数"></a>5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数</h3><p>原来的调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> logic() &#123;</div><div class="line">  a();</div><div class="line">  b()；</div><div class="line">  <span class="keyword">if</span> (logic1 condition) &#123;</div><div class="line">    c();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    d();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将a，b函数抽取出来作为单独的函数<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> basicConfig() &#123;</div><div class="line">  a();</div><div class="line">  b();</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">void</span> logic1() &#123;</div><div class="line">  basicConfig();</div><div class="line">  c();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> logic2() &#123;</div><div class="line">  basicConfig();</div><div class="line">  d();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="6-将函数内部比较复杂的逻辑提取出来作为单独的函数"><a href="#6-将函数内部比较复杂的逻辑提取出来作为单独的函数" class="headerlink" title="6. 将函数内部比较复杂的逻辑提取出来作为单独的函数"></a>6. 将函数内部比较复杂的逻辑提取出来作为单独的函数</h3><p>一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。</p>
<p>举一个发送邮件的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">openEmailSite();</div><div class="line">login();</div><div class="line"></div><div class="line">writeTitle(title);</div><div class="line">writeContent(content);</div><div class="line">writeReceiver(receiver);</div><div class="line">addAttachment(attachment);</div><div class="line"></div><div class="line">send();</div></pre></td></tr></table></figure></p>
<p>中间的部分稍微长一些，我们可以将它们提取出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeEmail</span><span class="params">(title, content,receiver,attachment)</span></span></div><div class="line">&#123;</div><div class="line">  writeTitle(title);</div><div class="line">  writeContent(content);</div><div class="line">  writeReceiver(receiver);</div><div class="line">  addAttachment(attachment); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再看一下原来的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">openEmailSite();</div><div class="line">login();</div><div class="line">writeEmail(title, content,receiver,attachment)</div><div class="line">send();</div></pre></td></tr></table></figure></p>
<h3 id="8-避免使用全局变量，类成员（class-member）来传递信息，尽量使用局部变量和参数。"><a href="#8-避免使用全局变量，类成员（class-member）来传递信息，尽量使用局部变量和参数。" class="headerlink" title="8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。"></a>8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。</h3><p>在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> x;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">updateX</span><span class="params">()</span></span> &#123;</div><div class="line">      ...</div><div class="line">      x = ...;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">printX</span><span class="params">()</span></span> &#123;</div><div class="line">     updateX();</div><div class="line">     <span class="built_in">print</span>(x);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。</p>
<p>而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func updateX() -&gt; String&#123;</div><div class="line">    x = ...;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> func printX() &#123;</div><div class="line">   String x = updateX();</div><div class="line">   print(x);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><hr>
<p>优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。</p>
<p>但并不是说一定不能写注释，有以下三种情况比较适合写注释：</p>
<ol>
<li>公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。</li>
<li>涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。</li>
<li>容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。</li>
</ol>
<p>除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。</p>
<p>最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。</p>
<h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><hr>
<p>换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。</p>
<p>而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。</p>
<h1 id="三-iOS规范"><a href="#三-iOS规范" class="headerlink" title="三. iOS规范"></a>三. iOS规范</h1><h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><hr>
<h3 id="1-变量名必须使用驼峰格式"><a href="#1-变量名必须使用驼峰格式" class="headerlink" title="1. 变量名必须使用驼峰格式"></a>1. 变量名必须使用驼峰格式</h3><p>类，协议使用大驼峰：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HomePageViewController.h</div><div class="line">&lt;HeaderViewDelegate&gt;</div></pre></td></tr></table></figure></p>
<p>对象等局部变量使用小驼峰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *personName = <span class="string">@""</span>;</div><div class="line"><span class="built_in">NSUInteger</span> totalCount = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<h3 id="2-变量的名称必须同时包含功能与类型"><a href="#2-变量的名称必须同时包含功能与类型" class="headerlink" title="2. 变量的名称必须同时包含功能与类型"></a>2. 变量的名称必须同时包含功能与类型</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *addBtn <span class="comment">//添加按钮</span></div><div class="line"><span class="built_in">UILabel</span> *nameLbl <span class="comment">//名字标签</span></div><div class="line"><span class="built_in">NSString</span> *addressStr<span class="comment">//地址字符串</span></div></pre></td></tr></table></figure>
<h3 id="3-系统常用类作实例变量声明时加入后缀"><a href="#3-系统常用类作实例变量声明时加入后缀" class="headerlink" title="3. 系统常用类作实例变量声明时加入后缀"></a>3. 系统常用类作实例变量声明时加入后缀</h3><table>
<thead>
<tr>
<th>类型</th>
<th>后缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIViewController</td>
<td>VC</td>
</tr>
<tr>
<td>UIView</td>
<td>View</td>
</tr>
<tr>
<td>UILabel</td>
<td>Lbl</td>
</tr>
<tr>
<td>UIButton</td>
<td>Btn</td>
</tr>
<tr>
<td>UIImage</td>
<td>Img</td>
</tr>
<tr>
<td>UIImageView</td>
<td>ImagView </td>
</tr>
<tr>
<td>NSArray</td>
<td>Array</td>
</tr>
<tr>
<td>NSMutableArray</td>
<td>Marray</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>Dict</td>
</tr>
<tr>
<td>NSMutableDictionary</td>
<td>Mdict</td>
</tr>
<tr>
<td>NSString</td>
<td>Str</td>
</tr>
<tr>
<td>NSMutableString</td>
<td>MStr</td>
</tr>
<tr>
<td>NSSet</td>
<td>Set</td>
</tr>
<tr>
<td>NSMutableSet</td>
<td>Mset</td>
</tr>
</tbody>
</table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><hr>
<h3 id="1-常量以相关类名作为前缀"><a href="#1-常量以相关类名作为前缀" class="headerlink" title="1. 常量以相关类名作为前缀"></a>1. 常量以相关类名作为前缀</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> ZOCSignInViewControllerFadeOutAnimationDuration = <span class="number">0.4</span>;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> fadeOutTime = <span class="number">0.4</span>;</div></pre></td></tr></table></figure>
<h3 id="2-建议使用类型常量，不建议使用-define预处理命令"><a href="#2-建议使用类型常量，不建议使用-define预处理命令" class="headerlink" title="2. 建议使用类型常量，不建议使用#define预处理命令"></a>2. 建议使用类型常量，不建议使用#define预处理命令</h3><p>首先比较一下这两种声明常量的区别：</p>
<ul>
<li>预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。</li>
<li>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。</li>
</ul>
<p>使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的：</p>
<ul>
<li>不具备类型信息。</li>
<li>可以被任意修改。</li>
</ul>
<h3 id="3-对外公开某个常量："><a href="#3-对外公开某个常量：" class="headerlink" title="3. 对外公开某个常量："></a>3. 对外公开某个常量：</h3><p>如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。</p>
<p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头文件</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ZOCCacheControllerDidClearCacheNotification;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现文件</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCCacheControllerDidClearCacheNotification = <span class="string">@"ZOCCacheControllerDidClearCacheNotification"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> ZOCImageThumbnailHeight = <span class="number">50.0</span>f;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CompanyName @<span class="meta-string">"Apple Inc."</span> </span></div><div class="line"><span class="meta">#define magicNumber 42</span></div></pre></td></tr></table></figure>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><hr>
<h3 id="1-宏、常量名都要使用大写字母，用下划线‘-’分割单词。"><a href="#1-宏、常量名都要使用大写字母，用下划线‘-’分割单词。" class="headerlink" title="1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。"></a>1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define URL_GAIN_QUOTE_LIST @<span class="meta-string">"/v1/quote/list"</span></span></div><div class="line"><span class="meta">#define URL_UPDATE_QUOTE_LIST @<span class="meta-string">"/v1/quote/update"</span></span></div><div class="line"><span class="meta">#define URL_LOGIN  @<span class="meta-string">"/v1/user/login”</span></span></div></pre></td></tr></table></figure>
<h3 id="2-宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。"><a href="#2-宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。" class="headerlink" title="2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。"></a>2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MY_MIN(A, B)  ((A)&gt;(B)?(B):(A))</span></div></pre></td></tr></table></figure>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><hr>
<p>其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用：</p>
<p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame; </div><div class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame); </div><div class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</div></pre></td></tr></table></figure></p>
<p>而不是<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;  </div><div class="line"><span class="built_in">CGFloat</span> x = frame.origin.x;  </div><div class="line"><span class="built_in">CGFloat</span> y = frame.origin.y;  </div><div class="line"><span class="built_in">CGFloat</span> width = frame.size.width;  </div><div class="line"><span class="built_in">CGFloat</span> height = frame.size.height;  </div><div class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; .origin = <span class="built_in">CGPointZero</span>, .size = frame.size &#125;;</div></pre></td></tr></table></figure></p>
<h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><hr>
<p>建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *testArr = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Hello"</span>, <span class="string">@"world"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSNumber</span> *&gt; *dic = @&#123;<span class="string">@"key"</span>:@(<span class="number">1</span>), <span class="string">@"age"</span>:@(<span class="number">10</span>)&#125;;</div></pre></td></tr></table></figure>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><hr>
<p>为常用的Block类型创建typedef</p>
<p>如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123;</div><div class="line">     // Implementation</div><div class="line">     return someInt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型：</p>
<figure class="highlight plain"><figcaption><span>int(^EOCSomeBlock)(BOOL flag, int value);```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">再次定义的时候，就可以通过简单的赋值来实现：</div></pre></td></tr></table></figure>
<p>EOCSomeBlock block = ^(BOOL flag, int value){<br>     // Implementation<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">定义作为参数的Block：</div></pre></td></tr></table></figure>
<ul>
<li>(void)startWithCompletionHandler: (void(^)(NSData <em>data, NSError </em>error))completion;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里的Block有一个NSData参数，一个NSError参数并没有返回值</div></pre></td></tr></table></figure>
<p>typedef void(^EOCCompletionHandler)(NSData <em>data, NSError </em>error);</p>
<ul>
<li>(void)startWithCompletionHandler:(EOCCompletionHandler)completion;”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。</div><div class="line"></div><div class="line"></div><div class="line">## 字面量语法</div><div class="line">---</div><div class="line"></div><div class="line">尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象：</div><div class="line"></div><div class="line">推荐这样写：</div><div class="line">```objc</div><div class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</div><div class="line">NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;; </div><div class="line">NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span> ];</div><div class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];<span class="built_in">NSNumber</span> *buildingZIPCode = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><hr>
<h3 id="1-属性的命名使用小驼峰"><a href="#1-属性的命名使用小驼峰" class="headerlink" title="1. 属性的命名使用小驼峰"></a>1. 属性的命名使用小驼峰</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *confirmButton;</div></pre></td></tr></table></figure>
<h3 id="2-属性的关键字推荐按照-原子性，读写，内存管理的顺序排列"><a href="#2-属性的关键字推荐按照-原子性，读写，内存管理的顺序排列" class="headerlink" title="2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列"></a>2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *headerView;</div></pre></td></tr></table></figure>
<h3 id="3-Block属性应该使用copy关键字"><a href="#3-Block属性应该使用copy关键字" class="headerlink" title="3. Block属性应该使用copy关键字"></a>3. Block属性应该使用copy关键字</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^ErrorCodeBlock) (<span class="keyword">id</span> errorCode,<span class="built_in">NSString</span> *message);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) ErrorCodeBlock errorBlock;<span class="comment">//将block拷贝到堆中</span></div></pre></td></tr></table></figure>
<h3 id="4-形容词性的BOOL属性的getter应该加上is前缀"><a href="#4-形容词性的BOOL属性的getter应该加上is前缀" class="headerlink" title="4. 形容词性的BOOL属性的getter应该加上is前缀"></a>4. 形容词性的BOOL属性的getter应该加上is前缀</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</div></pre></td></tr></table></figure>
<h3 id="5-使用getter方法做懒加载"><a href="#5-使用getter方法做懒加载" class="headerlink" title="5. 使用getter方法做懒加载"></a>5. 使用getter方法做懒加载</h3><p>实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123;</div><div class="line">    <span class="keyword">if</span> (!_dateFormatter) &#123;</div><div class="line">           _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">           <span class="built_in">NSLocale</span> *enUSPOSIXLocale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</div><div class="line">           [_dateFormatter setLocale:enUSPOSIXLocale];</div><div class="line">           [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd'T'HH:mm:ss.SSS"</span>];</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> _dateFormatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。</p>
<h3 id="6-除了init和dealloc方法，建议都使用点语法访问属性"><a href="#6-除了init和dealloc方法，建议都使用点语法访问属性" class="headerlink" title="6. 除了init和dealloc方法，建议都使用点语法访问属性"></a>6. 除了init和dealloc方法，建议都使用点语法访问属性</h3><p>使用点语法的好处：</p>
<h4 id="setter："><a href="#setter：" class="headerlink" title="setter："></a>setter：</h4><ol>
<li>setter会遵守内存管理语义(strong, copy, weak)。</li>
<li>通过在内部设置断点，有助于调试bug。</li>
<li>可以过滤一些外部传入的值。</li>
<li>捕捉KVO通知。</li>
</ol>
<h4 id="getter："><a href="#getter：" class="headerlink" title="getter："></a>getter：</h4><ol>
<li>允许子类化。</li>
<li>通过在内部设置断点，有助于调试bug。</li>
<li>实现懒加载（lazy initialization）。</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。</li>
<li>在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。</li>
</ol>
</blockquote>
<h3 id="7-不要滥用点语法，要区分好方法调用和属性访问"><a href="#7-不要滥用点语法，要区分好方法调用和属性访问" class="headerlink" title="7. 不要滥用点语法，要区分好方法调用和属性访问"></a>7. 不要滥用点语法，要区分好方法调用和属性访问</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor]; </div><div class="line">[<span class="built_in">UIApplication</span> sharedApplication].delegate;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]]; </div><div class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</div></pre></td></tr></table></figure>
<h3 id="8-尽量使用不可变对象"><a href="#8-尽量使用不可变对象" class="headerlink" title="8. 尽量使用不可变对象"></a>8. 尽量使用不可变对象</h3><p>建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是：</p>
<ul>
<li>在头文件中，设置对象属性为<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- 在实现文件中设置为```readwrite```。</div><div class="line"></div><div class="line">这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。</div><div class="line"></div><div class="line">如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如：</div><div class="line"></div><div class="line">在公共API中：</div></pre></td></tr></table></figure></li>
</ul>
<p>@interface EOCPerson : NSObject</p>
<p>@property (nonatomic, copy, readonly) NSString <em>firstName;<br>@property (nonatomic, copy, readonly) NSString </em>lastName;<br>@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合</p>
<ul>
<li>(id)initWithFirstName:(NSString<em>)firstName andLastName:(NSString</em>)lastName;</li>
<li>(void)addFriend:(EOCPerson*)person;</li>
<li>(void)removeFriend:(EOCPerson*)person;</li>
</ul>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。</div><div class="line"></div><div class="line">在实现文件里：</div></pre></td></tr></table></figure>
<p>@interface EOCPerson ()</p>
<p>@property (nonatomic, copy, readwrite) NSString <em>firstName;<br>@property (nonatomic, copy, readwrite) NSString </em>lastName;</p>
<p>@end</p>
<p>@implementation EOCPerson {<br>     NSMutableSet *_internalFriends;  //实现文件里的可变集合<br>}</p>
<ul>
<li><p>(NSSet*)friends {<br>   return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型<br>}</p>
</li>
<li><p>(void)addFriend:(EOCPerson*)person {<br>  [_internalFriends addObject:person]; //在外部增加集合元素的操作<br>  //do something when add element<br>}</p>
</li>
<li><p>(void)removeFriend:(EOCPerson*)person {<br>  [_internalFriends removeObject:person]; //在外部移除元素的操作<br>  //do something when remove element<br>}</p>
</li>
<li><p>(id)initWithFirstName:(NSString<em>)firstName andLastName:(NSString</em>)lastName {</p>
<p>   if ((self = [super init])) {</p>
<pre><code>_firstName = firstName;
_lastName = lastName;
_internalFriends = [NSMutableSet new];
</code></pre><p>  }<br>return self;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。</div><div class="line"></div><div class="line">这里最重要的代码是：</div></pre></td></tr></table></figure>
<ul>
<li>(NSSet*)friends {<br>return [_internalFriends copy];<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。</div><div class="line"></div><div class="line">## 方法</div><div class="line">----</div><div class="line"></div><div class="line">### 1. 方法名中不应使用and，而且签名要与对应的参数名保持高度一致</div><div class="line"></div><div class="line">推荐这样写：</div><div class="line"></div><div class="line">```objc</div><div class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width andHeight:(<span class="built_in">CGFloat</span>)height;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWith:(<span class="keyword">int</span>)width and:(<span class="keyword">int</span>)height;</div></pre></td></tr></table></figure>
<h3 id="2-方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。"><a href="#2-方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。" class="headerlink" title="2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。"></a>2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doSomethingWith:(<span class="built_in">NSString</span> *)theFoo</div><div class="line">                   rect:(<span class="built_in">CGRect</span>)theRect</div><div class="line">               interval:(<span class="built_in">CGFloat</span>)theInterval</div><div class="line">&#123;</div><div class="line">   <span class="comment">//Implementation</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-私有方法应该在实现文件中申明。"><a href="#3-私有方法应该在实现文件中申明。" class="headerlink" title="3. 私有方法应该在实现文件中申明。"></a>3. 私有方法应该在实现文件中申明。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">- (<span class="keyword">void</span>)basicConfiguration;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)basicConfiguration</div><div class="line">&#123;</div><div class="line">   <span class="comment">//Do some basic configuration</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="4-方法名用小写字母开头的单词组合而成"><a href="#4-方法名用小写字母开头的单词组合而成" class="headerlink" title="4. 方法名用小写字母开头的单词组合而成"></a>4. 方法名用小写字母开头的单词组合而成</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">id</span>)locale;</div></pre></td></tr></table></figure>
<h3 id="5-方法名前缀"><a href="#5-方法名前缀" class="headerlink" title="5. 方法名前缀"></a>5. 方法名前缀</h3><ul>
<li>刷新视图的方法名要以<code>refresh</code>为首。</li>
<li>更新数据的方法名要以<code>update</code>为首。</li>
</ul>
<p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)refreshHeaderViewWithCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line">- (<span class="keyword">void</span>)updateDataSourceWithViewModel:(ViewModel*)viewModel;</div></pre></td></tr></table></figure>
<h2 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h2><hr>
<p>如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。</p>
<p>因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子：</p>
<p>现在有一个需求：在一个<code>UITableViewController</code>里面拉取feed并展示出来。</p>
<h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p>定义一个拉取feed的类<code>ZOCFeedParser</code>，这个类有一些代理方法实现feed相关功能：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)feedParserDidStart:(ZOCFeedParser *)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; </div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item; </div><div class="line">- (<span class="keyword">void</span>)feedParserDidFinish:(ZOCFeedParser *)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didFailWithError:(<span class="built_in">NSError</span> *)error;<span class="keyword">@end</span> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCFeedParser</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;ZOCFeedParserDelegate&gt; delegate; </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url; </div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url; </div><div class="line">- (<span class="built_in">BOOL</span>)start; </div><div class="line">- (<span class="keyword">void</span>)stop; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>然后在<code>ZOCTableViewController</code>里面传入<code>ZOCFeedParser</code>，并遵循其代理方法，实现feed的拉取功能。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCTableViewController</span> : <span class="title">UITableViewController</span>&lt;<span class="title">ZOCFeedParserDelegate</span>&gt;</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFeedParser:(ZOCFeedParser *)feedParser; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>具体应用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *feedURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://bbc.co.uk/feed.rss"</span>]; </div><div class="line">ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL]; </div><div class="line">ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser]; </div><div class="line">feedParser.delegate = tableViewController;</div></pre></td></tr></table></figure>
<p>OK，现在我们实现了需求：在<code>ZOCTableViewController</code>里面存放了一个<code>ZOCFeedParser</code>对象来处理feed的拉取功能。</p>
<p>但这里有一个严重的耦合问题：<code>ZOCTableViewController</code>只能通过<code>ZOCFeedParser</code>对象来处理feed的拉取功能。<br>于是我们重新审视一下这个需求：其实我们实际上只需要<code>ZOCTableViewController</code>拉取feed就可以了，而具体是由哪个对象来拉取，<code>ZOCTableViewController</code>并不需要关心。</p>
<p>也就是说，我们需要提供给<code>ZOCTableViewController</code>的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（<code>ZOCFeedParser</code>）。所以，刚才的设计需要重新做一次修改：</p>
<h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>首先需要在一个接口文件<code>ZOCFeedParserProtocol.h</code>里面定义抽象的，具有拉取feed功能的协议：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)feedParserDidStart:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; </div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item; </div><div class="line">- (<span class="keyword">void</span>)feedParserDidFinish:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(<span class="built_in">NSError</span> *)error;<span class="keyword">@end</span> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;ZOCFeedParserDelegate&gt; delegate; </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)start;</div><div class="line">- (<span class="keyword">void</span>)stop;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>而原来的<code>ZOCFeedParser</code>仅仅是需要遵循上面这个协议就具备了拉取feed的功能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCFeedParser</span> : <span class="title">NSObject</span> &lt;<span class="title">ZOCFeedParserProtocol</span>&gt; </span></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url;<span class="comment">//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end</span></div></pre></td></tr></table></figure>
<p>而且，<code>ZOCTableViewController</code>也不直接依赖于<code>ZOCFeedParser</code>对象，我们只需要传给它一个遵循<code>&lt;ZOCFeedParserProtocol&gt;</code>的对象即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCTableViewController</span> : <span class="title">UITableViewController</span> &lt;<span class="title">ZOCFeedParserDelegate</span>&gt;</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFeedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)feedParser;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这样一来，<code>ZOCTableViewController</code>和<code>ZOCFeedParser</code>之间就没有直接的关系了。以后，如果我们想：</p>
<ul>
<li>给这个feed拉取器增加新的功能：仅需要修改<code>ZOCFeedParserProtocol.h</code>文件。</li>
<li>更换一个feed拉取器实例：创建一个新类型来遵循<code>ZOCFeedParserProtocol.h</code>即可。</li>
</ul>
<h2 id="iOS-中委托的设计"><a href="#iOS-中委托的设计" class="headerlink" title="iOS 中委托的设计"></a>iOS 中委托的设计</h2><hr>
<h3 id="1-要区分好代理和数据源的区别"><a href="#1-要区分好代理和数据源的区别" class="headerlink" title="1. 要区分好代理和数据源的区别"></a>1. 要区分好代理和数据源的区别</h3><p>在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：</p>
<ul>
<li>delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）</li>
<li>datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）</li>
</ul>
<p>然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div></pre></td></tr></table></figure></p>
<p>这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div></pre></td></tr></table></figure>
<p>该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。</p>
<p>在UITableViewDataSource中，就有标准的数据源方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView;</div></pre></td></tr></table></figure>
<p>这个方法的作用就是让tableview向控制器拉取一个section数量的数据。</p>
<p>所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。</p>
<h3 id="2-代理方法的第一个参数必须为委托者"><a href="#2-代理方法的第一个参数必须为委托者" class="headerlink" title="2. 代理方法的第一个参数必须为委托者"></a>2. 代理方法的第一个参数必须为委托者</h3><p>代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在``</p>
<ul>
<li>(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath``方法中做个区分。</li>
</ul>
<h3 id="向代理发送消息时需要判断其是否实现该方法"><a href="#向代理发送消息时需要判断其是否实现该方法" class="headerlink" title="向代理发送消息时需要判断其是否实现该方法"></a>向代理发送消息时需要判断其是否实现该方法</h3><p>最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(signUpViewControllerDidPressSignUpButton:)]) &#123; </div><div class="line"> [<span class="keyword">self</span>.delegate signUpViewControllerDidPressSignUpButton:<span class="keyword">self</span>]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-遵循代理过多的时候，换行对齐显示"><a href="#3-遵循代理过多的时候，换行对齐显示" class="headerlink" title="3. 遵循代理过多的时候，换行对齐显示"></a>3. 遵循代理过多的时候，换行对齐显示</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ShopViewController</span> () &lt;<span class="title">UIGestureRecognizerDelegate</span>,</span></div><div class="line">                                  HXSClickEventDelegate,</div><div class="line">                                  <span class="built_in">UITableViewDelegate</span>,</div><div class="line">                                  <span class="built_in">UITableViewDataSource</span>&gt;</div></pre></td></tr></table></figure>
<h3 id="4-代理的方法需要明确必须执行和可不执行"><a href="#4-代理的方法需要明确必须执行和可不执行" class="headerlink" title="4. 代理的方法需要明确必须执行和可不执行"></a>4. 代理的方法需要明确必须执行和可不执行</h3><p>代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用<code>@optional</code>关键字来修饰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCServiceDelegate</span> &lt;<span class="title">NSObject</span>&gt;@<span class="title">optional</span>- (<span class="title">void</span>)<span class="title">generalService</span>:(<span class="title">ZOCGeneralService</span> *)<span class="title">service</span> <span class="title">didRetrieveEntries</span>:(<span class="title">NSArray</span> *)<span class="title">entries</span>; </span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><hr>
<h3 id="1-类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间"><a href="#1-类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间" class="headerlink" title="1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间"></a>1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//父类</span></div><div class="line">ZOCSalesListViewController</div><div class="line"></div><div class="line"><span class="comment">//子类</span></div><div class="line">ZOCDaySalesListViewController</div><div class="line">ZOCMonthSalesListViewController</div></pre></td></tr></table></figure></p>
<h3 id="2-initializer-amp-amp-dealloc"><a href="#2-initializer-amp-amp-dealloc" class="headerlink" title="2. initializer &amp;&amp; dealloc"></a>2. initializer &amp;&amp; dealloc</h3><p>推荐：</p>
<ul>
<li>将 dealloc 方法放在实现文件的最前面</li>
<li>将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。</li>
</ul>
<h4 id="2-1-dealloc方法里面应该直接访问实例变量，不应该用点语法访问"><a href="#2-1-dealloc方法里面应该直接访问实例变量，不应该用点语法访问" class="headerlink" title="2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问"></a>2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问</h4><h4 id="2-2-init方法的写法："><a href="#2-2-init方法的写法：" class="headerlink" title="2.2 init方法的写法："></a>2.2 init方法的写法：</h4><ul>
<li>init方法返回类型必须是instancetype，不能是id。</li>
<li>必须先实现[super init]。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init &#123; </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; <span class="comment">// call the designated initializer </span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123; </div><div class="line">        <span class="comment">// Custom initialization </span></div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-指定初始化方法"><a href="#2-3-指定初始化方法" class="headerlink" title="2.3 指定初始化方法"></a>2.3 指定初始化方法</h4><p>指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。</p>
<p>注意事项1：间接初始化方法必须调用指定初始化方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZOCEvent</span> </span></div><div class="line"></div><div class="line"><span class="comment">//指定初始化方法</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title date:(<span class="built_in">NSDate</span> *)date </div><div class="line">location:(<span class="built_in">CLLocation</span> *)location</div><div class="line">&#123; </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; </div><div class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">         _title = title; </div><div class="line">         _date = date; </div><div class="line">         _location = location; </div><div class="line">      &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//间接初始化方法</span></div><div class="line">-  (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title date:(<span class="built_in">NSDate</span> *)date</div><div class="line">&#123; </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:title date:date location:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//间接初始化方法</span></div><div class="line">-  (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title </div><div class="line">&#123; </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:title date:[<span class="built_in">NSDate</span> date] location:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"> <span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤</p>
<ol>
<li>定义新的指定初始化方法，并确保调用了直接父类的初始化方法。</li>
<li>重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。</li>
<li>为新的指定初始化方法写文档。</li>
</ol>
<p>看一个标准的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZOCNewsViewController</span></span></div><div class="line"></div><div class="line"><span class="comment">//新的指定初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithNews:(ZOCNews *)news &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:<span class="literal">nil</span> bundle:<span class="literal">nil</span>]; </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _news = news;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// 重载父类的初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNews:<span class="literal">nil</span>]; </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。</p>
<p>假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。</p>
<p>而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令<code>__attribute__((objc_designated_initializer))</code>来标记它。</p>
<h3 id="3-所有返回类对象和实例对象的方法都应该使用instancetype"><a href="#3-所有返回类对象和实例对象的方法都应该使用instancetype" class="headerlink" title="3. 所有返回类对象和实例对象的方法都应该使用instancetype"></a>3. 所有返回类对象和实例对象的方法都应该使用instancetype</h3><p>将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象）</p>
<p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCPerson</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)personWithName:(<span class="built_in">NSString</span> *)name; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCPerson</span></span></div><div class="line">+ (<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="4-在类的头文件中尽量少引用其他头文件"><a href="#4-在类的头文件中尽量少引用其他头文件" class="headerlink" title="4. 在类的头文件中尽量少引用其他头文件"></a>4. 在类的头文件中尽量少引用其他头文件</h3><p>有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EOCPerson.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">EOCEmployer</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EOCEmployer *employer;<span class="comment">//将EOCEmployer作为属性</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// EOCPerson.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"EOCEmployer.h"</span></span></div></pre></td></tr></table></figure>
<p>这样做有什么优点呢：</p>
<blockquote>
<ul>
<li>不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。</li>
<li>可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</li>
</ul>
</blockquote>
<p>但是个别的时候，必须在头文件中引入其他类的头文件:</p>
<blockquote>
<p>主要有两种情况：</p>
<ol>
<li>该类继承于某个类，则应该引入父类的头文件。</li>
<li>该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。</li>
</ol>
</blockquote>
<h3 id="5-类的布局"><a href="#5-类的布局" class="headerlink" title="5. 类的布局"></a>5. 类的布局</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#pragma mark - Life Cycle Methods</span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Override Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Intial Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Network Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Target Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Public Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Private Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - UITableViewDataSource  </span></div><div class="line"><span class="meta">#pragma mark - UITableViewDelegate  </span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Lazy Loads</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSCopying  </span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSObject  Methods</span></div></pre></td></tr></table></figure>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><hr>
<h3 id="1-分类添加的方法需要添加前缀和下划线"><a href="#1-分类添加的方法需要添加前缀和下划线" class="headerlink" title="1. 分类添加的方法需要添加前缀和下划线"></a>1. 分类添加的方法需要添加前缀和下划线</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">ZOCTimeExtensions</span>)</span></div><div class="line"> - (<span class="built_in">NSString</span> *)zoc_timeAgoShort;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">ZOCTimeExtensions</span>) </span></div><div class="line">- (<span class="built_in">NSString</span> *)timeAgoShort;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="2-把类的实现代码分散到便于管理的多个分类中"><a href="#2-把类的实现代码分散到便于管理的多个分类中" class="headerlink" title="2. 把类的实现代码分散到便于管理的多个分类中"></a>2. 把类的实现代码分散到便于管理的多个分类中</h3><p>一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。</p>
<p>举个🌰：</p>
<p>先看一个没有使用无分类的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">/* Friendship methods */</div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">/* Work methods */</div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">/* Play methods */</div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>分类之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line"></div><div class="line">andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Work)</div><div class="line"></div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Play)</div><div class="line"></div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>其中，FriendShip分类的实现代码可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// EOCPerson+Friendship.h</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson+Friendship.m</div><div class="line">#import &quot;EOCPerson+Friendship.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFriend:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在新建分类文件时，一定要引入被分类的类文件。</p>
</blockquote>
<p>通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。</p>
<p>利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。</p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><hr>
<h3 id="1-单例不能作为容器对象来使用"><a href="#1-单例不能作为容器对象来使用" class="headerlink" title="1. 单例不能作为容器对象来使用"></a>1. 单例不能作为容器对象来使用</h3><p>单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。</p>
<h3 id="2-使用dispatch-once来生成单例"><a href="#2-使用dispatch-once来生成单例" class="headerlink" title="2. 使用dispatch_once来生成单例"></a>2. 使用dispatch_once来生成单例</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; </div><div class="line"> <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>; </div><div class="line"> <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken = <span class="number">0</span>;</div><div class="line">       <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class="line">  sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">  &#125;); </div><div class="line"> <span class="keyword">return</span> sharedInstance; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; </div><div class="line"> <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance; </div><div class="line"> <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; </div><div class="line"> <span class="keyword">if</span> (sharedInstance == <span class="literal">nil</span>) &#123;  sharedInstance = [[MyClass alloc] init]; </div><div class="line"> &#125; &#125; </div><div class="line"> <span class="keyword">return</span> sharedInstance; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="相等性的判断"><a href="#相等性的判断" class="headerlink" title="相等性的判断"></a>相等性的判断</h2><hr>
<p>判断两个person类是否相等的合理做法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-  (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> == object) &#123;  <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">//判断内存地址</span></div><div class="line"> &#125; </div><div class="line">  <span class="keyword">if</span> (![object isKindOfClass:[ZOCPerson <span class="keyword">class</span>]]) &#123; </div><div class="line">     <span class="keyword">return</span> <span class="literal">NO</span>; <span class="comment">//是否为当前类或派生类 &#125; </span></div><div class="line"> <span class="keyword">return</span> [<span class="keyword">self</span> isEqualToPerson:(ZOCPerson *)object]; </div><div class="line"> </div><div class="line">&#125;</div><div class="line"><span class="comment">//自定义的判断相等性的方法</span></div><div class="line">-  (<span class="built_in">BOOL</span>)isEqualToPerson:(Person *)person &#123; </div><div class="line">        <span class="keyword">if</span> (!person) &#123;  <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">  &#125; <span class="built_in">BOOL</span> namesMatch = (!<span class="keyword">self</span>.name &amp;&amp; !person.name) || [<span class="keyword">self</span>.name isEqualToString:person.name]; <span class="built_in">BOOL</span> birthdaysMatch = (!<span class="keyword">self</span>.birthday &amp;&amp; !person.birthday) || [<span class="keyword">self</span>.birthday isEqualToDate:person.birthday]; <span class="keyword">return</span> haveEqualNames &amp;&amp; haveEqualBirthdays; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法文档"><a href="#方法文档" class="headerlink" title="方法文档"></a>方法文档</h2><hr>
<p>一个函数(方法)必须有一个字符串文档来解释，除非它：</p>
<ul>
<li>非公开，私有函数。</li>
<li>很短。</li>
<li>显而易见。</li>
</ul>
<p>而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：</p>
<ul>
<li>以/开始</li>
<li>第二行识总结性的语句</li>
<li>第三行永远是空行</li>
<li>在与第二行开头对齐的位置写剩下的注释。</li>
</ul>
<p>建议这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/This comment serves to demonstrate the format of a doc string.</div><div class="line"></div><div class="line">Note that the summary line is always at most one line <span class="keyword">long</span>, and after the opening block comment,</div><div class="line">and each line of text is preceded by a single space.</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>看一个指定初始化方法的注释：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/ </div><div class="line">  *  Designated initializer. *</div><div class="line">  *  @param store The store <span class="keyword">for</span> CRUD operations.</div><div class="line">  *  @param searchService The search service used to query the store. </div><div class="line">  *  @return A ZOCCRUDOperationsStore object.</div><div class="line">  */ </div><div class="line">- (<span class="keyword">instancetype</span>)initWithOperationsStore:(<span class="keyword">id</span>&lt;ZOCGenericStoreProtocol&gt;)store searchService:(<span class="keyword">id</span>&lt;ZOCGenericSearchServiceProtocol&gt;)searchService;</div></pre></td></tr></table></figure></p>
<h3 id="多用队列，少用同步锁来避免资源抢夺"><a href="#多用队列，少用同步锁来避免资源抢夺" class="headerlink" title="多用队列，少用同步锁来避免资源抢夺"></a>多用队列，少用同步锁来避免资源抢夺</h3><hr>
<p>多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。</p>
<h4 id="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："><a href="#方案一：使用串行同步队列来将读写操作都安排到同一个队列里：" class="headerlink" title="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："></a>方案一：使用串行同步队列来将读写操作都安排到同一个队列里：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveobjectivec.syncQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">         __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">         <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">            localSomeString = _someString;</div><div class="line">        &#125;);</div><div class="line">         <span class="keyword">return</span> localSomeString;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，读写操作都在串行队列进行，就不容易出错。</p>
<p>但是，还有一种方法可以让性能更高：</p>
<h4 id="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"><a href="#方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。" class="headerlink" title="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"></a>方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">     <span class="keyword">return</span> localSomeString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。<br>这里的<code>dispatch_barrier_async</code>方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。</p>
<h2 id="实现description方法打印自定义对象信息"><a href="#实现description方法打印自定义对象信息" class="headerlink" title="实现description方法打印自定义对象信息"></a>实现description方法打印自定义对象信息</h2><hr>
<p>在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：<code>object = &lt;EOCPerson: 0x7fd9a1600600&gt;</code></p>
<p>这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。</p>
<p>但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。</p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@ %@&gt;"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>, firstName, lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，显示了内存地址，还有该类的所有属性。</p>
<p>而且，如果我们将这些属性值放在字典里打印，则更具有可读性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@&gt;"</span>,[<span class="keyword">self</span> <span class="keyword">class</span>],<span class="keyword">self</span>,</div><div class="line">   </div><div class="line">    @&#123;    <span class="string">@"title"</span>:_title,</div><div class="line">       <span class="string">@"latitude"</span>:@(_latitude),</div><div class="line">      <span class="string">@"longitude"</span>:@(_longitude)&#125;</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location = &lt;EOCLocation: <span class="number">0x7f98f2e01d20</span>, &#123;</div><div class="line"></div><div class="line">    latitude = <span class="string">"51.506"</span>;</div><div class="line">   longitude = <span class="number">0</span>;</div><div class="line">       title = London;</div><div class="line">&#125;&gt;</div></pre></td></tr></table></figure>
<p>我们可以看到，通过重写<code>description</code>方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。</p>
<h2 id="NSArray-amp-NSMutableArray"><a href="#NSArray-amp-NSMutableArray" class="headerlink" title="NSArray&amp; NSMutableArray"></a>NSArray&amp; NSMutableArray</h2><hr>
<h3 id="1-addObject之前要非空判断。"><a href="#1-addObject之前要非空判断。" class="headerlink" title="1. addObject之前要非空判断。"></a>1. addObject之前要非空判断。</h3><h3 id="2-取下标的时候要判断是否越界。"><a href="#2-取下标的时候要判断是否越界。" class="headerlink" title="2. 取下标的时候要判断是否越界。"></a>2. 取下标的时候要判断是否越界。</h3><h3 id="3-取第一个元素或最后一个元素的时候使用firtstObject和lastObject"><a href="#3-取第一个元素或最后一个元素的时候使用firtstObject和lastObject" class="headerlink" title="3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject"></a>3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject</h3><h2 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h2><hr>
<h3 id="1-构建缓存时选用NSCache-而非NSDictionary"><a href="#1-构建缓存时选用NSCache-而非NSDictionary" class="headerlink" title="1. 构建缓存时选用NSCache 而非NSDictionary"></a>1. 构建缓存时选用NSCache 而非NSDictionary</h3><p>如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。</p>
<p>在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。</p>
<h3 id="2-NSCache优于NSDictionary的几点："><a href="#2-NSCache优于NSDictionary的几点：" class="headerlink" title="2. NSCache优于NSDictionary的几点："></a>2. NSCache优于NSDictionary的几点：</h3><ul>
<li>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</li>
<li>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</li>
<li>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</li>
</ul>
<h2 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h2><hr>
<h3 id="1-通知的名称"><a href="#1-通知的名称" class="headerlink" title="1. 通知的名称"></a>1. 通知的名称</h3><p>建议将通知的名字作为常量，保存在一个专门的类中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Const.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification</div><div class="line"></div><div class="line"><span class="comment">// Const.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification = <span class="string">@"ZOCFooDidBecomeBarNotification"</span>;</div></pre></td></tr></table></figure>
<h3 id="2-通知的移除"><a href="#2-通知的移除" class="headerlink" title="2. 通知的移除"></a>2. 通知的移除</h3><p>通知必须要在对象销毁之前移除掉。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr>
<h3 id="1-Xcode工程文件的物理路径要和逻辑路径保持一致。"><a href="#1-Xcode工程文件的物理路径要和逻辑路径保持一致。" class="headerlink" title="1. Xcode工程文件的物理路径要和逻辑路径保持一致。"></a>1. Xcode工程文件的物理路径要和逻辑路径保持一致。</h3><h3 id="2-忽略没有使用变量的编译警告"><a href="#2-忽略没有使用变量的编译警告" class="headerlink" title="2. 忽略没有使用变量的编译警告"></a>2. 忽略没有使用变量的编译警告</h3><p>对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)giveMeFive &#123; </div><div class="line"> <span class="built_in">NSString</span> *foo; </div><div class="line"> <span class="meta">#pragma unused (foo) </span></div><div class="line"> <span class="keyword">return</span> <span class="number">5</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-手动标明警告和错误"><a href="#3-手动标明警告和错误" class="headerlink" title="3. 手动标明警告和错误"></a>3. 手动标明警告和错误</h3><h4 id="手动明确一个错误："><a href="#手动明确一个错误：" class="headerlink" title="手动明确一个错误："></a>手动明确一个错误：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)divide:(<span class="built_in">NSInteger</span>)dividend by:(<span class="built_in">NSInteger</span>)divisor &#123; </div><div class="line"> <span class="meta">#error Whoa, buddy, you need to check for zero here! </span></div><div class="line"> <span class="keyword">return</span> (dividend / divisor); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="手动明确一个警告："><a href="#手动明确一个警告：" class="headerlink" title="手动明确一个警告："></a>手动明确一个警告：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">float</span>)divide:(<span class="keyword">float</span>)dividend by:(<span class="keyword">float</span>)divisor &#123; </div><div class="line"> <span class="meta">#warning Dude, don't compare floating point numbers like this! </span></div><div class="line"> <span class="keyword">if</span> (divisor != <span class="number">0.0</span>) &#123; </div><div class="line">  <span class="keyword">return</span> (dividend / divisor); </div><div class="line"> &#125; <span class="keyword">else</span> &#123;  <span class="keyword">return</span> NAN; </div><div class="line"> &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><ol>
<li><a href="http://www.jianshu.com/p/7645a5ea7f46" target="_blank" rel="external">王垠：编程的智慧</a></li>
<li><a href="http://tech.meituan.com/clean-code.html" target="_blank" rel="external">美团点评技术团队：聊聊clean code</a></li>
<li><a href="https://github.com/oa414/objc-zen-book-cn/">禅与 Objective-C 编程艺术</a></li>
<li><a href="http://www.jianshu.com/nb/6074358" target="_blank" rel="external">J_Knight 的文集：iOS - 《Effective Objective-C 2.0》</a></li>
<li><a href="http://www.jianshu.com/p/08be5b30ff82" target="_blank" rel="external">蝴蝶之梦天使：iOS代码编程规范-根据项目经验汇总</a></li>
<li><a href="http://www.jianshu.com/p/003f2d777ee8" target="_blank" rel="external">高家二少爷：Objective-C高质量代码参考规范</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-a9d78ce3d5e7114f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;配图来自：nipic.com&quot;&gt;&lt;/p&gt;
&lt;p&gt;利用上周的业余时间把这篇规范整理了出来，我会将这篇规范作为我们iOS团队的代码规范，并且还会根据读者的反馈，项目的实践和研究的深入做不定时更新，还希望各位朋友看了多多指正和批评。&lt;/p&gt;
&lt;p&gt;这篇规范一共分为三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;核心原则：介绍了这篇代码规范所遵循的核心原则。&lt;/li&gt;
&lt;li&gt;通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。&lt;/li&gt;
&lt;li&gt;iOS规范：仅适用于iOS的代码规范（使用Objective-C语言）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>2017年5月iOS招人心得（附面试题）</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/06/08/2017%E5%B9%B45%E6%9C%88iOS%E6%8B%9B%E4%BA%BA%E5%BF%83%E5%BE%97%EF%BC%88%E9%99%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/06/08/2017年5月iOS招人心得（附面试题）/</id>
    <published>2017-06-08T05:28:16.000Z</published>
    <updated>2017-06-08T05:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-62c64645adc0ec72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配图来自：https://pixabay.com"></p>
<blockquote>
<p>就在上个月中旬，技术老大让我招两个1-2年的iOS开发，把简历的筛选和第一轮技术面试的任务交给了我。</p>
</blockquote>
<p>从筛选第一份简历，准备面试题，到成功招到两个人一共花了两个星期多一点，总体来说还是比较顺利的。两位通过者都比较稳重踏实，而且对技术也比较有追求。这也可能和我筛选简历比较谨慎有关系，这次筛选简历所花费的精力是不比面试花费的少的。</p>
<p>虽然时间跨度不是很长，但是毕竟是第一次，所以有些感触，想总结出来分享给大家。这篇总结分为两个部分：</p>
<ul>
<li>第一部分是我当时准备的面试题</li>
<li>第二部分是我的心得</li>
</ul>
<p>我重点在本文的第二部分说一下这次面试别人的心得体会。而关于第一部分的面试题，文中不提供答案（因为不是本文的重点）。</p>
<a id="more"></a>
<h1 id="第一部分：面试题"><a href="#第一部分：面试题" class="headerlink" title="第一部分：面试题"></a>第一部分：面试题</h1><hr>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol>
<li>为什么说Objective-C是一门动态的语言？</li>
<li>讲一下MVC和MVVM，MVP？</li>
<li>为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?</li>
<li>属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？</li>
<li>属性的默认关键字是什么？</li>
<li>NSString为什么要用copy关键字，如果用strong会有什么问题？</li>
<li>如何令自己所写的对象具有拷贝功能?</li>
<li>可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？</li>
<li>为什么IBOutlet修饰的UIView也适用weak关键字？</li>
<li>nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？</li>
<li>UICollectionView自定义layout如何实现？</li>
<li>用StoryBoard开发界面有什么弊端？如何避免？</li>
<li>进程和线程的区别？同步异步的区别？并行和并发的区别？</li>
<li>线程间通信？</li>
<li>GCD的一些常用的函数？（group，barrier，信号量，线程同步）</li>
<li>如何使用队列来避免资源抢夺？</li>
<li>数据持久化的几个方案（fmdb用没用过）</li>
<li>说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？</li>
<li>NSCache优于NSDictionary的几点？</li>
<li>知不知道Designated Initializer？使用它的时候有什么需要注意的问题？</li>
<li>实现description方法能取到什么效果？</li>
<li>objc使用什么机制管理对象内存？</li>
</ol>
<h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><h4 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h4><ol>
<li>block的实质是什么？一共有几种block？都是什么情况下生成的？</li>
<li>为什么在默认情况下无法修改被block捕获的变量？ __block都做了什么？ </li>
<li>模拟一下循环引用的一个情况？block实现界面反向传值如何实现？</li>
</ol>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><ol>
<li>objc在向一个对象发送消息时，发生了什么？</li>
<li>什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？</li>
<li>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</li>
<li>runtime如何实现weak变量的自动置nil？</li>
<li>给类添加一个属性后，在类结构体里哪些元素会发生变化？</li>
</ol>
<h4 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h4><ol>
<li>runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？</li>
<li>runloop的mode是用来做什么的？有几种mode？</li>
<li>为什么把NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环以后，滑动scrollview的时候NSTimer却不动了？</li>
<li>苹果是如何实现Autorelease Pool的？</li>
</ol>
<h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><ol>
<li>isa指针？（对象的isa，类对象的isa，元类的isa都要说）</li>
<li>类方法和实例方法有什么区别？</li>
<li>介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？</li>
<li>运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？</li>
<li>objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）</li>
</ol>
<h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><ol>
<li>UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）</li>
<li>有没有用过运行时，用它都能做什么？（交换方法，创建类，给新创建的类增加方法，改变isa指针）</li>
<li>看过哪些第三方框架的源码？都是如何实现的？（如果没有，问一下多图下载的设计）</li>
<li>SDWebImage的缓存策略？</li>
<li>AFN为什么添加一条常驻线程？</li>
<li>KVO的使用？实现原理？（为什么要创建子类来实现）</li>
<li>KVC的使用？实现原理？（KVC拿到key以后，是如何赋值的？知不知道集合操作符，能不能访问私有属性，能不能直接访问_ivar）</li>
</ol>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol>
<li>有已经上线的项目么？</li>
<li>项目里哪个部分是你完成的？（找一个亮点问一下如何实现的）</li>
<li>开发过程中遇到过什么困难，是如何解决的？</li>
</ol>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ol>
<li>遇到一个问题完全不能理解的时候，是如何帮助自己理解的？举个例子？</li>
<li>有看书的习惯么？最近看的一本是什么书？有什么心得？</li>
<li>有没有使用一些笔记软件？会在多平台同步以及多渠道采集么？（如果没有，问一下是如何复习知识的）</li>
<li>有没有使用清单类，日历类的软件？（如果没有，问一下是如何安排，计划任务的）</li>
<li>平常看博客么？有没有自己写过？（如果写，有哪些收获？如果没有写，问一下不写的原因）</li>
</ol>
<p>有关技术类的问题可以在评论区留言，我重点说一下这轮面试的心得和体会。</p>
<h1 id="第二部分：心得"><a href="#第二部分：心得" class="headerlink" title="第二部分：心得"></a>第二部分：心得</h1><hr>
<h3 id="面试者千万不要答非所问"><a href="#面试者千万不要答非所问" class="headerlink" title="面试者千万不要答非所问"></a>面试者千万不要答非所问</h3><p>如果让我选一个让面试官觉得印象减分的点，答非所问应该是首当其冲的。</p>
<blockquote>
<p>面试者一定要知道面试官问的点是什么。</p>
</blockquote>
<ul>
<li>如果在知道面试官问的点，但是自己却不知道答案的时候，可以提出思路，思考过程。其实有几次面试者在我的引导下很容易就把答案说出来了，认清问题的点是解决问题的一半。</li>
<li>如果没有理解好面试官问的问题，一定要事先和面试官确认好。</li>
</ul>
<p>其实这也属于沟通能力的一点：如果不能保证和对方沟通内容的一致性，自己弄个filter把对方的话都曲解了，以后合作的时候又怎能保证沟通好呢？</p>
<h3 id="面试者一定不要来得太早"><a href="#面试者一定不要来得太早" class="headerlink" title="面试者一定不要来得太早"></a>面试者一定不要来得太早</h3><blockquote>
<p>这里说的来得太早，是来得太早并告知面试官自己已经来了。</p>
</blockquote>
<p>因为在约定好的面试时间之前，往往面试官还有别的事情在做，如果他知道你来的很早，就可能会扰乱他的计划。有一位面试者早来了1个小时，结果把我们的面试计划打乱了，而且正好是我的第一次面试，所以真的是有点措手不及。</p>
<p>求职者和公司定下来的时间属于一个约定，约定是要遵守的。而且遵守约定同样也是对对方的尊重。如果入职之前都没能把握好，入职之后又如何能保证把握好呢？</p>
<h3 id="实践与理论的脱节，让人很不安"><a href="#实践与理论的脱节，让人很不安" class="headerlink" title="实践与理论的脱节，让人很不安"></a>实践与理论的脱节，让人很不安</h3><blockquote>
<p>能做出来项目，但是基础知识很薄弱</p>
</blockquote>
<p>几乎每位面试者都能给我展示他做的一些app，虽然没有很难的功能，但也都算是有板有眼。可让我比较意外的是，虽然能做出有模有样的app，但当我问到很多基础的问题的时候却答不上来，比如属性和成员变量的区别，属性的默认关键字，Designated Initializer的概念等等。。</p>
<p>这不禁让我怀疑他们的代码的稳定性，更怀疑他们治学，做技术的态度。</p>
<p>虽说技术活需要实践的磨练，但和理论脱节的技术是钻不深的。可能有人会说我的面试题过于理论，实际中用不到。但有些时候，在实际开发中遇到的一些问题往往就是因为一些很基本的东西没有弄清导致的，相信你我都深有体会。</p>
<p>而且，我们都知道技术的提升是阶梯式的。什么是阶梯式的呢？就是可能我们会有比较长的时间才会有一个突破。但这个突破来的有多快，提升的有多高，是跟平时每个细小知识点的掌握程度是分不开的。</p>
<p>因为知识也是有复利效应的，准确地掌握越多的知识点，在以后的学习过程中，这些知识点相互之间想成的积极作用会越来越大：对新知识的理解更快，对问题的定位会更准，解决问题的方法也会越多。相反，如果你每个问题都得过且过，这些结果的复合作用就会导致你今后很难会有所突破了。</p>
<h3 id="真的可能被简历骗到"><a href="#真的可能被简历骗到" class="headerlink" title="真的可能被简历骗到"></a>真的可能被简历骗到</h3><blockquote>
<p>上家的薪资很高，但是实际能力很不符</p>
</blockquote>
<p>有一位面试者在简历里号称上一个工作拿了15k，但当我问到NSString属性使用strong还是copy作为关键字的时候他却说是strong，甚至连delegate都拿不准使用strong还是weak，我就有些奇怪了。</p>
<h3 id="看技术博客和技术书籍的人还是很少的"><a href="#看技术博客和技术书籍的人还是很少的" class="headerlink" title="看技术博客和技术书籍的人还是很少的"></a>看技术博客和技术书籍的人还是很少的</h3><blockquote>
<p>只依赖于公司里的项目应该是不够的，毕竟不是每个公司里都有上乘的代码和技术</p>
</blockquote>
<p>面试了大概20个人，但是真正有看过技术博客和技术书籍的真的不多，更别提Github了。不过其中一位面试通过者是有github账号的，并且有几个小项目，印象非常好，加了不少分。</p>
<p>我相信在这一行的未来，简历里面github账号和博客绝对会越来越受重视：</p>
<ul>
<li>一方面简历真的是应接不暇，而且同时千篇一律，很难找出亮点。</li>
<li>另一方面，如果可以把自己的代码和成长展示给招聘公司，就会使得自己的能力在公司面前变得更加纯粹和透明，更有助于找到适合你自己的公司。</li>
</ul>
<p>以上就是我上个月的面试心得，希望大家多交流，有说的不对的地方还请多指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-62c64645adc0ec72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;配图来自：https://pixabay.com&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就在上个月中旬，技术老大让我招两个1-2年的iOS开发，把简历的筛选和第一轮技术面试的任务交给了我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从筛选第一份简历，准备面试题，到成功招到两个人一共花了两个星期多一点，总体来说还是比较顺利的。两位通过者都比较稳重踏实，而且对技术也比较有追求。这也可能和我筛选简历比较谨慎有关系，这次筛选简历所花费的精力是不比面试花费的少的。&lt;/p&gt;
&lt;p&gt;虽然时间跨度不是很长，但是毕竟是第一次，所以有些感触，想总结出来分享给大家。这篇总结分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分是我当时准备的面试题&lt;/li&gt;
&lt;li&gt;第二部分是我的心得&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我重点在本文的第二部分说一下这次面试别人的心得体会。而关于第一部分的面试题，文中不提供答案（因为不是本文的重点）。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>使用Block实现KVO</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/05/15/%E4%BD%BF%E7%94%A8Block%E5%AE%9E%E7%8E%B0KVO/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/05/15/使用Block实现KVO/</id>
    <published>2017-05-15T00:24:28.000Z</published>
    <updated>2017-05-15T00:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，我们可以通过KVO机制来监听某个对象的某个属性的变化。</p>
<p>用过KVO的同学都应该知道，KVO的回调是以代理的形式实现的：在给某个对象添加观察以后，需要在另外一个地方实现回调代理方法。这种设计给人感觉比较分散，因此突然想试试用Block来实现KVO，将添加观察的代码和回调处理的代码写在一起。在学习了<a href="https://github.com/okcomp/ImplementKVO">ImplementKVO</a>的实现以后，自己也写了一个：<a href="https://github.com/knightsj/SJKVOController">SJKVOController</a></p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrollerblogimage.png" alt="使用Block来实现KVO"></p>
<h1 id="SJKVOController的用法"><a href="#SJKVOController的用法" class="headerlink" title="SJKVOController的用法"></a>SJKVOController的用法</h1><p>只需要引入<code>NSObject+SJKVOController.h</code>头文件就可以使用SJKVOController。<br>先看一下它的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SJKVOHeader.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">SJKVOController</span>)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============== add observer ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys withBlock:(SJKVOBlock)block;</div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key withBlock:(SJKVOBlock)block;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============= remove observer =============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer;</div><div class="line">- (<span class="keyword">void</span>)sj_removeAllObservers;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============= list observers ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_listAllObservers;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<blockquote>
<p>从上面的API可以看出，这个小轮子：</p>
<ol>
<li>支持一次观察同一对象的多个属性。</li>
<li>可以一次只观察一个对象的一个属性。</li>
<li>可以移除对某个对象对多个属性的观察。</li>
<li>可以移除对某个对象对某个属性的观察。</li>
<li>可以移除某个观察自己的对象。</li>
<li>可以移除所有观察自己的对象。</li>
<li>打印出所有观察自己的对象的信息，包括对象本身，观察的属性，setter方法。</li>
</ol>
</blockquote>
<p>下面来结合Demo讲解一下如何使用这个小轮子：</p>
<p>在点击上面两个按钮中的任意一个，增加观察：</p>
<p>一次性添加：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)addObserversTogether:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *keys = @[<span class="string">@"number"</span>,<span class="string">@"color"</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_addObserver:<span class="keyword">self</span> forKeys:keys withBlock:^(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"number"</span>]) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">self</span>.numberLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,newValue];</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"color"</span>])&#123;</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">self</span>.numberLabel.backgroundColor = newValue;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分两次添加：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)addObserverSeparatedly:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_addObserver:<span class="keyword">self</span> forKey:<span class="string">@"number"</span> withBlock:^(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">self</span>.numberLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,newValue];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_addObserver:<span class="keyword">self</span> forKey:<span class="string">@"color"</span> withBlock:^(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">self</span>.numberLabel.backgroundColor = newValue;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加以后，点击最下面的按钮来显示所有的观察信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)showAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_listAllObservers];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:==================== Start Listing All Observers: ==================== </div><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:observer item:&#123;observer: &lt;ViewController: <span class="number">0x7fa1577054f0</span>&gt; | key: color | <span class="keyword">setter</span>: setColor:&#125;</div><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:observer item:&#123;observer: &lt;ViewController: <span class="number">0x7fa1577054f0</span>&gt; | key: number | <span class="keyword">setter</span>: setNumber:&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在这里我重写了description方法，打印出了每个观察的对象和key,以及setter方法。</p>
</blockquote>
<p>现在点击更新按钮，则会更新model的number和color属性，从而触发KVO：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)updateNumber:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//trigger KVO : number</span></div><div class="line">    <span class="built_in">NSInteger</span> newNumber = arc4random() % <span class="number">100</span>;</div><div class="line">    <span class="keyword">self</span>.model.number = [<span class="built_in">NSNumber</span> numberWithInteger:newNumber];</div><div class="line">    </div><div class="line">    <span class="comment">//trigger KVO : color</span></div><div class="line">    <span class="built_in">NSArray</span> *colors = @[[<span class="built_in">UIColor</span> redColor],[<span class="built_in">UIColor</span> yellowColor],[<span class="built_in">UIColor</span> blueColor],[<span class="built_in">UIColor</span> greenColor]];</div><div class="line">    <span class="built_in">NSInteger</span> colorIndex = arc4random() % <span class="number">3</span>;</div><div class="line">    <span class="keyword">self</span>.model.color = colors[colorIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到中间的Label上面显示的数字和背景色都在变化，成功实现了KVO：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrolllergif1.gif" alt="同时观察颜色和数字的变化"></p>
<p>现在我们移除观察，点击remove按钮</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)removeAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    [<span class="keyword">self</span>.model sj_removeAllObservers];   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在移除了所有的观察者以后，则会打印出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:Removed all obserbing objects of object:&lt;Model: <span class="number">0x60000003b700</span>&gt;</div></pre></td></tr></table></figure></p>
<p>而且如果在这个时候打印观察者list，则会输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:There is no observers obserbing object:&lt;Model: <span class="number">0x60000003b700</span>&gt;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，这里的移除可以有多种选择：可以移某个对象的某个key，也可以移除某个对象的几个keys，为了验证，我们可以结合list方法来验证一下移除是否成功：</p>
<h4 id="验证1-在添加number和color的观察后，移除nunber的观察："><a href="#验证1-在添加number和color的观察后，移除nunber的观察：" class="headerlink" title="验证1:在添加number和color的观察后，移除nunber的观察："></a>验证1:在添加number和color的观察后，移除nunber的观察：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)removeAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    [<span class="keyword">self</span>.model sj_removeObserver:<span class="keyword">self</span> forKey:<span class="string">@"number"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在移除以后，我们调用list方法，输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80850</span>:<span class="number">4278383</span>] SJKVOLog:==================== Start Listing All Observers: ====================</div><div class="line">SJKVOController[<span class="number">80850</span>:<span class="number">4278383</span>] SJKVOLog:observer item:&#123;observer: &lt;ViewController: <span class="number">0x7ffeec408560</span>&gt; | key: color | <span class="keyword">setter</span>: setColor:&#125;</div></pre></td></tr></table></figure></p>
<p>现在只有color属性被观察了。看一下实际的效果：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrolllergif2.gif" alt="只观察颜色的变化"></p>
<p>我们可以看到，现在只有color在变，而数字没有变化了，验证此移除方法正确。</p>
<h4 id="验证2-在添加number和color的观察后，移除nunber和color的观察："><a href="#验证2-在添加number和color的观察后，移除nunber和color的观察：" class="headerlink" title="验证2:在添加number和color的观察后，移除nunber和color的观察："></a>验证2:在添加number和color的观察后，移除nunber和color的观察：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)removeAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_removeObserver:<span class="keyword">self</span> forKeys:@[<span class="string">@"number"</span>,<span class="string">@"color"</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在移除以后，我们调用list方法，输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80901</span>:<span class="number">4283311</span>] SJKVOLog:There is no observers obserbing object:&lt;Model: <span class="number">0x600000220fa0</span>&gt;</div></pre></td></tr></table></figure></p>
<p>现在color和number属性都不被观察了。看一下实际的效果：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrolllergif3.gif" alt="颜色和数字的变化都不再被观察"></p>
<p>我们可以看到，现在color和number都不变了，验证此移除方法正确。</p>
<p>OK，现在知道了怎么用SJKVOController，我下面给大家看一下代码：</p>
<h1 id="SJKVOController代码解析"><a href="#SJKVOController代码解析" class="headerlink" title="SJKVOController代码解析"></a>SJKVOController代码解析</h1><p>先大致讲解一下SJKVOController的实现思路：</p>
<ol>
<li>为了减少侵入性，SJKVOController被设计为NSObject的一个分类。</li>
<li>SJKVOController仿照了KVO的实现思路，在添加观察以后在运行时动态生成当前类的子类，给这个子类添加被观察的属性的set方法并使用isa swizzle的方式将当前对象转换为当前类的子类的实现。</li>
<li>同时，这个子类还使用了关联对象来保存一个“观察项”的set，每一个观察项封装了一次观察的行为（有去重机制）：包括观察自己的对象，自己被观察的属性，以及传进来的block。</li>
<li>在当前类，也就是子类的set方法被调用的时候做三件事情：<ul>
<li>第一件事情是使用KVC来找出当前属性的旧值。</li>
<li>第二件事情是调用父类（原来的类）的set方法（设新值）。</li>
<li>第三件事是根据当前的观察对象和key，在观察项set里面找出对应的block并调用。</li>
</ul>
</li>
</ol>
<p>再来看一下这个小轮子的几个类：</p>
<ul>
<li>SJKVOController：实现KVO主要功能的类。</li>
<li>SJKVOObserverItem：封装观察项的类。</li>
<li>SJKVOTool：setter和getter的相互转换和相关运行时查询方法等。</li>
<li>SJKVOError：封装错误类型。</li>
<li>SJKVOHeader：引用了运行时的头文件。</li>
</ul>
<p> 下面开始一个一个来讲解每个类的源码：</p>
<h2 id="SJKVOController"><a href="#SJKVOController" class="headerlink" title="SJKVOController"></a>SJKVOController</h2><p>再看一下头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SJKVOHeader.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">SJKVOController</span>)</span></div><div class="line"></div><div class="line"><span class="comment">//============== add observer ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys withBlock:(SJKVOBlock)block;</div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key withBlock:(SJKVOBlock)block;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============= remove observer =============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer;</div><div class="line">- (<span class="keyword">void</span>)sj_removeAllObservers;</div><div class="line"></div><div class="line"><span class="comment">//============= list observers ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_listAllObservers;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>每个方法的意思相信读者已经能看懂了，现在讲一下具体的实现。从<code>sj_addObserver:forKey withBlock:</code>开始：</p>
<h3 id="sj-addObserver-forKey-withBlock-方法："><a href="#sj-addObserver-forKey-withBlock-方法：" class="headerlink" title="sj_addObserver:forKey withBlock:方法："></a>sj_addObserver:forKey withBlock:方法：</h3><p>除去一些错误的判断，该方法作了下面几件事情：</p>
<h4 id="1-判断当前被观察的类是否存在与传入key对应的setter方法："><a href="#1-判断当前被观察的类是否存在与传入key对应的setter方法：" class="headerlink" title="1.判断当前被观察的类是否存在与传入key对应的setter方法："></a>1.判断当前被观察的类是否存在与传入key对应的setter方法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SEL setterSelector = <span class="built_in">NSSelectorFromString</span>([SJKVOTool setterFromGetter:key]);</div><div class="line">Method setterMethod = [SJKVOTool objc_methodFromClass:[<span class="keyword">self</span> <span class="keyword">class</span>] selector:setterSelector];</div><div class="line"><span class="comment">//error: no corresponding setter mothod</span></div><div class="line"><span class="keyword">if</span> (!setterMethod) &#123;</div><div class="line">     SJLog(<span class="string">@"%@"</span>,[SJKVOError errorNoMatchingSetterForKey:key]);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-如果有，判断当前被观察到类是否已经是KVO类-在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例-。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）："><a href="#2-如果有，判断当前被观察到类是否已经是KVO类-在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例-。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）：" class="headerlink" title="2. 如果有，判断当前被观察到类是否已经是KVO类(在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例)。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）："></a>2. 如果有，判断当前被观察到类是否已经是KVO类(在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例)。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get original class(current class,may be KVO class)</span></div><div class="line"><span class="built_in">NSString</span> *originalClassName = <span class="built_in">NSStringFromClass</span>(OriginalClass);</div><div class="line"></div><div class="line"><span class="comment">//如果当前的类是带有KVO前缀的类(也就是已经被观察到类),则需要将KVO前缀的类删除，并讲</span></div><div class="line"><span class="keyword">if</span> ([originalClassName hasPrefix:SJKVOClassPrefix]) &#123;</div><div class="line">    <span class="comment">//now,the OriginalClass is KVO class, we should destroy it and make new one</span></div><div class="line">    Class CurrentKVOClass = OriginalClass;</div><div class="line">    object_setClass(<span class="keyword">self</span>, class_getSuperclass(OriginalClass));</div><div class="line">    objc_disposeClassPair(CurrentKVOClass);</div><div class="line">    originalClassName = [originalClassName substringFromIndex:(SJKVOClassPrefix.length)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类："><a href="#3-如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类：" class="headerlink" title="3. 如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类："></a>3. 如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//create a KVO class</span></div><div class="line">Class KVOClass = [<span class="keyword">self</span> createKVOClassFromOriginalClassName:originalClassName];</div><div class="line"></div><div class="line"><span class="comment">//swizzle isa from self to KVO class</span></div><div class="line">object_setClass(<span class="keyword">self</span>, KVOClass);</div></pre></td></tr></table></figure>
<p>看一下如何新建一个新的类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (Class)createKVOClassFromOriginalClassName:(<span class="built_in">NSString</span> *)originalClassName</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *kvoClassName = [SJKVOClassPrefix stringByAppendingString:originalClassName];</div><div class="line">    Class KVOClass = <span class="built_in">NSClassFromString</span>(kvoClassName);</div><div class="line">    </div><div class="line">    <span class="comment">// KVO class already exists</span></div><div class="line">    <span class="keyword">if</span> (KVOClass) &#123;</div><div class="line">        <span class="keyword">return</span> KVOClass;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// if there is no KVO class, then create one</span></div><div class="line">    KVOClass = objc_allocateClassPair(OriginalClass, kvoClassName.UTF8String, <span class="number">0</span>);<span class="comment">//OriginalClass is super class</span></div><div class="line">    </div><div class="line">    <span class="comment">// pretending to be the original class:return the super class in class method</span></div><div class="line">    Method clazzMethod = class_getInstanceMethod(OriginalClass, <span class="keyword">@selector</span>(<span class="keyword">class</span>));</div><div class="line">    class_addMethod(KVOClass, <span class="keyword">@selector</span>(<span class="keyword">class</span>), (IMP)return_original_class, method_getTypeEncoding(clazzMethod));</div><div class="line">    </div><div class="line">    <span class="comment">// finally, register this new KVO class</span></div><div class="line">    objc_registerClassPair(KVOClass);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> KVOClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面："><a href="#4-查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面：" class="headerlink" title="4. 查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面："></a>4. 查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//if we already have some history observer items, we should add them into new KVO class</span></div><div class="line"><span class="built_in">NSMutableSet</span>* observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line"><span class="keyword">if</span> (observers.count &gt; <span class="number">0</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableSet</span> *newObservers = [[<span class="built_in">NSMutableSet</span> alloc] initWithCapacity:<span class="number">5</span>];</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers, newObservers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (SJKVOObserverItem *item <span class="keyword">in</span> observers) &#123;</div><div class="line">        [<span class="keyword">self</span> KVOConfigurationWithObserver:item.observer key:item.key block:item.block kvoClass:KVOClass setterSelector:item.setterSelector setterMethod:setterMethod];</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下如何保存观察项的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)KVOConfigurationWithObserver:(<span class="built_in">NSObject</span> *)observer key:(<span class="built_in">NSString</span> *)key block:(SJKVOBlock)block kvoClass:(Class)kvoClass setterSelector:(SEL)setterSelector setterMethod:(Method)setterMethod</div><div class="line">&#123;</div><div class="line">    <span class="comment">//add setter method in KVO Class</span></div><div class="line">    <span class="keyword">if</span>(![SJKVOTool detectClass:OriginalClass hasSelector:setterSelector])&#123;</div><div class="line">        class_addMethod(kvoClass, setterSelector, (IMP)kvo_setter_implementation, method_getTypeEncoding(setterMethod));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//add item of this observer&amp;&amp;key pair</span></div><div class="line">    [<span class="keyword">self</span> addObserverItem:observer key:key setterSelector:setterSelector setterMethod:setterMethod block:block];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里首先给KVO类增加了setter方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//implementation of KVO setter method</span></div><div class="line"><span class="keyword">void</span> kvo_setter_implementation(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue)</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *setterName = <span class="built_in">NSStringFromSelector</span>(_cmd);</div><div class="line">    <span class="built_in">NSString</span> *getterName = [SJKVOTool getterFromSetter:setterName];</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!getterName) &#123;</div><div class="line">        SJLog(<span class="string">@"%@"</span>,[SJKVOError errorTransferSetterToGetterFaildedWithSetterName:setterName]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// create a super class of a specific instance</span></div><div class="line">    Class superclass = class_getSuperclass(OriginalClass);</div><div class="line">    </div><div class="line">    <span class="keyword">struct</span> objc_super superclass_to_call = &#123;</div><div class="line">        .super_class = superclass,  <span class="comment">//super class</span></div><div class="line">        .receiver = <span class="keyword">self</span>,           <span class="comment">//insatance of this class</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// cast method pointer</span></div><div class="line">    <span class="keyword">void</span> (*objc_msgSendSuperCasted)(<span class="keyword">void</span> *, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)objc_msgSendSuper;</div><div class="line">    </div><div class="line">    <span class="comment">// call super's setter, the supper is the original class</span></div><div class="line">    objc_msgSendSuperCasted(&amp;superclass_to_call, _cmd, newValue);</div><div class="line">    </div><div class="line">    <span class="comment">// look up observers and call the blocks</span></div><div class="line">    <span class="built_in">NSMutableSet</span> *observers = objc_getAssociatedObject(<span class="keyword">self</span>,&amp;SJKVOObservers);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (observers.count &lt;= <span class="number">0</span>) &#123;</div><div class="line">        SJLog(<span class="string">@"%@"</span>,[SJKVOError errorNoObserverOfObject:<span class="keyword">self</span>]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//get the old value</span></div><div class="line">    <span class="keyword">id</span> oldValue = [<span class="keyword">self</span> valueForKey:getterName];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (SJKVOObserverItem *item <span class="keyword">in</span> observers) &#123;</div><div class="line">        <span class="keyword">if</span> ([item.key isEqualToString:getterName]) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">                <span class="comment">//call block</span></div><div class="line">                item.block(<span class="keyword">self</span>, getterName, oldValue, newValue);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实例化对应的观察项：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserverItem:(<span class="built_in">NSObject</span> *)observer</div><div class="line">                    key:(<span class="built_in">NSString</span> *)key</div><div class="line">         setterSelector:(SEL)setterSelector</div><div class="line">           setterMethod:(Method)setterMethod</div><div class="line">                  block:(SJKVOBlock)block</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableSet</span> *observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line">    <span class="keyword">if</span> (!observers) &#123;</div><div class="line">        observers = [[<span class="built_in">NSMutableSet</span> alloc] initWithCapacity:<span class="number">10</span>];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers, observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    SJKVOObserverItem *item = [[SJKVOObserverItem alloc] initWithObserver:observer Key:key setterSelector:setterSelector setterMethod:setterMethod block:block];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (item) &#123;</div><div class="line">        [observers addObject:item];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="5-判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察："><a href="#5-判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察：" class="headerlink" title="5. 判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察："></a>5. 判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/ /ignore same observer and key:<span class="keyword">if</span> the observer and key are same with saved observerItem,we should not add them one more time</div><div class="line"><span class="built_in">BOOL</span> findSameObserverAndKey = <span class="literal">NO</span>;</div><div class="line"><span class="keyword">if</span> (observers.count&gt;<span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (SJKVOObserverItem *item <span class="keyword">in</span> observers) &#123;</div><div class="line">        <span class="keyword">if</span> ( (item.observer == observer) &amp;&amp; [item.key isEqualToString:key]) &#123;</div><div class="line">            findSameObserverAndKey = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!findSameObserverAndKey) &#123;</div><div class="line">    [<span class="keyword">self</span> KVOConfigurationWithObserver:observer key:key block:block kvoClass:KVOClass setterSelector:setterSelector setterMethod:setterMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而一次性添加多个key的方法，也只是调用多次一次性添加单个key的方法罢了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">               forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys</div><div class="line">             withBlock:(SJKVOBlock)block</div><div class="line">&#123;</div><div class="line">    <span class="comment">//error: keys array is nil or no elements</span></div><div class="line">    <span class="keyword">if</span> (keys.count == <span class="number">0</span>) &#123;</div><div class="line">        SJLog(<span class="string">@"%@"</span>,[SJKVOError errorInvalidInputObservingKeys]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//one key corresponding to one specific item, not the observer</span></div><div class="line">    [keys enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> * key, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        [<span class="keyword">self</span> sj_addObserver:observer forKey:key withBlock:block];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于移除观察的实现，只是在观察项set里面找出封装了对应的观察对象和key的观察项就可以了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">                   forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableSet</span>* observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (observers.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        SJKVOObserverItem *removingItem = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">for</span> (SJKVOObserverItem* item <span class="keyword">in</span> observers) &#123;</div><div class="line">            <span class="keyword">if</span> (item.observer == observer &amp;&amp; [item.key isEqualToString:key]) &#123;</div><div class="line">                removingItem = item;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (removingItem) &#123;</div><div class="line">            [observers removeObject:removingItem];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看一下移除所有观察者：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sj_removeAllObservers</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableSet</span>* observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (observers.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        [observers removeAllObjects];</div><div class="line">        SJLog(<span class="string">@"SJKVOLog:Removed all obserbing objects of object:%@"</span>,<span class="keyword">self</span>);</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        SJLog(<span class="string">@"SJKVOLog:There is no observers obserbing object:%@"</span>,<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="SJKVOObserverItem"><a href="#SJKVOObserverItem" class="headerlink" title="SJKVOObserverItem"></a>SJKVOObserverItem</h2><p>这个类负责封装每一个观察项的信息，包括：</p>
<ul>
<li>观察者对象。</li>
<li>被观察的key。</li>
<li>setter方法名（SEL）</li>
<li>setter方法（Method）</li>
<li>回调的block</li>
</ul>
<blockquote>
<p>需要注意的是:<br>在这个小轮子里，对于同一个对象可以观察不同的key的情况，是将这两个key区分开来的，是属于不同的观察项。所以应该用不同的<code>SJKVOObserverItem</code>实例来封装。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SJKVOBlock)(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJKVOObserverItem</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *observer;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *key;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL setterSelector;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Method setterMethod;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   SJKVOBlock block;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="built_in">NSObject</span> *)observer Key:(<span class="built_in">NSString</span> *)key setterSelector:(SEL)setterSelector setterMethod:(Method)setterMethod block:(SJKVOBlock)block;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="SJKVOTool"><a href="#SJKVOTool" class="headerlink" title="SJKVOTool"></a>SJKVOTool</h2><p>这个类负责setter方法与getter方法相互转换，以及和运行时相关的操作，服务于<code>SJKVOController</code>。看一下它的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJKVOTool</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">//setter &lt;-&gt; getter</span></div><div class="line">+ (<span class="built_in">NSString</span> *)getterFromSetter:(<span class="built_in">NSString</span> *)<span class="keyword">setter</span>;</div><div class="line">+ (<span class="built_in">NSString</span> *)setterFromGetter:(<span class="built_in">NSString</span> *)<span class="keyword">getter</span>;</div><div class="line"></div><div class="line"><span class="comment">//get method from a class by a specific selector</span></div><div class="line">+ (Method)objc_methodFromClass:(Class)cls selector:(SEL)selector;</div><div class="line"></div><div class="line"><span class="comment">//check a class has a specific selector or not</span></div><div class="line">+ (<span class="built_in">BOOL</span>)detectClass:(Class)cls hasSelector:(SEL)selector;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>##SJKVOError</p>
<p>这个小轮子仿照了<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>的错误管理方式，用单独的一个类<code>SJKVOError</code>来返回各种错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    </div><div class="line">    SJKVOErrorTypeNoObervingObject,</div><div class="line">    SJKVOErrorTypeNoObervingKey,</div><div class="line">    SJKVOErrorTypeNoObserverOfObject,</div><div class="line">    SJKVOErrorTypeNoMatchingSetterForKey,</div><div class="line">    SJKVOErrorTypeTransferSetterToGetterFailded,</div><div class="line">    SJKVOErrorTypeInvalidInputObservingKeys,</div><div class="line">    </div><div class="line">&#125; SJKVOErrorTypes;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJKVOError</span> : <span class="title">NSError</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)errorNoObervingObject;</div><div class="line">+ (<span class="keyword">id</span>)errorNoObervingKey;</div><div class="line">+ (<span class="keyword">id</span>)errorNoMatchingSetterForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">+ (<span class="keyword">id</span>)errorTransferSetterToGetterFaildedWithSetterName:(<span class="built_in">NSString</span> *)setterName;</div><div class="line">+ (<span class="keyword">id</span>)errorNoObserverOfObject:(<span class="keyword">id</span>)object;</div><div class="line">+ (<span class="keyword">id</span>)errorInvalidInputObservingKeys;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>OK，这样就介绍完了，希望各位同学可以积极指正～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，我们可以通过KVO机制来监听某个对象的某个属性的变化。&lt;/p&gt;
&lt;p&gt;用过KVO的同学都应该知道，KVO的回调是以代理的形式实现的：在给某个对象添加观察以后，需要在另外一个地方实现回调代理方法。这种设计给人感觉比较分散，因此突然想试试用Block来实现KVO，将添加观察的代码和回调处理的代码写在一起。在学习了&lt;a href=&quot;https://github.com/okcomp/ImplementKVO&quot;&gt;ImplementKVO&lt;/a&gt;的实现以后，自己也写了一个：&lt;a href=&quot;https://github.com/knightsj/SJKVOController&quot;&gt;SJKVOController&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/sjkvocontrollerblogimage.png&quot; alt=&quot;使用Block来实现KVO&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;SJKVOController的用法&quot;&gt;&lt;a href=&quot;#SJKVOController的用法&quot; class=&quot;headerlink&quot; title=&quot;SJKVOController的用法&quot;&gt;&lt;/a&gt;SJKVOController的用法&lt;/h1&gt;&lt;p&gt;只需要引入&lt;code&gt;NSObject+SJKVOController.h&lt;/code&gt;头文件就可以使用SJKVOController。&lt;br&gt;先看一下它的头文件：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;SJKVOHeader.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;SJKVOController&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//============== add observer ===============//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_addObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKeys:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; &amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt;*)keys withBlock:(SJKVOBlock)block;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_addObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key withBlock:(SJKVOBlock)block;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//============= remove observer =============//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKeys:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; &amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt;*)keys;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeAllObservers;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//============= list observers ===============//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_listAllObservers;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C 高级编程》干货三部曲（三）：GCD篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/04/24/%E3%80%8AObjective-C%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGCD%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/04/24/《Objective-C 高级编程》干货三部曲（三）：GCD篇/</id>
    <published>2017-04-24T01:21:34.000Z</published>
    <updated>2017-04-24T08:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>我们知道在iOS开发中，一共有四种多线程技术：pthread，NSThread，GCD，NSOperation：</p>
<ul>
<li>前两者是面向线程开发的多线程技术，需要开发者自己去维护线程的生命周期，比较繁琐。</li>
<li>后两者是面向队列开发的多线程技术，开发者仅仅定义想执行的任务追加到适当的Dispatch Queue（队列）中并设置一些优先级，依赖等操作就可以了，其他的事情可以交给系统来做。</li>
</ul>
<p>在这一章里，作者主要介绍了GCD技术，它是基于C语言的API，开发者只需要将任务放在block内，并指定好追加的队列，就可以完成多线程开发。</p>
<p>但是多线程开发时容易发生的一些问题：</p>
<ul>
<li>多个线程更新相同的资源：数据竞争。</li>
<li>多个线程相互持续等待：死锁。</li>
<li>使用太多的线程导致消耗内存。</li>
</ul>
<p>虽然解决这些问题的代价是会使程序的复杂度上升，但是多线程技术仍然是必须使用的：因为使用多线程编程可以保证应用程序的响应性能。如果耗时操作阻塞了主线程的RunLoop，会导致用户界面无法响应用户的操作，所以必须开启子线程将耗时操作放在子线程中处理。那么我们应该怎么进行多线程开发呢？在讲解之前先看一下本文结构（GCD部分）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<p>本文的Demo地址：<a href="https://github.com/knightsj/iOS_Demo/tree/master/%5B12%5D.%20gcd_demo">knightsj/iOS_Demo/gcd_demo</a><br>虽然文章里应给出了详细的输出结果，但还是希望读者可以将demo下载后仔细对照一下代码并体会。</p>
<a id="more"></a>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>Dispatch Queue是执行处理的等待队列，按照任务（block）追加到队列里的顺序，先进先出执行处理。</p>
<p>而等待队列有两种</p>
<ul>
<li>Serial Dispatch Queue：串行队列，等待当前执行任务处理结束的队列。</li>
<li>Concurrent Dispatch Queue:并发队列，不等待当前执行任务处理结束的队列。</li>
</ul>
<h2 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h2><p>将任务追加到串行队列：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)serialQueue</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"serial queue"</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index ++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"task index %ld in serial queue"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">0</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">1</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">2</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">3</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">4</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">5</span> <span class="keyword">in</span> serial queue</div></pre></td></tr></table></figure></p>
<blockquote>
<p>通过dispatch_queue_create函数可以创建队列，第一个函数为队列的名称，第二个参数是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;为了避免重复代码，我在这里使用了for循环，将任务追加到了queue中。</div><div class="line"></div><div class="line">&gt;注意，这里的任务是按照顺序执行的。说明任务是以阻塞的形式执行的：必须等待上一个任务执行完成才能执行现在的任务。也就是说：一个Serial Dispatch Queue中同时只能执行一个追加处理（任务block），而且系统对于一个Serial Dispatch Queue只生成并使用一个线程。</div><div class="line"></div><div class="line"></div><div class="line">但是，如果我们将6个任务分别追加到6个Serial Dispatch Queue中，那么系统就会同时处理这6个任务（因为会另开启6个子线程）：</div><div class="line"></div><div class="line"></div><div class="line">```objc</div><div class="line">- (void)multiSerialQueue</div><div class="line">&#123;</div><div class="line">    for (NSInteger index = 0; index &lt; 10; index ++) &#123;</div><div class="line">        //新建一个serial queue</div><div class="line">        dispatch_queue_t queue = dispatch_queue_create(&quot;different serial queue&quot;, NULL);</div><div class="line">        dispatch_async(queue, ^&#123;</div><div class="line">            NSLog(@&quot;serial queue index : %ld&quot;,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485282</span>] serial queue index : <span class="number">1</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485264</span>] serial queue index : <span class="number">0</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485267</span>] serial queue index : <span class="number">2</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485265</span>] serial queue index : <span class="number">3</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485291</span>] serial queue index : <span class="number">4</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485265</span>] serial queue index : <span class="number">5</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>从输出结果可以看出来，这里的6个任务并不是按顺序执行的。</p>
</blockquote>
<p>需要注意的是：一旦开发者新建了一个串行队列，系统一定会开启一个子线程，所以在使用串行队列的时候，一定只创建真正需要创建的串行队列，避免资源浪费。</p>
<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>将任务追加到并发队列：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)concurrentQueue</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"concurrent queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index ++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"task index %ld in concurrent queue"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484160</span>] task index <span class="number">1</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484159</span>] task index <span class="number">0</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484162</span>] task index <span class="number">2</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484182</span>] task index <span class="number">3</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484183</span>] task index <span class="number">4</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484160</span>] task index <span class="number">5</span> <span class="keyword">in</span> concurrent queue</div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，dispatch_queue_create函数的第二个参数是<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<p>注意，这里追加到并发队列的6个任务并不是按照顺序执行的，符合上面并发队列的定义。</p>
<p>扩展知识：iOS和OSX基于Dispatch Queue中的处理数，CPU核数，以及CPU负荷等当前系统的状态来决定Concurrent Dispatch Queue中并发处理的任务数。</p>
</blockquote>
<h2 id="队列的命名"><a href="#队列的命名" class="headerlink" title="队列的命名"></a>队列的命名</h2><p>现在我们知道dispatch_queue_create方法第一个参数指定了这个新建队列的名称，推荐使用逆序quan cheng全程域名(FQDN,fully qualified domain name)。这个名称可以在Xcode和CrashLog中显示出来，对bug的追踪很有帮助。</p>
<p>在继续讲解之前做个小总结，现在我们知道了：</p>
<ul>
<li>如何创建串行队列和并发队列。</li>
<li>将任务追加到这两种队列里以后的执行效果。</li>
<li>将任务追加到多个串行队列会使这几个任务在不同的线程执行。</li>
</ul>
<p>实际上，系统给我们提供了两种特殊的队列，分别对应串行队列和并发队列：</p>
<h2 id="系统提供的队列"><a href="#系统提供的队列" class="headerlink" title="系统提供的队列"></a>系统提供的队列</h2><h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p>主队列：放在这个队列里的任务会追加到主线程的RunLoop中执行。需要刷新UI的时候我们可以直接获取这个队列，将任务追加到这个队列中。</p>
<h3 id="Globle-Dispatch-Queue"><a href="#Globle-Dispatch-Queue" class="headerlink" title="Globle Dispatch Queue"></a>Globle Dispatch Queue</h3><p>全局并发队列：开发者可以不需要特意通过dispatch_queue_create方法创建一个Concurrent Dispatch Queue，可以将任务直接放在这个全局并发队列里面。</p>
<p>有一个常见的例子可以充分体现二者的使用方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取全局并发队列进行耗时操作 </span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">          <span class="comment">//加载图片</span></div><div class="line">          <span class="built_in">NSData</span> *dataFromURL = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageURL];</div><div class="line">          <span class="built_in">UIImage</span> *imageFromData = [<span class="built_in">UIImage</span> imageWithData:dataFromURL];</div><div class="line"></div><div class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">              <span class="comment">//获取主队列，在图片加载完成后更新UIImageView</span></div><div class="line">              <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:imageFromData];          </div><div class="line">      &#125;);      </div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<h1 id="GCD的各种函数"><a href="#GCD的各种函数" class="headerlink" title="GCD的各种函数"></a>GCD的各种函数</h1><h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><p>这个函数有两个作用：</p>
<ol>
<li>改变队列的优先级。</li>
<li>防止多个串行队列的并发执行。</li>
</ol>
<h3 id="改变队列的优先级"><a href="#改变队列的优先级" class="headerlink" title="改变队列的优先级"></a>改变队列的优先级</h3><p>dispatch_queue_create方法生成的串行队列合并发队列的优先级都是与默认优先级的Globle Dispatch Queue一致。</p>
<p>如果想要变更某个队列的优先级，需要使用dispatch_set_target_queue函数。<br>举个🌰：创建一个在后台执行动作处理的Serial Dispatch Queue<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需求：生成一个后台的串行队列</span></div><div class="line">- (<span class="keyword">void</span>)changePriority</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> bgQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//第一个参数：需要改变优先级的队列；</span></div><div class="line">    <span class="comment">//第二个参数：目标队列</span></div><div class="line">    dispatch_set_target_queue(queue, bgQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="防止多个串行队列的并发执行"><a href="#防止多个串行队列的并发执行" class="headerlink" title="防止多个串行队列的并发执行"></a>防止多个串行队列的并发执行</h3><p>有时，我们将不能并发执行的处理追加到多个Serial Dispatch Queue中时，可以使用dispatch_set_target_queue函数将目标函数定为某个Serial Dispatch Queue，就可以防止这些处理的并发执行。</p>
<p>代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        <span class="comment">//5个串行队列</span></div><div class="line">        <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</div><div class="line">        [array addObject:serial_queue];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">dispatch_queue_t</span> queue, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,idx);</div><div class="line">    &#125;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999714</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999726</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999717</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999715</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999730</span>] 任务<span class="number">4</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到，如果仅仅是将任务追加到5个串行队列中，那么这些任务就会并发执行。</p>
</blockquote>
<p>那接下来看看使用dispatch_set_target_queue方法以后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多个串行队列，设置了target queue</span></div><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="built_in">dispatch_queue_t</span> serial_queue_target = dispatch_queue_create(<span class="string">"queue_target"</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">      </div><div class="line">    <span class="comment">//分别给每个队列设置相同的target queue  </span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</div><div class="line">    dispatch_set_target_queue(serial_queue, serial_queue_target);</div><div class="line">    [array addObject:serial_queue];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">dispatch_queue_t</span> queue, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,idx);</div><div class="line">    &#125;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">4</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>很显然，这些任务就按顺序执行了。</p>
</blockquote>
<h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>dispatch_after解决的问题：某个线程里，在指定的时间后处理某个任务：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"三秒之后追加到队列"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意：不是在3秒之后处理任务，准确来说是3秒之后追加到队列。所以说，如果这个线程的runloop执行1/60秒一次，那么这个block最快会在3秒后执行，最慢会在（3+1/60）秒后执行。而且，如果这个队列本身还有延迟，那么这个block的延迟执行时间会更多。</p>
<h2 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h2><p>如果遇到这样到需求：全部处理完多个预处理任务(block_1 ~ 4)后执行某个任务（block_finish），我们有两个方法：</p>
<ul>
<li>如果预处理任务需要一个接一个的执行：将所有需要先处理完的任务追加到Serial Dispatch Queue中，并在最后追加最后处理的任务(block_finish)。</li>
<li>如果预处理任务需要并发执行：需要使用dispatch_group函数，将这些预处理的block追加到global dispatch queue中。</li>
</ul>
<p>分别详细讲解一下两种需求的实现方式：</p>
<h3 id="预处理任务需要一个接一个的执行："><a href="#预处理任务需要一个接一个的执行：" class="headerlink" title="预处理任务需要一个接一个的执行："></a>预处理任务需要一个接一个的执行：</h3><p>这个需求的实现方式相对简单一点，只要将所有的任务（block_1 ~ 4 + block_finish）放在一个串行队列中即可，因为都是按照顺序执行的，只要不做多余的事情，这些任务就会乖乖地按顺序执行。</p>
<h3 id="预处理任务需要一个接一个的执行：-1"><a href="#预处理任务需要一个接一个的执行：-1" class="headerlink" title="预处理任务需要一个接一个的执行："></a>预处理任务需要一个接一个的执行：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        dispatch_group_async(group, queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,index);</div><div class="line">        &#125;);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">dispatch_group_notify(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后的任务"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057237</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057235</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057234</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057253</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057237</span>] 任务<span class="number">4</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057237</span>] 最后的任务</div></pre></td></tr></table></figure></p>
<p>因为这些预处理任务都是追加到global dispatch queue中的，所以这些任务的执行任务的顺序是不定的。但是最后的任务一定是最后输出的。</p>
<blockquote>
<p>dispatch_group_notify函数监听传入的group中任务的完成，等这些任务全部执行以后，再将第三个参数（block）追加到第二个参数的queue（相同的queue）中。</p>
</blockquote>
<h2 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h2><p>dispatch_group_wait 也是配合dispatch_group 使用的，利用这个函数，我们可以设定group内部所有任务执行完成的超时时间。</p>
<p>一共有两种情况：超时的情况和没有超时的情况：</p>
<h3 id="超时的情况："><a href="#超时的情况：" class="headerlink" title="超时的情况："></a>超时的情况：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_wait_1</div><div class="line">&#123;</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        dispatch_group_async(group, queue, ^&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i ++) &#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">    <span class="keyword">long</span> result = dispatch_group_wait(group, time);</div><div class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"group内部的任务全部结束"</span>);</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"虽然过了超时时间，group还有任务没有完成"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087481</span>] 虽然过了超时时间，group还有任务没有完成，结果是判定为超时</div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087563</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087564</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087579</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087566</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087563</span>] 任务<span class="number">4</span></div></pre></td></tr></table></figure></p>
<h3 id="没有超时的情况："><a href="#没有超时的情况：" class="headerlink" title="没有超时的情况："></a>没有超时的情况：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_wait_2</div><div class="line">&#123;</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        dispatch_group_async(group, queue, ^&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">100000000</span>; i ++) &#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">    <span class="keyword">long</span> result = dispatch_group_wait(group, time);</div><div class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"group内部的任务全部结束"</span>);</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"虽然过了超时时间，group还有任务没有完成"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092079</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092076</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092092</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092077</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092079</span>] 任务<span class="number">4</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3091956</span>] group内部的任务全部结束，在超时的时间以内完成，结果判定为没有超时</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<br>一旦调用dispatch_group_wait以后，当经过了函数中指定的超时时间后 或者 指定的group内的任务全部执行后会返回这个函数的结果：</p>
<ul>
<li>经过了函数中指定的超时时间后，group内部的任务没有全部完成，判定为超时，否则，没有超时</li>
<li>指定的group内的任务全部执行后，经过的时间长于超时时间，判定为超时，否则，没有超时。</li>
</ul>
<p>也就是说：<br>如果指定的超时时间为DISPATCH_TIME_NOW，那么则没有等待，立即判断group内的任务是否完成。</p>
<p>可以看出，指定的超时时间为DISPATCH_TIME_NOW的时候相当于dispatch_group_notify函数的使用：判断group内的任务是否都完成。</p>
</blockquote>
<p>然而dispatch_group_notify函数是作者推荐的，因为通过这个函数可以直接设置最后任务所被追加的队列，使用起来相对比较方便。</p>
<h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p>关于解决数据竞争的方法：读取处理是可以并发的，但是写入处理却是不允许并发执行的。</p>
<p>所以合理的方案是这样的：</p>
<ul>
<li>读取处理追加到concurrent dispatch queue中</li>
<li>写入处理在任何一个读取处理没有执行的状态下，追加到serial dispatch queue中（也就是说，在写入处理结束之前，读取处理不可执行）。</li>
</ul>
<p>我们看看如何使用dispatch_barrier_async来解决这个问题。</p>
<p>为了帮助大家理解，我构思了一个例子：</p>
<ol>
<li>3名董事和总裁开会，在每个人都查看完合同之后，由总裁签字。</li>
<li>总裁签字之后，所有人再审核一次合同。</li>
</ol>
<p>这个需求有三个关键点：</p>
<ul>
<li>关键点1：所有与会人员查看和审核合同，是同时进行的，无序的行为。</li>
<li>关键点2：只有与会人员都查看了合同之后，总裁才能签字。</li>
<li>关键点3:   只有总裁签字之后，才能进行审核。</li>
</ul>
<p>用代码看一下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_barrier</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> meetingQueue = dispatch_queue_create(<span class="string">"com.meeting.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"总裁查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事1查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事2查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事3查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_barrier_async(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"总裁签字"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"总裁审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事1审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事2审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事3审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140315</span>] 总裁查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140296</span>] 董事<span class="number">1</span>查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140297</span>] 董事<span class="number">3</span>查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140299</span>] 董事<span class="number">2</span>查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140299</span>] 总裁签字</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140299</span>] 总裁审核合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140297</span>] 董事<span class="number">1</span>审核合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140296</span>] 董事<span class="number">2</span>审核合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140320</span>] 董事<span class="number">3</span>审核合同</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在这里，我们可以将meetingQueue看成是会议的时间线。总裁签字这个行为相当于写操作，其他都相当于读操作。使用dispatch_barrier_async以后，之前的所有并发任务都会被dispatch_barrier_async里的任务拦截掉，就像函数名称里的“栅栏”一样。</p>
</blockquote>
<p>因此，使用Concurrent Dispatch Queue 和 dispatch_barrier_async 函数可以实现高效率的数据库访问和文件访问。</p>
<h2 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h2><p>到目前为止的所有例子都使用的是异步函数，有异步就一定会有同步，那么现在就来区分一下同步和异步函数的区别：</p>
<ul>
<li>dispatch_async：异步函数，这个函数会立即返回，不做任何等待，它所指定的block“非同步地”追加到指定的队列中。</li>
<li>dispatch_sync：同步函数，这个函数不会立即返回，它会一直等待追加到特定队列中的制定block完成工作后才返回，所以它的目的（也是效果）是阻塞当前线程。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_sync_1</div><div class="line">&#123;</div><div class="line">    <span class="comment">//同步处理</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步处理开始"</span>);</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSInteger</span> num = <span class="number">0</span>;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="comment">//模仿耗时操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i ++) &#123;</div><div class="line">            num++;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"同步处理完毕"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,num);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60800006fa40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] 同步处理开始</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60800006fa40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] 同步处理完毕</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] <span class="number">1000000000</span></div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60800006fa40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div></pre></td></tr></table></figure></p>
<p>在最开始的时候只打印前两行，循环完毕之后才打印后面的内容。<br>因为是同步函数，它阻塞了当前线程（主线程），所以只能等到block内部的任务都结束后，才能打印下面的两行。</p>
<p>但是如果使用异步函数会怎样呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_sync_2</div><div class="line">&#123;</div><div class="line">    <span class="comment">//异步处理</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步处理开始"</span>);</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSInteger</span> num = <span class="number">0</span>;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="comment">//模仿耗时操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i ++) &#123;</div><div class="line">            num++;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"异步处理完毕"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,num);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000071f00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] 异步处理开始</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] <span class="number">0</span></div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000071f00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194280</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x608000260400</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194280</span>] 异步处理完毕</div></pre></td></tr></table></figure></p>
<p>我们可以看到，不同于上面的情况，block下面的两个输出是先打印的（因为没有经过for循环的计算，num的值是0）。因为是异步处理，所以没有等待block中任务的完成就立即返回了。</p>
<p>了解了同步异步的区别之后，我们看一下使用同步函数容易发生的问题：如果给同步函数传入的队列是串行队列的时候就会容易造成死锁。看一下一个死锁的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_sync_3</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码只能输出任务1，并形成死锁。<br>因为任务2被追加到了主队列的最后，所以它需要等待任务3执行完成。<br>但又因为是同步函数，任务3也在等待任务2执行完成。<br>二者互相等待，所以形成了死锁。</p>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><p>通过dispatch_apply函数，我们可以按照指定的次数将block追加到指定的队列中。并等待全部处理执行结束。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_apply_1</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,index);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240332</span>] <span class="number">1</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240331</span>] <span class="number">0</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240334</span>] <span class="number">2</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240332</span>] <span class="number">4</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240334</span>] <span class="number">6</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240331</span>] <span class="number">5</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240332</span>] <span class="number">7</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240334</span>] <span class="number">8</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240331</span>] <span class="number">9</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240259</span>] <span class="number">3</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240259</span>] 完毕</div></pre></td></tr></table></figure>
<p>我们也可以用这个函数来遍历数组，取得下标进行操作:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_apply_2</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,@<span class="number">10</span>,@<span class="number">43</span>,@<span class="number">13</span>,@<span class="number">33</span>];</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array[index]);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244316</span>] <span class="number">10</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244313</span>] <span class="number">1</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244316</span>] <span class="number">33</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244314</span>] <span class="number">43</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244261</span>] <span class="number">13</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244261</span>] 完毕</div></pre></td></tr></table></figure></p>
<p>我们可以看到dispatch_apply函数与dispatch_sync函数同样具有阻塞的作用（dispatch_apply函数返回后才打印完毕）。</p>
<p>我们也可以在dispatch_async函数里执行dispatch_apply函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_apply_3</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,@<span class="number">10</span>,@<span class="number">43</span>,@<span class="number">13</span>,@<span class="number">33</span>];</div><div class="line">        __block  <span class="built_in">NSInteger</span> sum = <span class="number">0</span>;</div><div class="line">    </div><div class="line">        dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line">            <span class="built_in">NSNumber</span> *number = array[index];</div><div class="line">            <span class="built_in">NSInteger</span> num = [number integerValue];</div><div class="line">            sum += num;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="comment">//回到主线程，拿到总和</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,sum);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h2><p>挂起函数调用后对已经执行的处理没有影响，但是追加到队列中但是尚未执行的处理会在此之后停止执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_suspend(queue);</div><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p>通过dispatch_once处理的代码只执行一次，而且是线程安全的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_once_1</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            [<span class="keyword">self</span> onceCode];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)onceCode</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"只执行一次的代码"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">7556</span>:<span class="number">361196</span>] 只执行一次的代码</div></pre></td></tr></table></figure></p>
<p>该函数主要用于单例模式的使用。</p>
<p>到这里终于总结完啦，这本书加深了我对iOS内存管理，block以及GCD的理解，希望我写的这三篇能对您有所帮助～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程：iOS与OS X多线程和内存管理》&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道在iOS开发中，一共有四种多线程技术：pthread，NSThread，GCD，NSOperation：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前两者是面向线程开发的多线程技术，需要开发者自己去维护线程的生命周期，比较繁琐。&lt;/li&gt;
&lt;li&gt;后两者是面向队列开发的多线程技术，开发者仅仅定义想执行的任务追加到适当的Dispatch Queue（队列）中并设置一些优先级，依赖等操作就可以了，其他的事情可以交给系统来做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这一章里，作者主要介绍了GCD技术，它是基于C语言的API，开发者只需要将任务放在block内，并指定好追加的队列，就可以完成多线程开发。&lt;/p&gt;
&lt;p&gt;但是多线程开发时容易发生的一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个线程更新相同的资源：数据竞争。&lt;/li&gt;
&lt;li&gt;多个线程相互持续等待：死锁。&lt;/li&gt;
&lt;li&gt;使用太多的线程导致消耗内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然解决这些问题的代价是会使程序的复杂度上升，但是多线程技术仍然是必须使用的：因为使用多线程编程可以保证应用程序的响应性能。如果耗时操作阻塞了主线程的RunLoop，会导致用户界面无法响应用户的操作，所以必须开启子线程将耗时操作放在子线程中处理。那么我们应该怎么进行多线程开发呢？在讲解之前先看一下本文结构（GCD部分）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程》 干货三部曲&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文的Demo地址：&lt;a href=&quot;https://github.com/knightsj/iOS_Demo/tree/master/%5B12%5D.%20gcd_demo&quot;&gt;knightsj/iOS_Demo/gcd_demo&lt;/a&gt;&lt;br&gt;虽然文章里应给出了详细的输出结果，但还是希望读者可以将demo下载后仔细对照一下代码并体会。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C 高级编程》干货三部曲（二）：Blocks篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/04/17/%E3%80%8AObjective-C%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABlocks%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/04/17/《Objective-C 高级编程》干货三部曲（二）：Blocks篇/</id>
    <published>2017-04-17T00:22:24.000Z</published>
    <updated>2017-04-17T00:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>这一章讲解了Block相关的知识。因为作者将Objective-C的代码转成了C++的代码，所以第一次看的时候非常吃力，我自己也不记得看了多少遍了。</p>
<p>这篇总结不仅仅只有这本书中的内容，还有一点在其他博客里看过的Block的相关知识，并加上了自己的理解，而且文章结构也和原书不太一致，是经过我的整理重新排列出来的。</p>
<p>先看一下本文结构（Blocks部分）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<a id="more"></a>
<h1 id="需要先知道的"><a href="#需要先知道的" class="headerlink" title="需要先知道的"></a>需要先知道的</h1><h2 id="Objective-C-转-C-的方法"><a href="#Objective-C-转-C-的方法" class="headerlink" title="Objective-C 转 C++的方法"></a>Objective-C 转 C++的方法</h2><p>因为需要看Block操作的C++源码，所以需要知道转换的方法，自己转过来看一看：</p>
<ol>
<li>在OC源文件block.m写好代码。</li>
<li>打开终端，cd到block.m所在文件夹。</li>
<li>输入<code>clang -rewrite-objc block.m</code>，就会在当前文件夹内自动生成对应的block.cpp文件。</li>
</ol>
<h2 id="关于几种变量的特点"><a href="#关于几种变量的特点" class="headerlink" title="关于几种变量的特点"></a>关于几种变量的特点</h2><p>c语言的函数中可能使用的变量：</p>
<ul>
<li>函数的参数</li>
<li>自动变量（局部变量）</li>
<li>静态变量（静态局部变量）</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>而且，由于存储区域特殊，这其中有三种变量是可以在任何时候以任何状态调用的：</p>
<ul>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>而其他两种，则是有各自相应的作用域，超过作用域后，会被销毁。</p>
<p>好了，知道了这两点，理解下面的内容就容易一些了。</p>
<h1 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h1><p>先说结论：Block实质是Objective-C对闭包的对象实现，简单说来，Block就是对象。</p>
<p>下面分别从表层到底层来分析一下：</p>
<h2 id="表层分析Block的实质：它是一个类型"><a href="#表层分析Block的实质：它是一个类型" class="headerlink" title="表层分析Block的实质：它是一个类型"></a>表层分析Block的实质：它是一个类型</h2><p>Block是一种类型，一旦使用了Block就相当于生成了可赋值给Block类型变量的值。举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (^blk)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> count)&#123;</div><div class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>等号左侧的代码表示了这个Block的类型：它接受一个int参数，返回一个int值。</li>
<li>等号右侧的代码是这个Block的值：它是等号左侧定义的block类型的一种实现。</li>
</ul>
<p>如果我们在项目中经常使用某种相同类型的block，我们可以用<code>typedef</code>来抽象出这种类型的Block：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^AddOneBlock)(<span class="keyword">int</span> count);</div><div class="line"></div><div class="line">AddOneBlock block = ^(<span class="keyword">int</span> count)&#123;</div><div class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;<span class="comment">//具体实现代码</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样一来，block的赋值和传递就变得相对方便一些了, 因为block的类型已经抽象了出来。</p>
<h2 id="深层分析Block的实质：它是Objective-C对象"><a href="#深层分析Block的实质：它是Objective-C对象" class="headerlink" title="深层分析Block的实质：它是Objective-C对象"></a>深层分析Block的实质：它是Objective-C对象</h2><p>Block其实就是Objective-C对象，因为它的结构体中含有isa指针。</p>
<p>下面将Objective-C的代码转化为C++的代码来看一下block的实现。</p>
<p><strong>OC代码:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        printf(<span class="string">"Block\n"</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>C++代码:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">  <span class="keyword">void</span> *isa;</div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;</div><div class="line">  <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//block结构体</span></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  </div><div class="line">  <span class="comment">//Block构造函数</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;<span class="comment">//isa指针</span></div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//将来被调用的block内部的代码：block值被转换为C的函数代码</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">        printf(<span class="string">"Block\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">    </div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">    </div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="comment">//main 函数</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们看一下从原来的block值（OC代码块）转化而来的C++代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">    printf(<span class="string">"Block\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里，*__cself 是指向Block的值的指针，也就相当于是Block的值它自己（相当于C++里的this，OC里的self）。</p>
<p>而且很容易看出来，<strong>cself 是指向</strong>main_block_impl_0结构体实现的指针。<br>结合上句话，也就是说Block结构体就是<strong>main_block_impl_0结构体。Block的值就是通过</strong>main_block_impl_0构造出来的。</p>
</blockquote>
<p>下面来看一下这个结构体的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  </div><div class="line">  <span class="comment">//构造函数</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看出，__main_block_impl_0结构体有三个部分：</p>
<p>第一个是成员变量impl，它是实际的函数指针，它指向__main_block_func_0。来看一下它的结构体的声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">  <span class="keyword">void</span> *isa;</div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;  <span class="comment">//今后版本升级所需的区域</span></div><div class="line">  <span class="keyword">void</span> *FuncPtr; <span class="comment">//函数指针</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二个是成员变量是指向__main_block_desc_0结构体的Desc指针，是用于描述当前这个block的附加信息的，包括结构体的大小等等信息</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">    </div><div class="line">  size_t reserved;  <span class="comment">//今后升级版本所需区域</span></div><div class="line">  size_t Block_size;<span class="comment">//block的大小</span></div><div class="line">    </div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<p>第三个部分是<strong>main_block_impl_0结构体的构造函数，</strong>main_block_impl_0 就是该 block 的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在这个结构体的构造函数里，isa指针保持这所属类的结构体的实例的指针。__main_block_imlp_0结构体就相当于Objective-C类对象的结构体，这里的_NSConcreteStackBlock相当于Block的结构体实例,<strong>也就是说block其实就是Objective-C对于闭包的对象实现</strong>。</p>
<h1 id="Block截获自动变量和对象"><a href="#Block截获自动变量和对象" class="headerlink" title="Block截获自动变量和对象"></a>Block截获自动变量和对象</h1><h2 id="Block截获自动变量（局部变量）"><a href="#Block截获自动变量（局部变量）" class="headerlink" title="Block截获自动变量（局部变量）"></a>Block截获自动变量（局部变量）</h2><p>使用Block的时候，不仅可以使用其内部的参数，还可以使用Block外部的局部变量。而一旦在Block内部使用了其外部变量，这些变量就会被Block保存。</p>
<p>有趣的是，即使在Block外部修改这些变量，存在于Block内部的这些变量也不会被修改。来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    printf(<span class="string">"%d, %d\n"</span>,a,b);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();<span class="comment">//10 20</span></div><div class="line">    </div><div class="line">a += <span class="number">10</span>;</div><div class="line">b += <span class="number">30</span>;</div><div class="line">    </div><div class="line">printf(<span class="string">"%d, %d\n"</span>,a,b);<span class="comment">//20 50</span></div><div class="line">    </div><div class="line">block();<span class="comment">//10 20</span></div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，在外部修改a，b的值以后，再次调用block时，里面的打印仍然和之前是一样的。给人的感觉是，外部到局部变量和被Block内部截获的变量并不是同一份。</p>
</blockquote>
<p>那如果在内部修改a，b的值会怎么样呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    <span class="comment">//编译不通过</span></div><div class="line">    a = <span class="number">30</span>;</div><div class="line">    b = <span class="number">10</span>;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();</div></pre></td></tr></table></figure>
<p>如果不进行额外操作，局部变量一旦被Block保存，在Block内部就不能被修改了。</p>
<p>但是需要注意的是，这里的修改是指整个变量的赋值操作，变更该对象的操作是允许的，比如在不加上__block修饰符的情况下，给在block内部的可变数组添加对象的操作是可以的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array); <span class="comment">//@[]</span></div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    [array addObject:@<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);<span class="comment">//@[1]</span></div></pre></td></tr></table></figure>
<p>OK，现在我们知道了三点：</p>
<ol>
<li>Block可以截获局部变量。</li>
<li>修改Block外部的局部变量，Block内部被截获的局部变量不受影响。</li>
<li>修改Block内部到局部变量，编译不通过。</li>
</ol>
<p>为了解释2，3点，我们通过C++的代码来看一下Block在截获变量的时候都发生了什么：<br><strong>C代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        printf(fmt,val);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    val = <span class="number">2</span>;</div><div class="line">    fmt = <span class="string">"These values were changed. var = %d\n"</span>;</div><div class="line">    </div><div class="line">    blk();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>C++代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;  <span class="comment">//被添加</span></div><div class="line">  <span class="keyword">int</span> val;          <span class="comment">//被添加</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></div><div class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></div><div class="line"></div><div class="line">        printf(fmt,val);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</div><div class="line"></div><div class="line">    val = <span class="number">2</span>;</div><div class="line">    fmt = <span class="string">"These values were changed. var = %d\n"</span>;</div><div class="line"></div><div class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单独抽取__main_block_impl_0来看一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt; <span class="comment">//截获的自动变量</span></div><div class="line">  <span class="keyword">int</span> val;         <span class="comment">//截获的自动变量</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>我们可以看到，在block内部语法表达式中使用的自动变量（fmt，val）被作为成员变量追加到了__main_block_impl_0结构体中（注意：block没有使用的自动变量不会被追加，如dmy变量）。</li>
<li>在初始化block结构体实例时（请看<strong>main_block_impl_0的构造函数），还需要截获的自动变量fmt和val来初始化</strong>main_block_impl_0结构体实例，因为增加了被截获的自动变量，block的体积会变大。</li>
</ol>
<p>再来看一下函数体的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></div><div class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></div><div class="line">  printf(fmt,val);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>从这里看就更明显了：fmt,var都是从__cself里面获取的，更说明了二者是属于block的。而且从注释来看（注释是由clang自动生成的），这两个变量是值传递，而不是指针传递，也就是说Block仅仅截获自动变量的值，所以这就解释了<strong>即使改变了外部的自动变量的值，也不会影响Block内部的值</strong>。</p>
</blockquote>
<p>那为什么在默认情况下改变Block内部到变量会导致编译不通过呢？<br>我的思考是：既然我们无法在Block中改变外部变量的值，所以也就没有必要在Block内部改变变量的值了，因为Block内部和外部的变量实际上是两种不同的存在：前者是Block内部结构体的一个成员变量，后者是在栈区里的临时变量。</p>
<p>现在我们知道：被截获的自动变量的值是无法直接修改的，但是有两个方法可以解决这个问题：</p>
<ol>
<li>改变存储于特殊存储区域的变量。</li>
<li>通过__block修饰符来改变。</li>
</ol>
<h2 id="1-改变存储于特殊存储区域的变量"><a href="#1-改变存储于特殊存储区域的变量" class="headerlink" title="1. 改变存储于特殊存储区域的变量"></a>1. 改变存储于特殊存储区域的变量</h2><ul>
<li>全局变量，可以直接访问。</li>
<li>静态全局变量，可以直接访问。</li>
<li>静态变量，直接指针引用。</li>
</ul>
<p>我们还是用OC和C++代码的对比看一下具体的实现:</p>
<p><strong>OC代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;<span class="comment">//全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;<span class="comment">//全局静态变量</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;<span class="comment">//静态变量</span></div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        global_val *=<span class="number">1</span>;</div><div class="line">        static_global_val *=<span class="number">2</span>;</div><div class="line">        static_val *=<span class="number">3</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>C++代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">int</span> *static_val;</div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span></div><div class="line"></div><div class="line">  global_val *=<span class="number">1</span>;</div><div class="line">  static_global_val *=<span class="number">2</span>;</div><div class="line">  (*static_val) *=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，</p>
<ul>
<li><p>全局变量和全局静态变量没有被截获到block里面，它们的访问是不经过block的(与__cself无关)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span></div><div class="line"></div><div class="line">  global_val *=<span class="number">1</span>;</div><div class="line">  static_global_val *=<span class="number">2</span>;</div><div class="line">  (*static_val) *=<span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>访问静态变量（static_val）时，将静态变量的指针传递给__main_block_impl_0结构体的构造函数并保存：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">int</span> *static_val;<span class="comment">//是指针，不是值</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>那么有什么方法可以在Block内部给变量赋值呢？– 通过<strong>block关键字。在讲解</strong>block关键字之前，讲解一下Block截获对象：</p>
<h2 id="Block截获对象"><a href="#Block截获对象" class="headerlink" title="Block截获对象"></a>Block截获对象</h2><p>我们看一下在block里截获了array对象的代码，array超过了其作用域存在：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">blk_t blk;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    blk = [^(<span class="keyword">id</span> object)&#123;</div><div class="line">        [array addObject:object];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>,[array count]);</div><div class="line">            </div><div class="line">    &#125; <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">blk([<span class="built_in">NSObject</span> new]);</div><div class="line">blk([<span class="built_in">NSObject</span> new]);</div><div class="line">blk([<span class="built_in">NSObject</span> new]);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">block_demo[<span class="number">28963</span>:<span class="number">1629127</span>] array count = <span class="number">1</span></div><div class="line">block_demo[<span class="number">28963</span>:<span class="number">1629127</span>] array count = <span class="number">2</span></div><div class="line">block_demo[<span class="number">28963</span>:<span class="number">1629127</span>] array count = <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>看一下C++代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">id</span> array;<span class="comment">//截获的对象</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">id</span> _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : array(_array) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，在OC中，C结构体里不能含有被<strong>strong修饰的变量，因为编译器不知道应该何时初始化和废弃C结构体。但是OC的运行时库能够准确把握Block从栈复制到堆，以及堆上的block被废弃的时机，在实现上是通过</strong>main_block_copy_0函数和__main_block_dispose_0函数进行的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;array, (<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其中，_Block_object_assign相当于retain操作，将对象赋值在对象类型的结构体成员变量中。<br>_Block_object_dispose相当于release操作。</p>
</blockquote>
<p>这两个函数调用的时机是在什么时候呢？</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>被调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>__main_block_copy_0</td>
<td>从栈复制到堆时</td>
</tr>
<tr>
<td>__main_block_dispose_0</td>
<td>堆上的Block被废弃时</td>
</tr>
</tbody>
</table>
<p><strong>什么时候栈上的Block会被复制到堆呢？</strong></p>
<ul>
<li>调用block的copy函数时</li>
<li>Block作为函数返回值返回时</li>
<li>将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时</li>
<li>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时</li>
</ul>
<p><strong>什么时候Block被废弃呢？</strong></p>
<p>堆上的Block被释放后，谁都不再持有Block时调用dispose函数。</p>
<p>__weak关键字：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">        <span class="keyword">id</span> __<span class="keyword">weak</span> array2 = array;</div><div class="line">        blk = ^(<span class="keyword">id</span> object)&#123;</div><div class="line">            [array2 addObject:object];</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>,[array2 count]);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    blk([<span class="built_in">NSObject</span> new]);</div><div class="line">    blk([<span class="built_in">NSObject</span> new]);</div><div class="line">    blk([<span class="built_in">NSObject</span> new]);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">block_demo[<span class="number">32084</span>:<span class="number">1704240</span>] array count = <span class="number">0</span></div><div class="line">block_demo[<span class="number">32084</span>:<span class="number">1704240</span>] array count = <span class="number">0</span></div><div class="line">block_demo[<span class="number">32084</span>:<span class="number">1704240</span>] array count = <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>因为array在变量作用域结束时被释放，nil被赋值给了array2中。</p>
<h1 id="block的实现原理"><a href="#block的实现原理" class="headerlink" title="__block的实现原理"></a>__block的实现原理</h1><h2 id="block修饰局部变量"><a href="#block修饰局部变量" class="headerlink" title="__block修饰局部变量"></a>__block修饰局部变量</h2><p>先通过OC代码来看一下给局部变量添加__block关键字后的效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    a -= <span class="number">10</span>;</div><div class="line">    printf(<span class="string">"%d, %d\n"</span>,a,b);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();<span class="comment">//0 20</span></div><div class="line">    </div><div class="line">a += <span class="number">20</span>;</div><div class="line">b += <span class="number">30</span>;</div><div class="line">    </div><div class="line">printf(<span class="string">"%d, %d\n"</span>,a,b);<span class="comment">//20 50</span></div><div class="line">    </div><div class="line">block();/<span class="number">10</span> <span class="number">20</span></div></pre></td></tr></table></figure>
<p>我们可以看到，__block变量在block内部就可以被修改了。</p>
<blockquote>
<p>加上<strong>block之后的变量称之为</strong>block变量，</p>
</blockquote>
<p>先简单说一下<strong>block的作用：
</strong>block说明符用于指定将变量值设置到哪个存储区域中，也就是说，当自动变量加上__block说明符之后，会改变这个自动变量的存储区域。</p>
<p>接下来我们还是用clang工具看一下C++的代码：</p>
<p>OC代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        val = <span class="number">1</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">int</span> val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line"></div><div class="line">        (val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在__main_block_impl_0里面发生了什么呢？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&gt;__main_block_impl_0里面增加了一个成员变量，它是一个结构体指针，指向了 __Block_byref_val_0结构体的一个实例。那么这个结构体是什么呢？</div><div class="line"></div><div class="line">这个结构体是变量val在被__block修饰后生成的！！</div><div class="line">该结构体声明如下：</div><div class="line">```objc</div><div class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">int</span> val;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，这个结构体最后的成员变量就相当于原来自动变量。<br>这里有两个成员变量需要特别注意：</p>
<ol>
<li>val：保存了最初的val变量，也就是说原来单纯的int类型的val变量被__block修饰后生成了一个结构体。这个结构体其中一个成员变量持有原来的val变量。</li>
<li><strong>forwarding：通过</strong>forwarding，可以实现无论<strong>block变量配置在栈上还是堆上都能正确地访问</strong>block变量，也就是说__forwarding是指向自身的。</li>
</ol>
<p>用一张图来直观看一下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-072e7b29e7daf0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"><br>怎么实现的？</p>
<ol>
<li>最初，<strong>block变量在栈上时，它的成员变量</strong>forwarding指向栈上的__block变量结构体实例。</li>
<li>在<strong>block被复制到堆上时，会将</strong>forwarding的值替换为堆上的目标<strong>block变量用结构体实例的地址。而在堆上的目标</strong>block变量自己的__forwarding的值就指向它自己。</li>
</ol>
<p>我们可以看到，这里面增加了指向<strong>Block_byref_val_0结构体实例的指针。这里//by ref这个由clang生成的注释，说明它是通过指针来引用</strong>Block_byref_val_0结构体实例val的。</p>
<p>因此<strong>Block_byref_val_0结构体并不在</strong>main_block_impl_0结构体中，目的是为了使得多个Block中使用__block变量。</p>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk0)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        val = <span class="number">12</span>;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk1)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        val = <span class="number">13</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk0)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_1((<span class="keyword">void</span> *)__main_block_func_1, &amp;__main_block_desc_1_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在main函数里，两个block都引用了__Block_byref_val_0结构体的实例val。</p>
<p>那么__block修饰对象的时候是怎么样的呢？</p>
<h2 id="block修饰对象"><a href="#block修饰对象" class="headerlink" title="__block修饰对象"></a>__block修饰对象</h2><p>__block可以指定任何类型的自动变量。下面来指定id类型的对象:</p>
<p>看一下__block变量的结构体：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __Block_byref_obj_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_obj_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</div><div class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</div><div class="line"> <span class="keyword">id</span> obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>被__strong修饰的id类型或对象类型自动变量的copy和dispose方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</div><div class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</div><div class="line"> _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，当Block持有被__strong修饰的id类型或对象类型自动变量时：</p>
<ul>
<li>如果__block对象变量从栈复制到堆时，使用_Block_object_assign函数，</li>
<li>当堆上的__block对象变量被废弃时，使用_Block_object_dispose函数。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_obj_0 *obj; <span class="comment">// by ref</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_obj_0 *_obj, <span class="keyword">int</span> flags=<span class="number">0</span>) : obj(_obj-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，obj被添加到了<strong>main_block_impl_0结构体中，它是</strong>Block_byref_obj_0类型。</p>
<h1 id="三种Block"><a href="#三种Block" class="headerlink" title="三种Block"></a>三种Block</h1><p>细心的同学会发现，在上面Block的构造函数__main_block_impl_0中的isa指针指向的是&amp;_NSConcreteStackBlock，它表示当前的Block位于栈区中。实际上，一共有三种类型的Block：</p>
<table>
<thead>
<tr>
<th>Block的类</th>
<th>存储域</th>
<th>拷贝效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈拷贝到堆</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody>
</table>
<h2 id="全局Block：-NSConcreteGlobalBlock"><a href="#全局Block：-NSConcreteGlobalBlock" class="headerlink" title="全局Block：_NSConcreteGlobalBlock"></a>全局Block：_NSConcreteGlobalBlock</h2><p>因为全局Block的结构体实例设置在程序的数据存储区，所以可以在程序的任意位置通过指针来访问，它的产生条件：</p>
<ul>
<li>记述全局变量的地方有block语法时。</li>
<li>block不截获的自动变量时。</li>
</ul>
<p>以上两个条件只要满足一个就可以产生全局Block，下面分别用C++来展示一下第一种条件下的全局Block：</p>
<p>c代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(<span class="string">"Global Block\n"</span>);&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    blk();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __blk_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __blk_block_desc_0* Desc;</div><div class="line">  __blk_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __blk_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteGlobalBlock;<span class="comment">//全局</span></div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blk_block_func_0(<span class="keyword">struct</span> __blk_block_impl_0 *__cself) &#123;</div><div class="line">printf(<span class="string">"Global Block\n"</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __blk_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __blk_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __blk_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> __blk_block_impl_0 __global_blk_block_impl_0((<span class="keyword">void</span> *)__blk_block_func_0, &amp;__blk_block_desc_0_DATA);</div><div class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__global_blk_block_impl_0);</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到Block结构体构造函数里面isa指针被赋予的是&amp;_NSConcreteGlobalBlock，说明它是一个全局Block。</p>
</blockquote>
<h2 id="栈Block：-NSConcreteStackBlock"><a href="#栈Block：-NSConcreteStackBlock" class="headerlink" title="栈Block：_NSConcreteStackBlock"></a>栈Block：_NSConcreteStackBlock</h2><p>在生成Block以后，如果这个Block不是全局Block，那么它就是为_NSConcreteStackBlock对象，但是如果其所属的变量作用域名结束，该block就被废弃。在栈上的__block变量也是如此。</p>
<p>但是，如果Block变量和__block变量复制到了堆上以后，则不再会受到变量作用域结束的影响了，因为它变成了堆Block：</p>
<h2 id="堆Block：-NSConcreteMallocBlock"><a href="#堆Block：-NSConcreteMallocBlock" class="headerlink" title="堆Block：_NSConcreteMallocBlock"></a>堆Block：_NSConcreteMallocBlock</h2><blockquote>
<p>将栈block复制到堆以后，block结构体的isa成员变量变成了_NSConcreteMallocBlock。</p>
</blockquote>
<p>其他两个类型的Block在被复制后会发生什么呢？</p>
<table>
<thead>
<tr>
<th>Block类型</th>
<th>存储位置</th>
<th>copy操作的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈拷贝到堆</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody>
</table>
<p>而大多数情况下，编译器会进行判断，自动将block从栈上复制到堆：</p>
<ul>
<li>block作为函数值返回的时候</li>
<li>部分情况下向方法或函数中传递block的时候<ul>
<li>Cocoa框架的方法而且方法名中含有usingBlock等时。</li>
<li>Grand Central Dispatch 的API。</li>
</ul>
</li>
</ul>
<p>除了这两种情况，基本都需要我们手动复制block。</p>
<p>那么__block变量在Block执行copy操作后会发生什么呢？</p>
<ol>
<li>任何一个block被复制到堆上时，__block变量也会一并从栈复制到堆上，并被该Block持有。</li>
<li>如果接着有其他Block被复制到堆上的话，被复制的Block会持有<strong>block变量，并增加</strong>block的引用计数，反过来如果Block被废弃，它所持有的__block也就被释放（不再有block引用它）。</li>
</ol>
<h1 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h1><p>如果在Block内部使用__strong修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有。</p>
<p>所以如果这个对象还同时持有Block的话，就容易发生循环引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    blk_t blk_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,<span class="keyword">self</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>Block blk_t持有self，而self也同时持有作为成员变量的blk_t</p>
<h2 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,weakSelf);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    blk_t blk_;</div><div class="line">    <span class="keyword">id</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj_ = %@"</span>,obj_);<span class="comment">//循环引用警告</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Block语法内的obj<em>截获了self,因为ojb</em>是self的成员变量，因此，block如果想持有obj_，就必须引用先引用self，所以同样会造成循环引用。就好比你如果想去某个商场里的咖啡厅，就需要先知道商场在哪里一样。</p>
<p>如果某个属性用的是weak关键字呢？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"array = %@"</span>,_array);<span class="comment">//循环引用警告</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还是会有循环引用的警告提示，因为循环引用的是self和block之间的事情，这个被Block持有的成员变量是strong还是weak都没有关系,而且即使是基本类型（assign）也是一样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> index;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"index = %ld"</span>,_index);<span class="comment">//循环引用警告</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    __block <span class="keyword">id</span> temp = <span class="keyword">self</span>;<span class="comment">//temp持有self</span></div><div class="line">    </div><div class="line">    <span class="comment">//self持有blk_</span></div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,temp);<span class="comment">//blk_持有temp</span></div><div class="line">        temp = <span class="literal">nil</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)execBlc</div><div class="line">&#123;</div><div class="line">    blk_();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以如果不执行blk_（将temp设为nil），则无法打破这个循环。</p>
<p>一旦执行了blk_，就只有</p>
<ul>
<li>self持有blk_</li>
<li>blk_持有temp</li>
</ul>
<p>使用__block 避免循环比较有什么特点呢？</p>
<ul>
<li>通过__block可以控制对象的持有时间。</li>
<li>为了避免循环引用必须执行block，否则循环引用一直存在。</li>
</ul>
<p>所以我们应该根据实际情况，根据当前Block的用途来决定到底用<strong>block，还是</strong>weak或__unsafe_unretained。</p>
<h1 id="扩展文献："><a href="#扩展文献：" class="headerlink" title="扩展文献："></a>扩展文献：</h1><ol>
<li><a href="http://www.jianshu.com/p/ee9756f3d5f6" target="_blank" rel="external">深入研究Block捕获外部变量和__block实现原理</a></li>
<li><a href="http://www.jianshu.com/p/e03292674e60" target="_blank" rel="external">让我们来深入浅出block吧</a></li>
<li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程：iOS与OS X多线程和内存管理》&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一章讲解了Block相关的知识。因为作者将Objective-C的代码转成了C++的代码，所以第一次看的时候非常吃力，我自己也不记得看了多少遍了。&lt;/p&gt;
&lt;p&gt;这篇总结不仅仅只有这本书中的内容，还有一点在其他博客里看过的Block的相关知识，并加上了自己的理解，而且文章结构也和原书不太一致，是经过我的整理重新排列出来的。&lt;/p&gt;
&lt;p&gt;先看一下本文结构（Blocks部分）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程》 干货三部曲&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C 高级编程》干货三部曲（一）：引用计数篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/04/10/%E3%80%8AObjective-C%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/04/10/《Objective-C 高级编程》干货三部曲（一）：引用计数篇/</id>
    <published>2017-04-10T00:40:50.000Z</published>
    <updated>2017-04-14T04:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结了<a href="http://www.jianshu.com/nb/6074358" target="_blank" rel="external">Effective Objective-C</a>之后，还想读一本进阶的iOS书，毫不犹豫选中了《Objective-C 高级编程》：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>这本书有三个章节，我针对每一章节进行总结并加上适当的扩展分享给大家。可以从下面这张图来看一下这三篇的整体结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<p>注意，这个结构并不和书中的结构一致，而是以书中的结构为参考，稍作了调整。</p>
<p>本篇是第一篇：引用计数，简单说两句：<br>Objective-C通过 retainCount 的机制来决定对象是否需要释放。 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。</p>
<a id="more"></a>
<p>先看一下手动内存管理：</p>
<h1 id="手动内存管理"><a href="#手动内存管理" class="headerlink" title="手动内存管理"></a>手动内存管理</h1><p>我个人觉得，学习一项新的技术之前，需要先了解一下它的核心思想。理解了核心思想之后，对技术点的把握就会更快一些：</p>
<h2 id="内存管理的思想"><a href="#内存管理的思想" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><ul>
<li>思想一：自己生成的对象，自己持有。</li>
<li>思想二：非自己生成的对象，自己也能持有。</li>
<li>思想三：不再需要自己持有的对象时释放对象。</li>
<li>思想四：非自己持有的对象无法释放。</li>
</ul>
<p>从上面的思想来看，我们对对象的操作可以分为三种：生成，持有，释放，再加上废弃，一共有四种。它们所对应的Objective-C的方法和引用计数的变化是：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>Objecctive-C方法</th>
<th>引用计数的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等方法</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain方法</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release方法</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc方法</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>用书中的图来直观感受一下这四种操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-5ced77c57afcfab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>下面开始逐一解释上面的四条思想：</p>
<h3 id="思想一：自己生成的对象，自己持有"><a href="#思想一：自己生成的对象，自己持有" class="headerlink" title="思想一：自己生成的对象，自己持有"></a>思想一：自己生成的对象，自己持有</h3><p>在生成对象时，使用以下面名称开头的方法生成对象以后，就会持有该对象：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<p>这行代码过后，指向生成并持有[[NSObject alloc] init]的指针被赋给了obj，也就是说obj这个指针强引用[[NSObject alloc] init]这个对象。</p>
<p>同样适用于new方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure></p>
<p>注意：<br>这种将持有对象的指针赋给指针变量的情况不只局限于上面这四种方法名称，还包括以他们开头的所有方法名称：</p>
<ul>
<li>allocThisObject</li>
<li>newThatObject</li>
<li>copyThisObject</li>
<li>mutableCopyThatObject</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1 = [obj0 allocObject];<span class="comment">//符合上述命名规则，生成并持有对象</span></div></pre></td></tr></table></figure>
<p>它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)allocObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反过来，如果不符合上述的命名规则，那么就不会持有生成的对象，<br>看一个不符合上述命名规则的返回对象的createObject方法的内部实现🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)createObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    [obj autorelease];<span class="comment">//取得对象，但自己不持有</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>经由这个方法返回以后，无法持有这个返回的对象。因为这里使用了autorelease。autorelease提供了这样一个功能：在对象超出其指定的生存范围时能够自动并正确地释放（详细会在后面介绍）。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-97b23d0108e4cadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>也就是说，生成一个调用方不持有的对象是可以通过autorelease来实现的（例如NSMutableArray的array类方法）。</p>
<p>我的个人理解是：通过autorelease方法，使对象的持有权转移给了自动释放池。所以实现了：调用方拿到了对象，但这个对象还不被调用方所持有。</p>
</blockquote>
<p>由这个不符合命名规则的例子来引出思想二：</p>
<h3 id="思想二：非自己生成的对象，自己也能持有"><a href="#思想二：非自己生成的对象，自己也能持有" class="headerlink" title="思想二：非自己生成的对象，自己也能持有"></a>思想二：非自己生成的对象，自己也能持有</h3><p>我们现在知道，仅仅通过上面那个不符合命名规则的返回对象实例的方法是无法持有对象的。但是我们可以通过某个操作来持有这个返回的对象：这个方法就是通过retain方法来让指针变量持有这个新生成的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里[NSMutableArray array]返回的非自己持有的对象正是通过上文介绍过的autorelease方法实现的。所以如果想持有这个对象，需要执行retain方法才可以。</p>
</blockquote>
<h3 id="思想三：不再需要自己持有的对象时释放对象"><a href="#思想三：不再需要自己持有的对象时释放对象" class="headerlink" title="思想三：不再需要自己持有的对象时释放对象"></a>思想三：不再需要自己持有的对象时释放对象</h3><p>对象的持有者<strong>有义务</strong>在不再需要这个对象的时候<strong>主动</strong>将这个对象释放。注意，是<strong>有义务</strong>，而不是有权利，注意两个词的不同。</p>
<p>来看一下释放对象的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure></p>
<p>同样适用于非自己生成并持有的对象（参考思想二）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj soSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>可能遇到的面试题</strong>：调用对象的release方法会销毁对象吗？<br>答案是不会：调用对象的release方法只是将对象的引用计数器-1，当对象的引用计数器为0的时候会调用了对象的dealloc 方法才能进行释放对象的内存。</p>
</blockquote>
<h3 id="思想四：无法释放非自己持有的对象"><a href="#思想四：无法释放非自己持有的对象" class="headerlink" title="思想四：无法释放非自己持有的对象"></a>思想四：无法释放非自己持有的对象</h3><p>在释放对象的时候，我们只能释放已经持有的对象，非自己持有的对象是不能被自己释放的。这很符合常识：就好比你自己才能从你自己的银行卡里取钱，取别人的卡里的钱是不对的（除非他的钱归你管。。。只是随便举个例子）。</p>
<h4 id="两种不允许的情况："><a href="#两种不允许的情况：" class="headerlink" title="两种不允许的情况："></a>两种不允许的情况：</h4><h4 id="1-释放一个已经废弃了的对象"><a href="#1-释放一个已经废弃了的对象" class="headerlink" title="1.  释放一个已经废弃了的对象"></a>1.  释放一个已经废弃了的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象</span></div><div class="line">[obj release];<span class="comment">//释放该对象，不再持有了</span></div><div class="line">[obj release];<span class="comment">//释放已经废弃了的对象，崩溃</span></div></pre></td></tr></table></figure>
<h4 id="2-释放自己不持有的对象"><a href="#2-释放自己不持有的对象" class="headerlink" title="2. 释放自己不持有的对象"></a>2. 释放自己不持有的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj release];<span class="comment">//释放了非自己持有的对象</span></div></pre></td></tr></table></figure>
<p>思考：哪些情况会使对象失去拥有者呢？</p>
<ol>
<li>将指向某对象的指针变量指向另一个对象。</li>
<li>将指向某对象的指针变量设置为nil。</li>
<li>当程序释放对象的某个拥有者时。</li>
<li>从collection类中删除对象时。</li>
</ol>
<p>现在知道了引用计数式内存管理的四个思想，我们再来看一下四个操作引用计数的方法：</p>
<h2 id="alloc-retain-release-dealloc的实现"><a href="#alloc-retain-release-dealloc的实现" class="headerlink" title="alloc/retain/release/dealloc的实现"></a>alloc/retain/release/dealloc的实现</h2><p>某种意义上，GNUstep 和 Foundation 框架的实现是相似的。所以这本书的作者通过GNUstep的源码来推测了苹果Cocoa框架的实现。</p>
<p>下面开始针对每一个方法，同时用GNUstep和苹果的实现方式（追踪程序的执行和作者的猜测）来对比一下各自的实现。</p>
<h3 id="GNUstep实现："><a href="#GNUstep实现：" class="headerlink" title="GNUstep实现："></a>GNUstep实现：</h3><h4 id="alloc方法"><a href="#alloc方法" class="headerlink" title="alloc方法"></a>alloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m alloc:</span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>) alloc</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span>(<span class="keyword">self</span>, <span class="number">0</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里NSAllocateObject方法分配了对象，看一下它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m NSAllocateObject:</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> obj_layout &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> retained;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">NSAllocateObject</span>(Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = 计算容纳对象所需内存大小;</div><div class="line">    <span class="keyword">id</span> new = <span class="built_in">NSZoneMalloc</span>(zone, <span class="number">1</span>, size);<span class="comment">//返回新的实例</span></div><div class="line">    memset (new, <span class="number">0</span>, size);</div><div class="line">    new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>NSAllocateObject函数通过NSZoneMalloc函数来分配存放对象所需要的内存空间。</li>
<li>obj_layout是用来保存引用计数，并将其写入对象内存头部。</li>
</ol>
</blockquote>
<p>对象的引用计数可以通过retainCount方法来取得：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GNUstep/modules/core/base/Source/<span class="built_in">NSObject</span>.m retainCount:</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></div><div class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> ((obj_layout)anObject)[<span class="number">-1</span>].retained;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，给NSExtraRefCount传入anObject以后，通过访问对象内存头部的.retained变量，来获取引用计数。</p>
<h4 id="retain方法"><a href="#retain方法" class="headerlink" title="retain方法"></a>retain方法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GNUstep/modules/core/base/Source/NSObject.m retain:</div><div class="line"></div><div class="line">- (id)retain</div><div class="line">&#123;</div><div class="line">    NSIncrementExtraRefCount(self);</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">inline void NSIncrementExtraRefCount(id anObject)</div><div class="line">&#123;</div><div class="line">    //retained变量超出最大值,抛出异常</div><div class="line">    if (((obj)anObject)[-1].retained == UINT_MAX - 1)&#123;</div><div class="line">        [NSException raise: NSInternalInconsistencyException</div><div class="line">        format: @"NSIncrementExtraRefCount() asked to increment too far”];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ((obj_layout)anObject)[-1].retained++;//retained变量+1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m release</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的引用计数 = 0，调用dealloc函数</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> dealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的retained值 = 0.则返回yes</span></div><div class="line">    <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果大于0，则-1，并返回NO</span></div><div class="line">    ((obj)anObject)[<span class="number">-1</span>].retained--;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="dealloc方法"><a href="#dealloc方法" class="headerlink" title="dealloc方法"></a>dealloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m dealloc</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    obj_layout o = &amp;((obj_layout)anObject)[<span class="number">-1</span>];</div><div class="line">    free(o);<span class="comment">//释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下上面的几个方法：</p>
<ul>
<li>Objective-C对象中保存着引用计数这一整数值。</li>
<li>调用alloc或者retain方法后，引用计数+1。</li>
<li>调用release后，引用计数-1。</li>
<li>引用计数为0时，调用dealloc方法废弃对象。</li>
</ul>
<p>下面看一下苹果的实现：</p>
<h3 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h3><h4 id="alloc方法-1"><a href="#alloc方法-1" class="headerlink" title="alloc方法"></a>alloc方法</h4><p>通过在NSObject类的alloc类方法上设置断点，我们可以看到执行所调用的函数：</p>
<ul>
<li>+alloc</li>
<li>+allocWithZone:</li>
<li>class_createInstance//生成实例</li>
<li>calloc//分配内存块</li>
</ul>
<p>retainCount:</p>
<ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashGetCountOfKey</li>
</ul>
<h4 id="retain方法-1"><a href="#retain方法-1" class="headerlink" title="retain方法"></a>retain方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashAddValue</li>
</ul>
<h4 id="release方法-1"><a href="#release方法-1" class="headerlink" title="release方法"></a>release方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashRemoveValue</li>
</ul>
<p>我们可以看到他们都调用了一个共同的 __CFdoExternRefOperation 方法。</p>
<p>看一下它的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line"> </div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        count = <span class="built_in">CFBasicHashAddValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，__CFDoExternRefOperation通过switch语句 针对不同的操作来进行具体的方法调用，如果 op 是 OPERATION_retain，就去掉用具体实现 retain 的方法，以此类推。</p>
<p>可以猜想上层的retainCount,retain,release方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">NSUInteger</span>)____CFDoExternRefOperation(OPERATION_retainCount,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_retain,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这里返回值应该是id，原书这里应该是错了</span></div><div class="line">- (<span class="keyword">id</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_release,<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们观察一下switch里面每个语句里的执行函数名称，似乎和散列表（Hash）有关，这说明苹果对引用计数的管理应该是通过散列表来执行的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-46b607c905f2355d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>在这张表里，key为内存块地址，而对应的值为引用计数。也就是说，它保存了这样的信息：一些被引用的内存块各自对应的引用计数。</p>
<p>那么使用散列表来管理内存有什么好处呢？</p>
<p>因为计数表保存内存块地址，我们就可以通过这张表来：</p>
<ul>
<li>确认损坏内存块的位置。</li>
<li>在检测内存泄漏时，可以查看各对象的持有者是否存在。</li>
</ul>
<h2 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h2><h3 id="autorelease-介绍"><a href="#autorelease-介绍" class="headerlink" title="autorelease 介绍"></a>autorelease 介绍</h3><p>当对象超出其作用域时，对象实例的release方法就会被调用，autorelease的具体使用方法如下：</p>
<ol>
<li>生成并持有NSAutoreleasePool对象。</li>
<li>调用已分配对象的autorelease方法。</li>
<li>废弃NSAutoreleasePool对象。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-e4e905eeda890869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所有调用过autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release方法（引用计数-1）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];<span class="comment">//相当于obj调用release方法</span></div></pre></td></tr></table></figure></p>
<p>NSRunLoop在每次循环过程中，NSAutoreleasePool对象都会被生成或废弃。<br>也就是说，如果有大量的autorelease变量，在NSAutoreleasePool对象废弃之前（一旦监听到RunLoop即将进入睡眠等待状态，就释放NSAutoreleasePool），都不会被销毁，容易导致内存激增的问题:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0a9bf49d47a0e3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>因此，我们有必要在适当的时候再嵌套一个自动释放池来管理临时生成的autorelease变量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//临时pool</span></div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">    [pool drain];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-157c469ad6fff139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>可能会出的面试题：什么时候会创建自动释放池？<br>答：运行循环检测到事件并启动后，就会创建自动释放池，而且子线程的 runloop 默认是不工作的，无法主动创建，必须手动创建。<br>举个🌰：<br>自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则在出了作用域以后，自动释放对象会因为没有自动释放池去处理自己而造成内存泄露。</p>
</blockquote>
<h3 id="autorelease实现"><a href="#autorelease实现" class="headerlink" title="autorelease实现"></a>autorelease实现</h3><p>和上文一样，我们还是通过GNUstep和苹果的实现来分别看一下。</p>
<h4 id="GNUstep-实现"><a href="#GNUstep-实现" class="headerlink" title="GNUstep 实现"></a>GNUstep 实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m autorelease</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)autorelease</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果调用NSObject类的autorelease方法，则该对象就会被追加到正在使用的NSAutoreleasePool对象中的数组里（作者假想了一个简化的源代码）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSAutoreleasePool.m addObject</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = 取得正在使用的<span class="built_in">NSAutoreleasePool</span>对象</div><div class="line">    <span class="keyword">if</span> (pool != <span class="literal">nil</span>)&#123;</div><div class="line">        [pool addObject:anObj];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSAutoreleasePool对象不存在"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    [pool.array addObject:anObj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法，然后这个对象就被追加到正在使用的NSAutoreleasePool对象中的数组里。</p>
<p>再来看一下NSAutoreleasePool的drain方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drain</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> dealloc];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> emptyPool];</div><div class="line">    [array release];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)emptyPool</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">id</span> obj <span class="keyword">in</span> array)&#123;</div><div class="line">        [obj release];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在emptyPool方法里，确实是对数组里每一个对象进行了release操作。</p>
<h4 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>我们可以通过objc4/NSObject.mm来确认苹果中autorelease的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">objc4/<span class="built_in">NSObject</span>.mm AutoreleasePoolPage</div><div class="line"> </div><div class="line"><span class="keyword">class</span> AutoreleasePoolPage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//生成或者持有 NSAutoreleasePool 类对象</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//废弃 NSAutoreleasePool 类对象</span></div><div class="line">        releaseAll();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//相当于 NSAutoreleasePool 类的 addObject 类方法</span></div><div class="line">        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;</div><div class="line">       autoreleaesPoolPage-&gt;add(obj)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</div><div class="line">    &#123;   </div><div class="line">        <span class="comment">//将对象追加到内部数组中</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> releaseAll()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//调用内部数组中对象的 release 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//压栈</span></div><div class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//出栈</span></div><div class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看一下外部的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPush</span></div><div class="line"> </div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">// 等同于 objc_autorelease(obj)</span></div><div class="line"> </div><div class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</div><div class="line"><span class="comment">// 查看 NSAutoreleasePool 状况</span></div><div class="line"> </div><div class="line">[pool drain];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPop(pool)</span></div></pre></td></tr></table></figure>
<p>看函数名就可以知道，对autorelease分别执行push、pop操作。销毁对象时执行release操作。</p>
<blockquote>
<p><strong>可能出现的面试题：苹果是如何实现autoreleasepool的？</strong><br>autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成.<br>•    objc_autoreleasepoolPush（压入）<br>•    objc_autoreleasepoolPop（弹出）<br>•    objc_autorelease（释放内部）</p>
</blockquote>
<h1 id="ARC内存管理"><a href="#ARC内存管理" class="headerlink" title="ARC内存管理"></a>ARC内存管理</h1><h2 id="内存管理的思想-1"><a href="#内存管理的思想-1" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><p>上面学习了非ARC机制下的手动管理内存思想，针对引用计数的操作和自动释放池的相关内容。现在学习一下在ARC机制下的相关知识。</p>
<p>ARC和非ARC机制下的内存管理思想是一致的：</p>
<ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放对象。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<p>在ARC机制下，编译器就可以自动进行内存管理，减少了开发的工作量。但我们有时仍需要四种所有权修饰符来配合ARC来进行内存管理</p>
<h2 id="四种所有权修饰符"><a href="#四种所有权修饰符" class="headerlink" title="四种所有权修饰符"></a>四种所有权修饰符</h2><p>但是，在ARC机制下我们有的时候需要追加所有权声明(以下内容摘自官方文档)：</p>
<ul>
<li><strong>__strong</strong>：is the default. An object remains “alive” as long as there is a strong pointer to it.</li>
<li><strong>__weak</strong>：specifies a reference that does not keep the referenced object alive. A weak reference is set to nil when there are no strong references to the object.</li>
<li><strong>__unsafe_unretained</strong>：specifies a reference that does not keep the referenced object alive and is not set to nil when there are no strong references to the object. If the object it references is deallocated, the pointer is left dangling.</li>
<li><strong>__autoreleasing</strong>：is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</li>
</ul>
<p>下面分别讲解一下这几个修饰符：</p>
<h3 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h3><p>__strong修饰符 是id类型和对象类型默认的所有权修饰符：</p>
<h4 id="strong使用方法："><a href="#strong使用方法：" class="headerlink" title="__strong使用方法："></a>__strong使用方法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>等同于：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure></p>
<p>看一下内存管理的过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//obj超出其作用域，强引用失效</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>__strong修饰符表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃。</p>
</blockquote>
<p>在__strong修饰符修饰的变量之间相互赋值的情况：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj0 持有对象A</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj1 持有对象B</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj2 = <span class="literal">nil</span>;<span class="comment">//ojb2不持有任何对象</span></div><div class="line">obj0 = obj1;<span class="comment">//obj0强引用对象B；而对象A不再被ojb0引用，被废弃</span></div><div class="line">obj2 = obj0;<span class="comment">//obj2强引用对象B（现在obj0，ojb1，obj2都强引用对象B）</span></div><div class="line">obj1 = <span class="literal">nil</span>;<span class="comment">//obj1不再强引用对象B</span></div><div class="line">obj0 = <span class="literal">nil</span>;<span class="comment">//obj0不再强引用对象B</span></div><div class="line">obj2 = <span class="literal">nil</span>;<span class="comment">//obj2不再强引用对象B，不再有任何强引用引用对象B，对象B被废弃</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>而且，<strong>strong可以使一个变量初始化为nil：id </strong>strong obj0;<br>同样适用于：id <strong>weak obj1; id </strong>autoreleasing obj2;</p>
</blockquote>
<p>做个总结：被__strong修饰后，相当于强引用某个对象。对象一旦有一个强引用引用自己，引用计数就会+1，就不会被系统废弃。而这个对象如果不再被强引用的话，就会被系统废弃。</p>
<h4 id="strong内部实现："><a href="#strong内部实现：" class="headerlink" title="__strong内部实现："></a>__strong内部实现：</h4><p>生成并持有对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_mesgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(init));</div><div class="line">objc_release(obj);<span class="comment">//超出作用域，释放对象</span></div></pre></td></tr></table></figure></p>
<p>再看一下使用命名规则以外的构造方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>objc_retainAutoreleasedReturnValue的作用：持有对象，将对象注册到autoreleasepool并返回。</p>
</blockquote>
<p>同样也有objc_autoreleaseReturnValue，来看一下它的使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">   objc_msgSend(obj,, <span class="keyword">@selector</span>(init));</div><div class="line">   <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>objc_autoreleaseReturnValue:返回注册到autoreleasepool的对象。</p>
</blockquote>
<h3 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h3><h4 id="weak使用方法："><a href="#weak使用方法：" class="headerlink" title="__weak使用方法："></a>__weak使用方法：</h4><p>__weak修饰符大多解决的是循环引用的问题：如果两个对象都互相强引用对方，同时都失去了外部对自己的引用，那么就会形成“孤岛”，这个孤岛将永远无法被释放，举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj</div><div class="line">&#123;</div><div class="line">    obj_ = obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];<span class="comment">//test0强引用对象A</span></div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];<span class="comment">//test1强引用对象B</span></div><div class="line">    [test0 setObject:test1];<span class="comment">//test0强引用对象B</span></div><div class="line">    [test1 setObject:test0];<span class="comment">//test1强引用对象A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为生成对象（第一，第二行）和set方法（第三，第四行）都是强引用，所以会造成两个对象互相强引用对方的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f2164aea2490deac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所以，我们需要打破其中一种强引用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj_;<span class="comment">//由__strong变成了__weak</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这样一来，二者就只是弱引用对方了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-98777f8ef5bbfc13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<h4 id="weak内部实现"><a href="#weak内部实现" class="headerlink" title="__weak内部实现"></a>__weak内部实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1;</div><div class="line">objc_initWeak(&amp;obj1,obj);<span class="comment">//初始化附有__weak的变量</span></div><div class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj1);<span class="comment">//取出附有__weak修饰符变量所引用的对象并retain</span></div><div class="line">objc_autorelease(tmp);<span class="comment">//将对象注册到autoreleasepool中</span></div><div class="line">objc_destroyWeak(&amp;obj1);<span class="comment">//释放附有__weak的变量</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这确认了<strong>weak的一个功能：使用附有</strong>weak修饰符的变量，即是使用注册到autoreleasepool中的对象。</p>
</blockquote>
<p>这里需要着重讲解一下objc_initWeak方法和objc_destroyWeak方法：</p>
<ul>
<li>objc_initWeak:初始化附有__weak的变量，具体通过执行objc_strongWeak(&amp;obj1, obj)方法，将obj对象以&amp;obj1作为key放入一个weak表（Hash）中。</li>
<li>objc_destroyWeak：释放附有__weak的变量。具体通过执行objc_storeWeak(&amp;obj1,0)方法，在weak表中查询&amp;obj1这个键，将这个键从weak表中删除。</li>
</ul>
<blockquote>
<p>注意：因为同一个对象可以赋值给多个附有__weak的变量中，所以对于同一个键值，可以注册多个变量的地址。</p>
</blockquote>
<p>当一个对象不再被任何人持有，则需要释放它，过程为：</p>
<ul>
<li>objc_dealloc</li>
<li>dealloc</li>
<li>_objc_rootDealloc</li>
<li>objc_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating<ul>
<li>从weak表中获取废弃对象的地址</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址</li>
</ul>
</li>
</ul>
<h3 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h3><h4 id="autoreleasing使用方法"><a href="#autoreleasing使用方法" class="headerlink" title="__autoreleasing使用方法"></a>__autoreleasing使用方法</h4><p>ARC下，可以用@autoreleasepool来替代NSAutoreleasePool类对象，用__autoreleasing修饰符修饰变量来替代ARC无效时调用对象的autorelease方法（对象被注册到autoreleasepool）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6dcb0d1fd878deeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>说到<strong>autoreleasing修饰符，就不得不提</strong>weak：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>  __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[obj1 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>等同于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="keyword">id</span> __autoreleasing tmp = obj1;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[tmp <span class="keyword">class</span>]);<span class="comment">//实际访问的是注册到自动个释放池的对象</span></div></pre></td></tr></table></figure>
<p>注意一下两段等效的代码里，NSLog语句里面访问的对象是不一样的，它说明：在访问__weak修饰符的变量（obj1）时必须访问注册到autoreleasepool的对象（tmp）。为什么呢？</p>
<p>因为__weak修饰符只持有对象的弱引用，也就是说在将来访问这个对象的时候，无法保证它是否还没有被废弃。因此，如果把这个对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。</p>
<h4 id="autoreleasing内部实现"><a href="#autoreleasing内部实现" class="headerlink" title="__autoreleasing内部实现"></a>__autoreleasing内部实现</h4><p>将对象赋值给附有__autoreleasing修饰符的变量等同于ARC无效时调用对象的autorelease方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">    <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();<span class="comment">//pool入栈</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">objc_autorelease(obj);</div><div class="line">objc_autoreleasePoolPop(pool);<span class="comment">//pool出栈</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们可以看到pool入栈，执行autorelease，出栈的三个方法。</p>
</blockquote>
<h2 id="ARC下的规则"><a href="#ARC下的规则" class="headerlink" title="ARC下的规则"></a>ARC下的规则</h2><p>我们知道了在ARC机制下编译器会帮助我们管理内存，但是在编译期，我们还是要遵守一些规则，作者为我们列出了以下的规则：</p>
<ol>
<li>不能使用retain/release/retainCount/autorelease</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>必须遵守内存管理的方法名规则</li>
<li>不要显式调用dealloc</li>
<li>使用@autorelease块代替NSAutoreleasePool</li>
<li>不能使用区域（NSZone）</li>
<li>对象型变量不能作为C语言结构体的成员</li>
<li>显式转换id和void*</li>
</ol>
<h3 id="1-不能使用retain-release-retainCount-autorelease"><a href="#1-不能使用retain-release-retainCount-autorelease" class="headerlink" title="1. 不能使用retain/release/retainCount/autorelease"></a>1. 不能使用retain/release/retainCount/autorelease</h3><p>在ARC机制下使用retain/release/retainCount/autorelease方法，会导致编译器报错。</p>
<h3 id="2-不能使用NSAllocateObject-NSDeallocateObject"><a href="#2-不能使用NSAllocateObject-NSDeallocateObject" class="headerlink" title="2. 不能使用NSAllocateObject/NSDeallocateObject"></a>2. 不能使用NSAllocateObject/NSDeallocateObject</h3><p>在ARC机制下使用NSAllocateObject/NSDeallocateObject方法，会导致编译器报错。</p>
<h3 id="3-必须遵守内存管理的方法名规则"><a href="#3-必须遵守内存管理的方法名规则" class="headerlink" title="3. 必须遵守内存管理的方法名规则"></a>3. 必须遵守内存管理的方法名规则</h3><p>对象的生成／持有的方法必须遵循以下命名规则：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
<li>init</li>
</ul>
<p>前四种方法已经介绍完。而关于init方法的要求则更为严格：</p>
<ul>
<li>必须是实例方法</li>
<li>必须返回对象</li>
<li>返回对象的类型必须是id类型或方法声明类的对象类型</li>
</ul>
<h3 id="4-不要显式调用dealloc"><a href="#4-不要显式调用dealloc" class="headerlink" title="4. 不要显式调用dealloc"></a>4. 不要显式调用dealloc</h3><p>对象被废弃时，无论ARC是否有效，系统都会调用对象的dealloc方法。</p>
<p>我们只能在dealloc方法里写一些对象被废弃时需要进行的操作（例如移除已经注册的观察者对象）但是不能手动调用dealloc方法。</p>
<p>注意在ARC无效的时候，还需要调用[super dealloc]：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">//该对象的处理</span></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-使用-autorelease块代替NSAutoreleasePool"><a href="#5-使用-autorelease块代替NSAutoreleasePool" class="headerlink" title="5. 使用@autorelease块代替NSAutoreleasePool"></a>5. 使用@autorelease块代替NSAutoreleasePool</h3><p>ARC下须使用使用@autorelease块代替NSAutoreleasePool。</p>
<h3 id="6-不能使用区域（NSZone）"><a href="#6-不能使用区域（NSZone）" class="headerlink" title="6. 不能使用区域（NSZone）"></a>6. 不能使用区域（NSZone）</h3><p>NSZone已经在目前的运行时系统（<strong>OBC2</strong>被设定的环境）被忽略了。</p>
<h3 id="7-对象型变量不能作为C语言结构体的成员"><a href="#7-对象型变量不能作为C语言结构体的成员" class="headerlink" title="7. 对象型变量不能作为C语言结构体的成员"></a>7. 对象型变量不能作为C语言结构体的成员</h3><p>C语言的结构体如果存在Objective-C对象型变量，便会引起错误，因为C语言在规约上没有方法来管理结构体成员的生存周期 。</p>
<h3 id="8-显式转换id和void"><a href="#8-显式转换id和void" class="headerlink" title="8. 显式转换id和void*"></a>8. 显式转换id和void*</h3><p>非ARC下，这两个类型是可以直接赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj = [NSObject alloc] init];</div><div class="line">void *p = obj;</div><div class="line">id o = p;</div></pre></td></tr></table></figure>
<p>但是在ARC下就会引起编译错误。为了避免错误，我们需要通过__bridege来转换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span>*)obj;<span class="comment">//显式转换</span></div><div class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;<span class="comment">//显式转换</span></div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>来看一下属性的声明与所有权修饰符的关系</p>
<table>
<thead>
<tr>
<th>属性关键字</th>
<th>所有权 修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
</tbody>
</table>
<p>说一下<strong>unsafe_unretained：
</strong>unsafe_unretained表示存取方法会直接为实例变量赋值。</p>
<p>这里的“unsafe”是相对于weak而言的。我们知道weak指向的对象被销毁时，指针会自动设置为nil。而__unsafe_unretained却不会，而是成为空指针。需要注意的是：当处理非对象属性的时候就不会出现空指针的问题。</p>
<p>这样第一章就介绍完了，第二篇会在下周一发布^^</p>
<hr>
<p>扩展文献：</p>
<ol>
<li><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Apple:Transitioning to ARC Release Notes</a> </li>
<li><a href="http://www.jianshu.com/p/6cf682f90fa2" target="_blank" rel="external">蚊香酱:可能是史上最全面的内存管理文章</a></li>
<li><a href="http://www.jianshu.com/p/0ad9957e3716" target="_blank" rel="external">微笑和飞飞:可能碰到的iOS笔试面试题（6）–内存管理</a></li>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00RWORA1O/ref=sr_1_1?ie=UTF8&amp;qid=1491531635&amp;sr=8-1&amp;keywords=ios%E7%BC%96%E7%A8%8B" target="_blank" rel="external">《iOS编程(第4版)》</a> </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了&lt;a href=&quot;http://www.jianshu.com/nb/6074358&quot;&gt;Effective Objective-C&lt;/a&gt;之后，还想读一本进阶的iOS书，毫不犹豫选中了《Objective-C 高级编程》：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程：iOS与OS X多线程和内存管理》&quot;&gt;&lt;/p&gt;
&lt;p&gt;这本书有三个章节，我针对每一章节进行总结并加上适当的扩展分享给大家。可以从下面这张图来看一下这三篇的整体结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程》 干货三部曲&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，这个结构并不和书中的结构一致，而是以书中的结构为参考，稍作了调整。&lt;/p&gt;
&lt;p&gt;本篇是第一篇：引用计数，简单说两句：&lt;br&gt;Objective-C通过 retainCount 的机制来决定对象是否需要释放。 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>基于MVVM，用于快速搭建设置页，个人信息页的框架</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/03/20/%E5%9F%BA%E4%BA%8EMVVM%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%AE%BE%E7%BD%AE%E9%A1%B5%EF%BC%8C%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E9%A1%B5%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%88%E9%99%84%EF%BC%9A%E4%BB%BF%E5%BE%AE%E4%BF%A1iOS%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E7%8E%B0%E9%A1%B5%EF%BC%8C%E4%B8%AA%E4%BA%BA%E9%A1%B5%EF%BC%8C%E8%AE%BE%E7%BD%AE%E9%A1%B5Demo%EF%BC%89/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/03/20/基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）/</id>
    <published>2017-03-20T05:47:51.000Z</published>
    <updated>2017-05-15T00:13:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h3><p><strong>2017.4.23：新增支持数据源完全依赖网络请求的情况。</strong><br><strong>2017.4.22：新增支持请求新数据后刷新表格。</strong><br><strong>2017.4.21： 新增CocoaPods支持：pod ‘SJStaticTableView’, ‘~&gt; 1.2.0’。</strong></p>
<hr>
<p>写一个小小轮子～</p>
<p>写UITableView的时候，我们经常遇到的是完全依赖于网络请求，需要自定义的动态cell的需求（比如微博帖子列表）。但是同时，大多数app里面几乎也都有设置页，个人页等其他以静态表格为主的页面。</p>
<p>而且这些页面的共性比较多：</p>
<ol>
<li>大多数情况下在进入页面之前就已经拿到所有数据。</li>
<li>cell样式单一，自定义cell出现的几率比较小（几乎都是高度为44的cell）。</li>
<li>多数都分组。</li>
</ol>
<p>因为自己非常想写一个开源的东西出来（也可以暴露自己的不足），同时又受限于水平，所以就打算写这么一个比较简单，又具有通用性的框架：<strong>一个定制性比较高的适合在个人页和设置页使用的UITableView</strong>。</p>
<p>在真正写之前，看了几篇类似的文章，挑出三篇自己觉得比较好的：</p>
<ol>
<li><a href="https://www.objc.io/issues/1-view-controllers/table-views/" target="_blank" rel="external">Clean Table View Code</a> </li>
<li><a href="http://www.jianshu.com/p/504c61a9dc82" target="_blank" rel="external">如何写好一个UITableView</a></li>
<li><a href="http://www.jianshu.com/p/81d0c573f7a8" target="_blank" rel="external">利用MVVM设计快速开发个人中心、设置等模块</a></li>
</ol>
<p>看完总结之后，利用上周3天的业余时间写好了这个框架，为了它实用性，我仿照了微信客户端的发现页，个人页和设置页写了一个Demo，来看一下效果图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/85789de80b62c93ff0c9f77b603dba70" alt="发现页 | 个人页 | 个人信息页 | 设置页"></p>
<blockquote>
<p>项目所用资源来自：<a href="https://github.com/zhengwenming/WeChat">GitHub:zhengwenming/WeChat</a><br>Demo地址：<a href="https://github.com/knightsj/SJStaticTableView">GitHub: knightsj/SJStaticTableView</a></p>
</blockquote>
<a id="more"></a>
<p>为了体现出这个框架的定制性，我自己也在里面添加了两个页面，入口在设置页里面：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/a38f9f8459fbd168e3f434e5cff27526" alt="分组定制 | 同组定制"></p>
<blockquote>
<p>先不要纠结分组定制和同组定制的具体意思，在后面讲到定制性的时候我会详细说明。现在只是让大家看一下效果。</p>
</blockquote>
<p>在大概了解了功能之后，开始详细介绍这个框架。写这篇介绍的原因倒不是希望有多少人来用，而是表达一下我自己的思路而已。各位觉得不好的地方请多批评。</p>
<p>在正式讲解之前，先介绍一下本篇的基本目录：</p>
<ol>
<li>用到的技术点。</li>
<li>功能说明。</li>
<li>使用方法。</li>
<li>定制性介绍。</li>
<li>新增支持刷新功能。</li>
<li>新增支持数据源完全依赖网络请求。</li>
</ol>
<h1 id="1-用到的技术点"><a href="#1-用到的技术点" class="headerlink" title="1. 用到的技术点"></a>1. 用到的技术点</h1><hr>
<p>框架整体来说还是比较简单的，主要还是基于苹果的<code>UITableView</code>组件，为了解耦和责任分离，主要运用了以下技术点：</p>
<ul>
<li><strong>MVVM</strong>：采用MVVM架构，将每一行“纯粹”的数据交给一个单独的<code>ViewModel</code>,让其持有每个cell的数据（行高，cell类型，文本宽度，图片高度等等）。而且每一个section也对应一个<code>ViewModel</code>，它持有当前section的配置数据（title，header和footer的高度等等）。</li>
<li><strong>轻UIViewController</strong>：分离<code>UITableViewDataSource</code>与<code>UIViewController</code>，让单独一个类来实现<code>UITableViewDataSource</code>的职能。</li>
<li><strong>block</strong>：使用block来调用cell的绘制方法。</li>
<li><strong>分类</strong>：使用分类来定义每一种不同的cell的绘制方法。</li>
</ul>
<p>知道了主要运用的技术点以后，给大家详细介绍一下该框架的功能。</p>
<h1 id="2-功能介绍"><a href="#2-功能介绍" class="headerlink" title="2. 功能介绍"></a>2. 功能介绍</h1><hr>
<p>这个框架可以用来快速搭建设置页，个人信息页能静态表格页面，使用者只需要给tableView的DataSource传入元素是viewModel的数组就可以了。</p>
<p>虽说这类页面的布局还是比较单一的，但是还是会有几种不同的情况（cell的布局类型），我对比较常见的cell布局做了封装，使用者可以直接使用。</p>
<p>我在定义这些cell的类型的时候，大致划分了两类：</p>
<ol>
<li>第一类是系统风格的cell，大多数情况下，cell高度为44；在cell左侧会有一张图，一个label，也可以只存在一种（但是只存在图片的情况很少）；在cell右侧一般都有一个向右的箭头，而且有时这个箭头的左侧还可能有label，image，也可以两个都有。</li>
<li>第二类就是自定义的cell了，它的高度不一定是44，而且布局和系统风格的cell很不一样，需要用户自己添加。</li>
</ol>
<p>基于这两大类，再细分了几种情况，可以由下面这张图来直观看一下：</p>
<p>既然是cell的类型，那么就类型的枚举就需要定义在cell的viewModel里面：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SJStaticCellType) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//系统风格的各种cell类型，已封装好，可以直接用</span></div><div class="line">    SJStaticCellTypeSystemLogout,                          <span class="comment">//退出登录cell</span></div><div class="line">    SJStaticCellTypeSystemAccessoryNone,                   <span class="comment">//右侧没有任何控件</span></div><div class="line">    SJStaticCellTypeSystemAccessorySwitch,                 <span class="comment">//右侧是开关</span></div><div class="line">    SJStaticCellTypeSystemAccessoryDisclosureIndicator,    <span class="comment">//右侧是三角箭头(箭头左侧可以有一个image或者一个label，或者二者都有，根据传入的参数决定)</span></div><div class="line">    </div><div class="line">    <span class="comment">//需要用户自己添加的自定义cell类型</span></div><div class="line">    SJStaticCellTypeMeAvatar,                              <span class="comment">//个人页“我”cell    </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>来一张图直观得体会一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/1f8db817518311481d64d30ec481cf71" alt="支持cell类型"></p>
<p>在这里有三点需要说一下：</p>
<ol>
<li>这里面除了自定义的cell以外，其他类型的cell都不需要开发者自己布局，都已经被我封装好，只需要在cell的<code>ViewModel</code>里面传入相应的类型和数据（文字，图片）即可。</li>
<li>因为左侧的两个控件（图片和文字）是至少存在一个而且左右顺序固定（图片永远在最左侧），所以该框架通过开发者传入的左侧需要显示的图片和文字，可以自己进行cell的布局。所以类型的判断主要作用于cell的右侧。</li>
<li>值得一提的是，在”最右侧是一个箭头”子分支的五个类型其实都属于一个类型，只需要传入文字和图片，以及文字图片的显示顺序参数（这个参数只在同时存在图片和文字的时候有效）就可以自行判断布局。</li>
</ol>
<p>在了解了该框架的功能之后，我们先看一下如何使用这个框架：</p>
<h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><hr>
<h2 id="集成方法："><a href="#集成方法：" class="headerlink" title="集成方法："></a>集成方法：</h2><ol>
<li>静态：手动将SJStaticTableViewComponent文件夹拖入到工程中。</li>
<li>动态：CocoaPods：<code>pod &#39;SJStaticTableView&#39;, &#39;~&gt; 1.1.2</code>。</li>
</ol>
<p>具体的方法先用文字说明一下：</p>
<ol>
<li>将要开发的页面的ViewController继承<code>SJStaticTableViewController</code>。</li>
<li>在新ViewController里实现<code>createDataSource</code>方法，将viewModel数组传给控制器的<code>dataSource</code>属性。</li>
<li>根据不同的cell类型，调用不同的cell绘制方法。</li>
<li>如果需要接受cell的点击，需要实现<code>didSelectViewModel</code>方法。</li>
</ol>
<p>可能感觉比较抽象，我拿设置页来具体说明一下：</p>
<p>先看一下设置页的布局：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/d1ea6240a3760acbcb92198f1c454044" alt="设置页"></p>
<p>然后我们看一下设置的ViewController的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.navigationItem.title = <span class="string">@"设置"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createDataSource</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.dataSource = [[SJStaticTableViewDataSource alloc] initWithViewModelsArray:[Factory settingPageData] configureBlock:^(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel *viewModel) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">switch</span> (viewModel.staticCellType)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryDisclosureIndicator:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryDisclosureIndicatorCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessorySwitch:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessorySwitchCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemLogout:</div><div class="line">            &#123;</div><div class="line">                [cell configureLogoutTableViewCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryNone:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryNoneCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didSelectViewModel:(SJStaticTableviewCellViewModel *)viewModel atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">switch</span> (viewModel.identifier)</div><div class="line">    &#123;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"退出登录"</span>);</div><div class="line">            [<span class="keyword">self</span> showAlertWithMessage:<span class="string">@"真的要退出登录嘛？"</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">8</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"清理缓存"</span>);</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">9</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"跳转到定制性cell展示页面 - 分组"</span>);</div><div class="line">            SJCustomCellsViewController *vc = [[SJCustomCellsViewController alloc] init];</div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">10</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"跳转到定制性cell展示页面 - 同组"</span>);</div><div class="line">            SJCustomCellsOneSectionViewController *vc = [[SJCustomCellsOneSectionViewController alloc] init];</div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，你可能会有这些疑问：</p>
<ol>
<li>UITableViewDataSource方法哪儿去了？</li>
<li>viewModel数组是如何设置的？</li>
<li>cell的绘制方法是如何区分的？</li>
<li>UITableViewDelegate的方法哪里去了？</li>
</ol>
<p>下面我会一一解答，看完了下面的解答，就能几乎完全掌握这个框架的思路了：</p>
<h3 id="问题1：UITableViewDataSource方法哪儿去了？"><a href="#问题1：UITableViewDataSource方法哪儿去了？" class="headerlink" title="问题1：UITableViewDataSource方法哪儿去了？"></a>问题1：UITableViewDataSource方法哪儿去了？</h3><p>我自己封装了一个类<code>SJStaticTableViewDataSource</code>专门作为数据源，需要控制器给它一个viewModel数组。</p>
<p>来看一下它的实现文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableViewDataSource.m</span></div><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.viewModelsArray.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.cellViewModelsArray.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">//获取section的ViewModel</span></div><div class="line">    SJStaticTableviewSectionViewModel *sectionViewModel = <span class="keyword">self</span>.viewModelsArray[indexPath.section];</div><div class="line">    <span class="comment">//获取cell的viewModel</span></div><div class="line">    SJStaticTableviewCellViewModel *cellViewModel = sectionViewModel.cellViewModelsArray[indexPath.row];</div><div class="line">    </div><div class="line">    SJStaticTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellViewModel.cellID];</div><div class="line">    <span class="keyword">if</span> (!cell) &#123;</div><div class="line">        cell = [[SJStaticTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:cellViewModel.cellID];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.cellConfigureBlock(cell,cellViewModel);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.sectionHeaderTitle;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForFooterInSection:(<span class="built_in">NSInteger</span>)section</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.sectionFooterTitle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>表格的cell和section都设置了与其对应的viewModel，用于封装其对应的数据：</p>
</blockquote>
<p>cell的viewModel(大致看一下即可，后面有详细说明)：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SJStaticCellType) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//系统风格的各种cell类型，已封装好，可以直接用</span></div><div class="line">    SJStaticCellTypeSystemLogout,                          <span class="comment">//退出登录cell（已封装好）</span></div><div class="line">    SJStaticCellTypeSystemAccessoryNone,                   <span class="comment">//右侧没有任何控件</span></div><div class="line">    SJStaticCellTypeSystemAccessorySwitch,                 <span class="comment">//右侧是开关</span></div><div class="line">    SJStaticCellTypeSystemAccessoryDisclosureIndicator,    <span class="comment">//右侧是三角箭头(箭头左侧可以有一个image或者一个label，或者二者都有，根据传入的参数决定)</span></div><div class="line">    </div><div class="line">    <span class="comment">//需要用户自己添加的自定义cell类型</span></div><div class="line">    SJStaticCellTypeMeAvatar,                              <span class="comment">//个人页“我”cell</span></div><div class="line">    </div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SwitchValueChagedBlock)(<span class="built_in">BOOL</span> isOn);           <span class="comment">//switch开关切换时调用的block</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableviewCellViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SJStaticCellType staticCellType;                  <span class="comment">//类型</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *cellID;                                  <span class="comment">//cell reuser identifier</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> identifier;                              <span class="comment">//区别每个cell，用于点击</span></div><div class="line"></div><div class="line"><span class="comment">// =============== 系统默认cell左侧 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span>  *leftImage;                               <span class="comment">//左侧的image，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> leftImageSize;                              <span class="comment">//左侧image的大小，存在默认设置</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *leftTitle;                               <span class="comment">//cell主标题，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *leftLabelTextColor;                       <span class="comment">//当前组cell左侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *leftLabelTextFont;                         <span class="comment">//当前组cell左侧label里文字的字体</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> leftImageAndLabelGap;                      <span class="comment">//左侧image和label的距离，存在默认值</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// =============== 系统默认cell右侧 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *indicatorLeftTitle;                      <span class="comment">//右侧箭头左侧的文本，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *indicatorLeftLabelTextColor;              <span class="comment">//右侧文字的颜色，存在默认设置，也可以自定义</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *indicatorLeftLabelTextFont;                <span class="comment">//右侧文字的字体，存在默认设置，也可以自定义</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *indicatorLeftImage;                       <span class="comment">//右侧箭头左侧的image，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> indicatorLeftImageSize;                     <span class="comment">//右侧尖头左侧image大小，存在默认设置，也可以自定义</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>)  <span class="built_in">BOOL</span> hasIndicatorImageAndLabel;         <span class="comment">//右侧尖头左侧的文本和image是否同时存在，只能通过内部计算</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> indicatorLeftImageAndLabelGap;             <span class="comment">//右侧尖头左侧image和label的距离，存在默认值</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isImageFirst;                                 <span class="comment">//右侧尖头左侧的文本和image同时存在时，是否是image挨着箭头，默认为YES</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) SwitchValueChagedBlock switchValueDidChangeBlock;    <span class="comment">//切换switch开关的时候调用的block</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// =============== 长宽数据 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;                                <span class="comment">//cell高度,默认是44，可以设置</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span>  leftTitleLabelSize;                        <span class="comment">//左侧默认Label的size，传入text以后内部计算</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span>  indicatorLeftLabelSize;                    <span class="comment">//右侧label的size</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// =============== 自定义cell的数据放在这里 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *avatarImage;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *codeImage;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *userName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *userID;</div></pre></td></tr></table></figure></p>
<p>section的viewModel(大致看一下即可，后面有详细说明)：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableviewSectionViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sectionHeaderTitle;         <span class="comment">//该section的标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sectionFooterTitle;         <span class="comment">//该section的标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>  *cellViewModelsArray;        <span class="comment">//该section的数据源</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>  sectionHeaderHeight;         <span class="comment">//header的高度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>  sectionFooterHeight;         <span class="comment">//footer的高度</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> leftImageSize;                 <span class="comment">//当前组cell左侧image的大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *leftLabelTextColor;          <span class="comment">//当前组cell左侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *leftLabelTextFont;            <span class="comment">//当前组cell左侧label里文字的字体</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> leftImageAndLabelGap;         <span class="comment">//当前组左侧image和label的距离，存在默认值</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *indicatorLeftLabelTextColor; <span class="comment">//当前组cell右侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *indicatorLeftLabelTextFont;   <span class="comment">//当前组cell右侧label里文字的字体</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> indicatorLeftImageSize;        <span class="comment">//当前组cell右侧image的大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> indicatorLeftImageAndLabelGap;<span class="comment">//当前组cell右侧image和label的距离，存在默认值</span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCellViewModelsArray:(<span class="built_in">NSArray</span> *)cellViewModelsArray;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>你可能会觉得属性太多了，但这些属性的存在意义是为cell的定制性服务的，在后文会有解释。</p>
</blockquote>
<p>现在了解了我封装好的数据源，cell的viewModel，section的viewModel以后，我们看一下第二个问题：</p>
<h2 id="问题2：-viewModel数组是如何设置的？"><a href="#问题2：-viewModel数组是如何设置的？" class="headerlink" title="问题2： viewModel数组是如何设置的？"></a>问题2： viewModel数组是如何设置的？</h2><p>我们来看一下设置页的viewModel数组的设置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)settingPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ========== section 0</span></div><div class="line">    SJStaticTableviewCellViewModel *vm0 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm0.leftTitle = <span class="string">@"账号与安全"</span>;</div><div class="line">    vm0.identifier = <span class="number">0</span>;</div><div class="line">    vm0.indicatorLeftTitle = <span class="string">@"已保护"</span>;</div><div class="line">    vm0.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"ProfileLockOn"</span>];</div><div class="line">    vm0.isImageFirst = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section0 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm0]];</div><div class="line">    </div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// ========== section 1</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftTitle = <span class="string">@"新消息通知"</span>;</div><div class="line">    vm1.identifier = <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//额外添加switch</span></div><div class="line">    SJStaticTableviewCellViewModel *vm7 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftTitle = <span class="string">@"夜间模式"</span>;</div><div class="line">    vm7.switchValueDidChangeBlock = ^(<span class="built_in">BOOL</span> isON)&#123;</div><div class="line">        <span class="built_in">NSString</span> *message = isON?<span class="string">@"打开夜间模式"</span>:<span class="string">@"关闭夜间模式"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,message);</div><div class="line">    &#125;;</div><div class="line">    vm7.staticCellType = SJStaticCellTypeSystemAccessorySwitch;</div><div class="line">    vm7.identifier = <span class="number">7</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm8 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm8.leftTitle = <span class="string">@"清理缓存"</span>;</div><div class="line">    vm8.indicatorLeftTitle = <span class="string">@"12.3M"</span>;</div><div class="line">    vm8.identifier = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftTitle = <span class="string">@"隐私"</span>;</div><div class="line">    vm2.identifier = <span class="number">2</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftTitle = <span class="string">@"通用"</span>;</div><div class="line">    vm3.identifier = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1,vm7,vm8,vm2,vm3]];</div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ========== section 2</span></div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftTitle = <span class="string">@"帮助与反馈"</span>;</div><div class="line">    vm4.identifier = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftTitle = <span class="string">@"关于微信"</span>;</div><div class="line">    vm5.identifier = <span class="number">5</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section2 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm4,vm5]];</div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line">      <span class="comment">// ========== section 4</span></div><div class="line">    SJStaticTableviewCellViewModel *vm9 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm9.leftTitle = <span class="string">@"定制性cell展示页面 - 分组"</span>;</div><div class="line">    vm9.identifier = <span class="number">9</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm10 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm10.leftTitle = <span class="string">@"定制性cell展示页面 - 同组"</span>;</div><div class="line">    vm10.identifier = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section4 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm9,vm10]];</div><div class="line">    </div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// ========== section 3</span></div><div class="line">    SJStaticTableviewCellViewModel *vm6 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.staticCellType = SJStaticCellTypeSystemLogout;</div><div class="line">    vm6.cellID = <span class="string">@"logout"</span>;</div><div class="line">    vm6.identifier = <span class="number">6</span>;</div><div class="line">   </div><div class="line">    SJStaticTableviewSectionViewModel *section3 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm6]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section0,section1,section2,section4,section3];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，交给dataSource的数组是一个二维数组：</p>
<ul>
<li>第一维是section数组，元素是每一个section对应的viewModel：<code>SJStaticTableviewSectionViewModel</code>。</li>
<li>第二维是cell数组，元素是每一个cell对应的viewModel:<code>SJStaticTableviewCellViewModel</code>。</li>
</ul>
<p>有几个<code>SJStaticTableviewCellViewModel</code>的属性需要强调一下：</p>
<ol>
<li>isImageFirst：因为该页面第一组的cell右侧的箭头左边同时存在一个image和一个label，所以需要额外设置二者的顺序。因为默认紧挨着箭头的是图片，所以我们需要重新设置它为NO，作用是让label紧挨着箭头。</li>
<li>identifier：这个属性是一个整数，它用来标记每个cell，用于在用户点击cell的时候进行判断。我没有将用户的点击与cell的index相关联，是因为有的时候因为需求我们可能会更改cell的顺序或者删除某个cell，所以依赖cell的index是不妥的，容易出错。</li>
<li>cellID：这个属性用来cell的复用。因为总是有个别cell的布局是不同的：在这里出现了一个退出登录的cell，所以需要和其他的cell区别开来（cellID可以不用设置，有默认值，用来标记最常用的cell类型）。</li>
</ol>
<p>显然，<code>Factory</code>类属于<code>Model</code>，它将“纯数据”交给了dataSource使用的两个viewModel。这个类是我自己定义的，读者在使用这个框架的时候可以根据需求自己定义。</p>
<p>现在知道了数据源的设置方法，我们看一下第三个问题：</p>
<h3 id="问题3：cell的绘制方法是如何区分的？"><a href="#问题3：cell的绘制方法是如何区分的？" class="headerlink" title="问题3：cell的绘制方法是如何区分的？"></a>问题3：cell的绘制方法是如何区分的？</h3><p>心细的同学会发现，在dataSource的<code>cellForRow:</code>方法里，我用了block方法来绘制了cell。</p>
<p>先看一下这个block的定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SJStaticCellConfigureBlock)(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel * viewModel);</div></pre></td></tr></table></figure></p>
<p>这个block在控制器里面回调，通过判断cell的类型来绘制不同的cell。</p>
<p>那么不同类型的cell是如何区分的呢？<br>— 我用的是分类。</p>
<p>有分类，就一定有一个被分类的类： <code>SJStaticTableViewCell</code></p>
<p>看一下它的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//所有cell都是这个类的分类</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> : <span class="title">UITableViewCell</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SJStaticTableviewCellViewModel *viewModel;</div><div class="line"></div><div class="line"><span class="comment">// =============== 系统风格cell的所有控件 =============== //</span></div><div class="line"></div><div class="line"><span class="comment">//左半部分</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *leftImageView;               <span class="comment">//左侧的ImageView</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *leftTitleLabel;                  <span class="comment">//左侧的Label</span></div><div class="line"></div><div class="line"><span class="comment">//右半部分</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *indicatorArrow;              <span class="comment">//右侧的箭头</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *indicatorLeftImageView;      <span class="comment">//右侧的箭头的左边的imageview</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *indicatorLeftLabel;              <span class="comment">//右侧的箭头的左边的Label</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UISwitch</span> *indicatorSwitch;                <span class="comment">//右侧的箭头的左边的开关</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *logoutLabel;                     <span class="comment">//退出登录的label</span></div><div class="line"></div><div class="line"><span class="comment">// =============== 用户自定义的cell里面的控件 =============== //</span></div><div class="line"></div><div class="line"><span class="comment">//MeViewController里面的头像cell</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *avatarImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *codeImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *avatarIndicatorImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *userNameLabel;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *userIdLabel;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//统一的，布局cell左侧部分的内容（标题 ／ 图片 + 标题），所有系统风格的cell都要调用这个方法</span></div><div class="line">- (<span class="keyword">void</span>)layoutLeftPartSubViewsWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>在这里我定义了所有的控件和一个布局cell左侧的控件的方法。因为几乎所有的分类的左侧几乎都是类似的，所以将它抽取出来。</p>
<p>那么究竟有几个分类呢？（可以参考上面cellViewModel头文件里的枚举类型）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧有剪头的cell（最常见）</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessoryDisclosureIndicator</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessoryDisclosureIndicatorCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧没有控件的cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessoryNone</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessoryNoneCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧是开关的 cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessorySwitch</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessorySwitchCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//退出登录cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">Logout</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureLogoutTableViewCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个自定义的cell（在个人页的第一排）</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">MeAvatar</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureMeAvatarTableViewCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在使用这个框架的时候，如果遇到不满足当前需求的情况，可以自己添加分类。</p>
<h3 id="问题4：UITableViewDelegate的方法哪里去了？"><a href="#问题4：UITableViewDelegate的方法哪里去了？" class="headerlink" title="问题4：UITableViewDelegate的方法哪里去了？"></a>问题4：UITableViewDelegate的方法哪里去了？</h3><p>说到<code>UITableViewDelegate</code>的代理方法，我们最熟悉的莫过于<code>didSelectRowAtIndexPath:</code>了。</p>
<p>但是我在写这个框架的时候，自己定义了一个继承于<code>UITableViewDelegate</code>的代理：<code>SJStaticTableViewDelegate</code>，并给它添加了一个代理方法：<br>``<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SJStaticTableViewDelegate</span> &lt;<span class="title">UITableViewDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didSelectViewModel: (SJStaticTableviewCellViewModel *)viewModel atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这个方法返回的是当前点击的cell对应的viewModel，弱化了indexPath的作用。</p>
<p>为什么要这么做？</p>
<p>想一想原来点击cell的代理方法：<code>didSelectRowAtIndexPath:</code>。我们通过这个点击方法，拿到的是cell对应的indexPath，然后再通过这个indexPath，就可以在数据源里面查找对应的模型（viewModel或者model）。</p>
<p>因此，我定义的这个方法直接返回了被点击cell对应的viewModel，等于说帮使用者节省了一个步骤。当然如果要使用的话也可以使用系统原来的<code>didSelectRowAtIndexPath:</code>方法。</p>
<p>来看一下这个新的代理方法是如何实现的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableView.m</span></div><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.sjDelegate) &amp;&amp; [<span class="keyword">self</span>.sjDelegate respondsToSelector:<span class="keyword">@selector</span>(didSelectViewModel:atIndexPath:)]) &#123;</div><div class="line">        </div><div class="line">        SJStaticTableviewCellViewModel *cellViewModel = [<span class="keyword">self</span>.sjDataSource tableView:tableView cellViewModelAtIndexPath:indexPath];</div><div class="line">        [<span class="keyword">self</span>.sjDelegate didSelectViewModel:cellViewModel atIndexPath:indexPath];</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">self</span>.sjDelegate)&amp;&amp; [<span class="keyword">self</span>.sjDelegate respondsToSelector:<span class="keyword">@selector</span>(tableView:didSelectRowAtIndexPath:)])&#123;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.sjDelegate tableView:tableView didSelectRowAtIndexPath:indexPath];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在读者应该大致了解了这个框架的实现思路，现在我讲一下这个框架的定制性。</p>
<h1 id="4-定制性"><a href="#4-定制性" class="headerlink" title="4. 定制性"></a>4. 定制性</h1><hr>
<p>这个框架有一个配置文件：SJConst.h，它定义了这个框架的所有默认数据和默认配置，比如cell左侧lable的字体，颜色；左侧label和image的距离；右侧label的字体和颜色，右侧图片的默认大小等等。来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef SJConst_h</span></div><div class="line"><span class="meta">#define SJConst_h</span></div><div class="line"></div><div class="line"><span class="comment">//distance</span></div><div class="line"><span class="meta">#define SJScreenWidth      [UIScreen mainScreen].bounds.size.width</span></div><div class="line"><span class="meta">#define SJScreenHeight     [UIScreen mainScreen].bounds.size.height</span></div><div class="line"></div><div class="line"><span class="meta">#define SJTopGap 8               //same as bottom gap</span></div><div class="line"><span class="meta">#define SJLeftGap 12             //same as right gap</span></div><div class="line"><span class="meta">#define SJLeftMiddleGap 10       //in left  part: the gap between image and label</span></div><div class="line"><span class="meta">#define SJRightMiddleGap 6       //in right part: the gap between image and label</span></div><div class="line"><span class="meta">#define SJImgWidth 30            //default width and height</span></div><div class="line"><span class="meta">#define SJTitleWidthLimit 180    //limt width of left and right labels</span></div><div class="line"></div><div class="line"><span class="comment">//image</span></div><div class="line"><span class="meta">#define SJIndicatorArrow @<span class="meta-string">"arrow"</span></span></div><div class="line"></div><div class="line"><span class="comment">//font</span></div><div class="line"><span class="meta">#define SJLeftTitleTextFont               [UIFont systemFontOfSize:15]</span></div><div class="line"><span class="meta">#define SJLogoutButtonFont                [UIFont systemFontOfSize:16]</span></div><div class="line"><span class="meta">#define SJIndicatorLeftTitleTextFont      [UIFont systemFontOfSize:13]</span></div><div class="line"></div><div class="line"><span class="comment">//color</span></div><div class="line"><span class="meta">#define SJColorWithRGB(R,G,B,A)           [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]</span></div><div class="line"><span class="meta">#define SJLeftTitleTextColor              [UIColor blackColor]</span></div><div class="line"><span class="meta">#define SJIndicatorLeftTitleTextColor     SJColorWithRGB(136,136,136,1)</span></div><div class="line"></div><div class="line"><span class="meta">#endif /* SJConst_h */</span></div></pre></td></tr></table></figure>
<p>这里定义的默认配置在cellViewModel和sectionViewModel初始化的时候使用：</p>
<p>cell的viewModel：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableviewCellViewModel.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;        </div><div class="line">        _cellHeight = <span class="number">44</span>;</div><div class="line">        _cellID = <span class="string">@"defaultCell"</span>;</div><div class="line">        _staticCellType = SJStaticCellTypeSystemAccessoryDisclosureIndicator;<span class="comment">//默认是存在三角箭头的cell</span></div><div class="line">        _isImageFirst = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//都是默认配置</span></div><div class="line">        _leftLabelTextFont = SJLeftTitleTextFont;</div><div class="line">        _leftLabelTextColor = SJLeftTitleTextColor;</div><div class="line">        _leftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _leftImageAndLabelGap = SJLeftMiddleGap;</div><div class="line">        _indicatorLeftLabelTextFont = SJIndicatorLeftTitleTextFont;</div><div class="line">        _indicatorLeftLabelTextColor = SJIndicatorLeftTitleTextColor;</div><div class="line">        _indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _indicatorLeftImageAndLabelGap = SJRightMiddleGap;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>section的viewModel：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithCellViewModelsArray:(<span class="built_in">NSArray</span> *)cellViewModelsArray</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _sectionHeaderHeight = <span class="number">10</span>;</div><div class="line">        _sectionFooterHeight = <span class="number">10</span>;</div><div class="line">        _leftLabelTextFont = SJLeftTitleTextFont;</div><div class="line">        _leftLabelTextColor = SJLeftTitleTextColor;</div><div class="line">        _leftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _leftImageAndLabelGap = SJLeftMiddleGap;</div><div class="line">        _indicatorLeftLabelTextFont = SJIndicatorLeftTitleTextFont;</div><div class="line">        _indicatorLeftLabelTextColor = SJIndicatorLeftTitleTextColor;</div><div class="line">        _indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _indicatorLeftImageAndLabelGap = SJRightMiddleGap;</div><div class="line">        _cellViewModelsArray = cellViewModelsArray;        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，这个默认配置只有一组，但是可能一个app里面同时存在一个设置页和一个个人页。而这两个页面的风格也可能是不一样的，所以这个默认配置只能给其中一个页面，另一个页面需要另外配置，于是就有了定制性的功能。</p>
<p>再来看一下展示定制性效果的图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/dc3d7675b3eedb3dbe4ac3b7bb20d7db" alt="分组定制 | 同组定制"></p>
<p>参照这个效果图，我们看一下这两个页面的数据源是如何设置的：</p>
<p>分组页面：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)customCellsPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">//默认配置</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm1.leftTitle = <span class="string">@"全部默认配置，用于对照"</span>;</div><div class="line">    vm1.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm1.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1]];</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm2.leftTitle = <span class="string">@"左侧图片变小"</span>;</div><div class="line">    vm2.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm2.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section2 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm2]];</div><div class="line">    section2.leftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>);</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm3.leftTitle = <span class="string">@"字体变小变红"</span>;</div><div class="line">    vm3.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm3.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section3 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm3]];</div><div class="line">    section3.leftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">8</span>];</div><div class="line">    section3.leftLabelTextColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm4.leftTitle = <span class="string">@"左侧两个控件距离变大"</span>;</div><div class="line">    vm4.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm4.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section4 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm4]];</div><div class="line">    section4.leftImageAndLabelGap = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm5.leftTitle = <span class="string">@"右侧图片变小"</span>;</div><div class="line">    vm5.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm5.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section5 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm5]];</div><div class="line">    section5.indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">15</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm6= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm6.leftTitle = <span class="string">@"右侧字体变大变蓝"</span>;</div><div class="line">    vm6.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm6.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section6 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm6]];</div><div class="line">    section6.indicatorLeftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18</span>];</div><div class="line">    section6.indicatorLeftLabelTextColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm7= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm7.leftTitle = <span class="string">@"右侧两个控件距离变大"</span>;</div><div class="line">    vm7.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm7.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section7 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm7]];</div><div class="line">    section7.indicatorLeftImageAndLabelGap = <span class="number">18</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section1,section2,section3,section4,section5,section6,section7];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到，定制的代码都作用于section的viewModel。</p>
</blockquote>
<p>同组页面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)customCellsOneSectionPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">//默认配置</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm1.leftTitle = <span class="string">@"全部默认配置，用于对照"</span>;</div><div class="line">    vm1.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm1.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm2.leftTitle = <span class="string">@"左侧图片变小"</span>;</div><div class="line">    vm2.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm2.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm2.leftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm3.leftTitle = <span class="string">@"字体变小变红"</span>;</div><div class="line">    vm3.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm3.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm3.leftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">8</span>];</div><div class="line">    vm3.leftLabelTextColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm4.leftTitle = <span class="string">@"左侧两个控件距离变大"</span>;</div><div class="line">    vm4.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm4.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm4.leftImageAndLabelGap = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm5.leftTitle = <span class="string">@"右侧图片变小"</span>;</div><div class="line">    vm5.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm5.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm5.indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">15</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm6= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm6.leftTitle = <span class="string">@"右侧字体变大变蓝"</span>;</div><div class="line">    vm6.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm6.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm6.indicatorLeftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18</span>];</div><div class="line">    vm6.indicatorLeftLabelTextColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm7= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm7.leftTitle = <span class="string">@"右侧两个控件距离变大"</span>;</div><div class="line">    vm7.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm7.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm7.indicatorLeftImageAndLabelGap = <span class="number">18</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1,vm2,vm3,vm4,vm5,vm6,vm7]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为了方便比较，同组页面的定制和分组是一致的。我们可以看到，定制代码都作用于cell的viewModel上了。</p>
</blockquote>
<p>为什么要有同组和分组展示？</p>
<p>同组和分组展示的目的，是为了展示这个框架的两种定制性。</p>
<ul>
<li><p>分组页面所展示的是section级的定制性：cell的配置任务交给section层的viewModel。一旦设置，该section里面的所有cell都能保持这一配置。</p>
</li>
<li><p>同组页面所展示的是cell级的定制性：cell的配置任务交给cell层的viewModel。一旦设置，只有当前cell具有这个配置，不影响其他cell。</p>
</li>
</ul>
<p>其实为了省事，只在section层的viewModel上配置即可（如果给每个cell都给设置相同的配置太不优雅了），因为从设计角度来看，一个section里面的cell的风格不一致的情况比较少见（我觉得不符合设计）：比如在一个section里面，不太可能两个cell里面的图片大小是不一样的，或者字体大小也不一样。</p>
<p>还是看一下section级的定制代码吧：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧label的字体</span></div><div class="line">- (<span class="keyword">void</span>)setLeftLabelTextFont:(<span class="built_in">UIFont</span> *)leftLabelTextFont</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_leftLabelTextFont != leftLabelTextFont) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> font1:_leftLabelTextFont hasSameFontSizeOfFont2:leftLabelTextFont]) &#123;</div><div class="line">            </div><div class="line">            _leftLabelTextFont = leftLabelTextFont;</div><div class="line">            </div><div class="line">            <span class="comment">//如果新的宽度大于原来的宽度，需要重新设置，否则不需要</span></div><div class="line">            [_cellViewModelsArray enumerateObjectsUsingBlock:^(SJStaticTableviewCellViewModel * viewModel, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">                viewModel.leftLabelTextFont = _leftLabelTextFont;</div><div class="line">                <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> sizeForTitle:viewModel.leftTitle withFont:_leftLabelTextFont];</div><div class="line">                <span class="keyword">if</span> (size.width &gt; viewModel.leftTitleLabelSize.width) &#123;</div><div class="line">                    viewModel.leftTitleLabelSize = size;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧label的字的颜色</span></div><div class="line">- (<span class="keyword">void</span>)setLeftLabelTextColor:(<span class="built_in">UIColor</span> *)leftLabelTextColor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> color1:_leftLabelTextColor hasTheSameRGBAOfColor2:leftLabelTextColor]) &#123;</div><div class="line">         _leftLabelTextColor = leftLabelTextColor;</div><div class="line">        [_cellViewModelsArray makeObjectsPerformSelector:<span class="keyword">@selector</span>(setLeftLabelTextColor:) withObject:_leftLabelTextColor];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧图片等大小</span></div><div class="line">- (<span class="keyword">void</span>)setLeftImageSize:(<span class="built_in">CGSize</span>)leftImageSize</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewCellViewModel *viewMoel = _cellViewModelsArray.firstObject;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> cellHeight = viewMoel.cellHeight;</div><div class="line">    <span class="keyword">if</span> ( (!<span class="built_in">CGSizeEqualToSize</span>(_leftImageSize, leftImageSize)) &amp;&amp; (leftImageSize.height &lt; cellHeight)) &#123;</div><div class="line">        _leftImageSize = leftImageSize;</div><div class="line">        [_cellViewModelsArray enumerateObjectsUsingBlock:^(SJStaticTableviewCellViewModel *viewModel, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop)</div><div class="line">        &#123;</div><div class="line">            viewMoel.leftImageSize = _leftImageSize;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为每个section都持有它内部的所有cell的viewModel，所以在set方法里面，如果发现传进来的配置与当前配置不一致，就需要更新所有cell的viewModel对应的属性。</p>
<p>既然section的ViewModel能做这些，为什么还要有一个cell层的配置呢？</p>
<p>– 只是为了提高配置的自由度罢了，万一突然来个需求需要某个cell很独特呢？（大家应该知道我说的神么意思 ^^）</p>
<p>cell的viewModel属性的set方法的实现和section的一致，这里就不上代码了。</p>
<h1 id="5-新增支持刷新功能"><a href="#5-新增支持刷新功能" class="headerlink" title="5. 新增支持刷新功能"></a>5. 新增支持刷新功能</h1><p>在1.1.2版本支持了：在更新数据源后，刷新数据源。<br>举个例子：在发现页模拟网络请求，在请求结束后更新某个cell的viewmodel：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//模拟网络请求</span></div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求成功x</span></div><div class="line">        <span class="built_in">NSDictionary</span> *responseDict = @&#123;<span class="string">@"title_info"</span>:<span class="string">@"新游戏上架啦"</span>,</div><div class="line">                                       <span class="string">@"title_icon"</span>:<span class="string">@"game_1"</span>,</div><div class="line">                                       <span class="string">@"game_info"</span>:<span class="string">@"一起来玩斗地主呀！"</span>,</div><div class="line">                                       <span class="string">@"game_icon"</span>:<span class="string">@"doudizhu"</span></div><div class="line">                                       &#125;;</div><div class="line">        <span class="comment">//将要刷新cell的indexPath</span></div><div class="line">        <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="number">1</span> inSection:<span class="number">3</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//获取cell对应的viewModel</span></div><div class="line">        SJStaticTableviewCellViewModel *viewModel = [<span class="keyword">self</span>.dataSource tableView:<span class="keyword">self</span>.tableView cellViewModelAtIndexPath:indexPath];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (viewModel) &#123;</div><div class="line">            <span class="comment">//更新viewModel</span></div><div class="line">            viewModel.leftTitle = responseDict[<span class="string">@"title_info"</span>];</div><div class="line">            viewModel.leftImage = [<span class="built_in">UIImage</span> imageNamed:responseDict[<span class="string">@"title_icon"</span>]];</div><div class="line">            viewModel.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:responseDict[<span class="string">@"game_icon"</span>]];</div><div class="line">            viewModel.indicatorLeftTitle = responseDict[<span class="string">@"game_info"</span>];</div><div class="line">            </div><div class="line">            <span class="comment">//刷新tableview</span></div><div class="line">            [<span class="keyword">self</span>.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationFade</span>];</div><div class="line">        &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/8906383a490f9507e37f9f122e2a4eee" alt="更新数据源后刷新表格"></p>
<h1 id="6-新增支持数据源完全依赖网络请求"><a href="#6-新增支持数据源完全依赖网络请求" class="headerlink" title="6. 新增支持数据源完全依赖网络请求"></a>6. 新增支持数据源完全依赖网络请求</h1><p>在1.2.0版本支持了：数据源完全依赖网络请求的情况。</p>
<p>现在的最新版本里，SJStaticViewController在创建的时候分为两种情况:</p>
<ol>
<li>SJDefaultDataTypeExist：在表格生成之前就存在数据，可以是表格的全部数据，也可以是表格的默认数据（后来通过网络请求来更新部分数据，参考上一节）。</li>
<li>SJDefaultDataTypeNone：意味着当前没有任何的默认数据可以使用，也就是无法生成tableview，需要在网络请求拿到数据后，再手动调用生成数据源，生成表格的方法。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableViewController.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    </div><div class="line">    SJDefaultDataTypeExist,    <span class="comment">//在表格生成之前就有数据（1. 完全不依赖网络请求，有现成的完整数据 2. 先生成默认数据，然后通过网络请求来更新数据并刷新表格）</span></div><div class="line">    SJDefaultDataTypeNone,     <span class="comment">//无法生成默认数据，需要完全依赖网络请求，在拿到数据后，生成表格</span></div><div class="line">    </div><div class="line">&#125;SJDefaultDataType;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithDefaultDataType:(SJDefaultDataType)defualtDataType;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableViewController.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithDefaultDataType:(SJDefaultDataType)defualtDataType</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.defualtDataType = defualtDataType;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithDefaultDataType:SJDefaultDataTypeExist];<span class="comment">//默认是SJDefaultDataTypeExist</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [<span class="keyword">self</span> configureNav];</div><div class="line">    </div><div class="line">    <span class="comment">//在能够提供给tableivew全部，或者部分数据源的情况下，可以先构造出tableview；</span></div><div class="line">    <span class="comment">//否则，需要在网络请求结束后，手动调用configureTableView方法</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.defualtDataType == SJDefaultDataTypeExist) &#123;</div><div class="line">        [<span class="keyword">self</span> configureTableView];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//只有在SJDefaultDataTypeExist的时候才会自动调用，否则需要手动调用</span></div><div class="line">- (<span class="keyword">void</span>)configureTableView</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> createDataSource];<span class="comment">//生成数据源</span></div><div class="line">    [<span class="keyword">self</span> createTableView];<span class="comment">//生成表格</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一个例子，我们将表情页设置为<code>SJDefaultDataTypeNone</code>，那么就意味着我们需要手动调用<code>configureTableView</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">     <span class="keyword">self</span>.navigationItem.title = <span class="string">@"表情"</span>;</div><div class="line">    [<span class="keyword">self</span> networkRequest];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)networkRequest</div><div class="line">&#123;</div><div class="line">    [MBProgressHUD showHUDAddedTo: <span class="keyword">self</span>.view animated:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//模拟网络请求</span></div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        [MBProgressHUD hideHUDForView: <span class="keyword">self</span>.view animated:<span class="literal">YES</span>];</div><div class="line">         <span class="keyword">self</span>.modelsArray = [Factory emoticonPage];<span class="comment">//网络请求后，将数据保存在self.modelsArray里面</span></div><div class="line">        [<span class="keyword">self</span> configureTableView];<span class="comment">//手动调用</span></div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createDataSource</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.dataSource = [[SJStaticTableViewDataSource alloc] initWithViewModelsArray:<span class="keyword">self</span>.modelsArray configureBlock:^(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel *viewModel) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">switch</span> (viewModel.staticCellType) &#123;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryDisclosureIndicator:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryDisclosureIndicatorCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下效果图：<br><img src="https://user-gold-cdn.xitu.io/2017/4/24/dddb4eed3379c043133ba38d2d8ef1a4.png" alt=""><br>好了，到这里就讲差不多了，代码量虽然不多，但是都说清楚还是感觉挺需要时间想的。</p>
<p>希望如果各位觉得哪里不好，可以给出您的宝贵意见～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;更新记录：&quot;&gt;&lt;a href=&quot;#更新记录：&quot; class=&quot;headerlink&quot; title=&quot;更新记录：&quot;&gt;&lt;/a&gt;更新记录：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;2017.4.23：新增支持数据源完全依赖网络请求的情况。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2017.4.22：新增支持请求新数据后刷新表格。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2017.4.21： 新增CocoaPods支持：pod ‘SJStaticTableView’, ‘~&amp;gt; 1.2.0’。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;写一个小小轮子～&lt;/p&gt;
&lt;p&gt;写UITableView的时候，我们经常遇到的是完全依赖于网络请求，需要自定义的动态cell的需求（比如微博帖子列表）。但是同时，大多数app里面几乎也都有设置页，个人页等其他以静态表格为主的页面。&lt;/p&gt;
&lt;p&gt;而且这些页面的共性比较多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大多数情况下在进入页面之前就已经拿到所有数据。&lt;/li&gt;
&lt;li&gt;cell样式单一，自定义cell出现的几率比较小（几乎都是高度为44的cell）。&lt;/li&gt;
&lt;li&gt;多数都分组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为自己非常想写一个开源的东西出来（也可以暴露自己的不足），同时又受限于水平，所以就打算写这么一个比较简单，又具有通用性的框架：&lt;strong&gt;一个定制性比较高的适合在个人页和设置页使用的UITableView&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在真正写之前，看了几篇类似的文章，挑出三篇自己觉得比较好的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.objc.io/issues/1-view-controllers/table-views/&quot;&gt;Clean Table View Code&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/504c61a9dc82&quot;&gt;如何写好一个UITableView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/81d0c573f7a8&quot;&gt;利用MVVM设计快速开发个人中心、设置等模块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看完总结之后，利用上周3天的业余时间写好了这个框架，为了它实用性，我仿照了微信客户端的发现页，个人页和设置页写了一个Demo，来看一下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/4/24/85789de80b62c93ff0c9f77b603dba70&quot; alt=&quot;发现页 | 个人页 | 个人信息页 | 设置页&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目所用资源来自：&lt;a href=&quot;https://github.com/zhengwenming/WeChat&quot;&gt;GitHub:zhengwenming/WeChat&lt;/a&gt;&lt;br&gt;Demo地址：&lt;a href=&quot;https://github.com/knightsj/SJStaticTableView&quot;&gt;GitHub: knightsj/SJStaticTableView&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/03/14/%E5%85%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%8D%E6%98%AFiOS%E7%A8%8B%E5%BA%8F%E5%91%98%20%E2%80%94%20%E5%86%99%E7%BB%99%E5%B9%BF%E5%A4%A7%E9%9D%9E%E7%A7%91%E7%8F%ADiOS%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%80%E7%AF%87%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/03/14/先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结/</id>
    <published>2017-03-14T00:37:08.000Z</published>
    <updated>2017-03-20T07:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-10c56d4121bfe78d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Objective-C | Swift | C"></p>
<p>这篇面试总结很短，也没有面试题的答案，只是写给像我一样的非科班iOS开发者的一些话。</p>
<p>昨天进行了人生第一次视频面试，一共三个小时的技术面，还没见到人事，应该是挂了。</p>
<p>不过整个过程下来感触还是蛮多的，除了感受到面试官的牛X之外，也知道自己平时在学习中的不足。</p>
<h4 id="先介绍一下面试中觉得比较吃力的问题："><a href="#先介绍一下面试中觉得比较吃力的问题：" class="headerlink" title="先介绍一下面试中觉得比较吃力的问题："></a>先介绍一下面试中觉得比较吃力的问题：</h4><ol>
<li>如果让你实现属性的weak，如何实现的？</li>
<li>如果让你来实现属性的atomic，如何实现？</li>
<li>KVO为什么要创建一个子类来实现？</li>
<li>类结构体的组成，isa指针指向了什么？（这里应该将元类和根元类也说一下）</li>
<li>RunLoop有几种事件源？有几种模式？</li>
<li>方法列表的数据结构是什么？</li>
<li>分类是如何实现的？它为什么会覆盖掉原来的方法？</li>
</ol>
<p>另外值得一提的就是问了我自己写的博客里的东西（JSONModel的解析，EOC的笔记）等等。。</p>
<a id="more"></a>
<h4 id="这次面试让我深刻意识到了两点："><a href="#这次面试让我深刻意识到了两点：" class="headerlink" title="这次面试让我深刻意识到了两点："></a>这次面试让我深刻意识到了两点：</h4><ol>
<li>对于每个设计，不能只停留在“会用”而已，应该理解它的实现机制，而且几乎每个设计都是与数据结构息息相关的，理解了数据结构和指针会有助于理解这些设计。</li>
<li>了解设计的原理之后，还要知其所以然：为什么这么设计？最好还要知道这个设计存在什么缺陷，这个缺陷是哪个解决类似问题的设计所没有的？</li>
</ol>
<p>第一点是“how”的问题，第二点是“why”的问题，然而我相信有不少人只停留在“what”和“using”上。</p>
<p>在面试的时候，我强烈感受到了面试官的功力之深：给我的感觉，对他而言，几乎所有的设计都可以用某种数据结构解释出来（有的时候也会结合指针），对知识点理解得非常透彻：即便是很简单知识点，也能说出很多深层次的东西来。而我自己只是刚开始学数据结构不久，在面对提到数据结构的问题几乎是没有思路的。</p>
<h4 id="我想说的："><a href="#我想说的：" class="headerlink" title="我想说的："></a>我想说的：</h4><p>所以我觉得对于广大非科班的iOS开发来说，如果想在iOS开发上走远，就必须尽快补充数据结构，算法，指针等计算机基础知识，不然会对知识的理解形成很大的阻力。因为只有知道了这些基础知识，才能更深入得理解每一个技术点，而且以后如果学习其他的语言，也会更高效一些。</p>
<p>简单来说就一句话：先是程序员，然后才是iOS程序员。只有这样思考，路才能越走越宽，越走越快，越走越远。</p>
<p>现在iOS开发形势这么不好，市场要过滤掉那些计算机基础知识薄弱的人也是情有可原的。</p>
<blockquote>
<p>所谓的现在的“不好”，只是相对于之前“不正常的好”的不好。现在这个行业变得“不好”，其实是因为这个行业正在变得好，应该值得我们高兴才是。</p>
</blockquote>
<p>所以对于我们这群人（非科班的iOS开发者），应该提高忧患意识，未雨绸缪，更何况，雨已经来过了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0dc7553fc98a04f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-10c56d4121bfe78d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Objective-C | Swift | C&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇面试总结很短，也没有面试题的答案，只是写给像我一样的非科班iOS开发者的一些话。&lt;/p&gt;
&lt;p&gt;昨天进行了人生第一次视频面试，一共三个小时的技术面，还没见到人事，应该是挂了。&lt;/p&gt;
&lt;p&gt;不过整个过程下来感触还是蛮多的，除了感受到面试官的牛X之外，也知道自己平时在学习中的不足。&lt;/p&gt;
&lt;h4 id=&quot;先介绍一下面试中觉得比较吃力的问题：&quot;&gt;&lt;a href=&quot;#先介绍一下面试中觉得比较吃力的问题：&quot; class=&quot;headerlink&quot; title=&quot;先介绍一下面试中觉得比较吃力的问题：&quot;&gt;&lt;/a&gt;先介绍一下面试中觉得比较吃力的问题：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;如果让你实现属性的weak，如何实现的？&lt;/li&gt;
&lt;li&gt;如果让你来实现属性的atomic，如何实现？&lt;/li&gt;
&lt;li&gt;KVO为什么要创建一个子类来实现？&lt;/li&gt;
&lt;li&gt;类结构体的组成，isa指针指向了什么？（这里应该将元类和根元类也说一下）&lt;/li&gt;
&lt;li&gt;RunLoop有几种事件源？有几种模式？&lt;/li&gt;
&lt;li&gt;方法列表的数据结构是什么？&lt;/li&gt;
&lt;li&gt;分类是如何实现的？它为什么会覆盖掉原来的方法？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外值得一提的就是问了我自己写的博客里的东西（JSONModel的解析，EOC的笔记）等等。。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>JSONModel源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/22/JSONModel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/22/JSONModel源码解析/</id>
    <published>2017-02-22T01:16:56.000Z</published>
    <updated>2017-03-20T07:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列的<a href="http://www.jianshu.com/nb/9137726" target="_blank" rel="external">源码解析</a>分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。</p>
<p>想来想去，还是从<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>开始吧～</p>
<p>首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。</p>
<p>该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。</p>
<a id="more"></a>
<p>在讲解源码之前，有必要先给不会使用JSONModel的同学们通过实际的例子来介绍一下它的使用方法（而且后面的源码解析部分也是结合这些例子给出的，因为结合例子有助于加快理解）：</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="1-最基本的使用"><a href="#1-最基本的使用" class="headerlink" title="1. 最基本的使用"></a>1. 最基本的使用</h2><p>第一种就是单纯地传入一个字典，并转换成模型：<br>首先我们需要定义我们自己的模型类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>然后再使用字典来转换为模型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"gender"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"> <span class="built_in">NSError</span> *error;</div><div class="line"> Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [sex]: male</div><div class="line">   [gender]: 23</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>可以看出来，该框架的使用非常方便，一行代码就将模型转换好了。<br>但是该框架的功能远不止这些：</p>
<h2 id="2-转换属性名称"><a href="#2-转换属性名称" class="headerlink" title="2. 转换属性名称"></a>2. 转换属性名称</h2><p>有的时候，传入的字典里的key发生了变化（比如接口重构之类的原因），但是我们前端这边已经写好的模型属性可能不容易被修改（因为业务逻辑很复杂什么的），所以这个时候，最好有一个转化的功能。</p>
<p>在这里举个例子：原来字典里的<code>gender</code>这个key变成了<code>sex</code>，这就需要我们定义一个转换的mapper（<code>JSONKeyMapper</code>）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">+ (JSONKeyMapper *)keyMapper</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[JSONKeyMapper alloc] initWithModelToJSONDictionary:@&#123;</div><div class="line">                                                                  <span class="string">@"gender"</span>: <span class="string">@"sex"</span>,                                                             &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来，<code>JSONKeyMapper</code>就会自动帮我们做转换。<br>为了验证效果，我们修改一下传入的字典里的<code>gender</code>字段为<code>sex</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>再看一下输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure>
<p>没有受到传入字典里key值的变化的影响，是吧？</p>
<h2 id="3-自定义错误"><a href="#3-自定义错误" class="headerlink" title="3. 自定义错误"></a>3. 自定义错误</h2><p>除了一些框架里自己处理的错误（比如传入的对象不是字典等），框架的作者也允许我们自己定义属于我们自己的错误。</p>
<p>比如，当<code>age</code>对应的数值小于25的时候，打印出<code>Too young!</code>,并阻止模型的转换：</p>
<p>首先，我们在模型的实现文件里添加：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validate:(<span class="built_in">NSError</span> **)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">super</span> validate:error])</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.age &lt; <span class="number">25</span>)</div><div class="line">    &#123;</div><div class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Too young!"</span> code:<span class="number">10</span> userInfo:<span class="literal">nil</span>];</div><div class="line">        <span class="built_in">NSError</span> *errorLog = *error;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,errorLog.domain);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] Too young!</div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] (null)</div></pre></td></tr></table></figure></p>
<p>打印了错误，而且模型也没有被转换。</p>
<h2 id="4-模型嵌套"><a href="#4-模型嵌套" class="headerlink" title="4. 模型嵌套"></a>4. 模型嵌套</h2><p>有的时候，我们需要在模型里加一个数组，而这个数组里面的元素是另一个对象：这就涉及到了模型的嵌套。</p>
<p>举个例子，我们让上面的<code>Person</code>对象含有一个数组<code>Friends</code>，它里面的元素是对象<code>Friend</code>，也就是好友信息。若要实现模型的嵌套，我们只需在原来的模型类里增加一个协议<code>Friend</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JSONModel.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Friend</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Friend</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;Friend&gt; *friends;<span class="comment">//数组，嵌套模型</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>而且要在<code>Person</code>的实现文件里加上这一段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Friend</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意！如果不添加，则会令程序崩溃。</p>
<p>最后，在使用的时候，我们只需将持有一个数组的字典里传入即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[</div><div class="line">                      @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Peter"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">35</span>,</div><div class="line">                        &#125;,</div><div class="line">                   ];</div><div class="line">    </div><div class="line"> <span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                           <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                           <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                           <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                           <span class="string">@"friends"</span>:array,<span class="comment">//朋友列表（模型嵌套）</span></div><div class="line">                         &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person);</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">   [friends]: (</div><div class="line">       "&lt;Friend&gt; \n   [name]: Peter\n   [age]: 35\n&lt;/Friend&gt;"</div><div class="line">   )</div><div class="line">   [name]: Jack</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，person对象里含有一个数组，这个数组只有一个元素，对应着上面字典里的array里的信息。</p>
<p>OK，这样一来，大家已经可以掌握该框架的主要用法了，现在开始详细讲解代码：</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>本篇源码解析主要围绕着<code>initWithDictionary:error:</code>来展开，在这一个方法里作者做到了所有的容错和模型的转化。</p>
<p>按照老规矩，先上流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-94b356eeb7b560e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字典-&gt;模型"></p>
<p>该流程图对应的方法实现是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//方法1. 参数为nil</span></div><div class="line">    <span class="keyword">if</span> (!dict) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></div><div class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法3. 初始化</span></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//初始化失败</span></div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>方法1-4:都是对错误的发现与处理。</li>
<li>方法5:是真正的mapping。</li>
<li>方法6:是作者给用户自己定义错误的方法，如果复合了用户自己定义的错误，那么即使mapping成功了，也要返回nil。<br>-方法7:成功返回模型对象。</li>
</ul>
<p>在讲解代码之前，有必要先了解一下JSONModel所持有的一些数据：</p>
<ul>
<li><p><strong>关联对象kClassPropertiesKey</strong>:(用来保存所有属性信息的NSDictionary)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       age = <span class="string">"@property primitive age (Setters = [])"</span>;</div><div class="line">      name = <span class="string">"@property NSString* name (Standard JSON type, Setters = [])"</span>;</div><div class="line">    gender = <span class="string">"@property NSString* gender (Standard JSON type, Setters = [])"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kClassRequiredPropertyNamesKey</strong>：(用来保存所有属性的名称NSSet)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;(</div><div class="line">    name,</div><div class="line">    age,</div><div class="line">    gender</div><div class="line">)&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kMapperObjectKey</strong>：(用来保存JSONKeyMapper)：自定义的mapper，具体的使用方法在上面的例子中可以看到。</p>
</li>
</ul>
<ul>
<li><strong>JSONModelClassProperty</strong>：封装的jsonmodel的一个属性，它包含了对应属性的名字（name：gender），类型（type：NSString），是否是JSONModel支持的类型（isStandardJSONType：YES/NO），是否是可变对象（isMutable:YES/NO）等属性。</li>
</ul>
<p>再大致讲解一下整个的流程：<br>首先，在这个模型类的对象被初始化的时候，遍历自身到所有的父类（直到JSONModel为止），获取所有的属性，并将其保存在一个字典里。获取传入字典的所有key，将这些key与保存的所有属性进行匹配。如果匹配成功，则进行kvc赋值。</p>
<p>OK，现在从上到下逐步讲解上段代码：</p>
<p>首先，在<code>load</code>方法里，定义了该框架支持的类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;           </div><div class="line">            <span class="comment">//兼容的对象属性</span></div><div class="line">            allowedJSONTypes = @[</div><div class="line">                [<span class="built_in">NSString</span> <span class="keyword">class</span>], [<span class="built_in">NSNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSDecimalNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>], [<span class="built_in">NSDictionary</span> <span class="keyword">class</span>], [<span class="built_in">NSNull</span> <span class="keyword">class</span>], <span class="comment">//immutable JSON classes</span></div><div class="line">                [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>] <span class="comment">//mutable JSON classes</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//兼容的基本类型属性</span></div><div class="line">            allowedPrimitiveTypes = @[</div><div class="line">                <span class="string">@"BOOL"</span>, <span class="string">@"float"</span>, <span class="string">@"int"</span>, <span class="string">@"long"</span>, <span class="string">@"double"</span>, <span class="string">@"short"</span>,</div><div class="line">                <span class="comment">//and some famous aliases</span></div><div class="line">                <span class="string">@"NSInteger"</span>, <span class="string">@"NSUInteger"</span>,</div><div class="line">                <span class="string">@"Block"</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//转换器</span></div><div class="line">            valueTransformer = [[JSONValueTransformer alloc] init];</div><div class="line">            </div><div class="line">            <span class="comment">//自己的类型</span></div><div class="line">            JSONModelClass = <span class="built_in">NSClassFromString</span>(<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们看一下从方法3的init方法开始，作者都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> __setup__];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)__setup__</div><div class="line">&#123;</div><div class="line">    <span class="comment">//只有第一次实例化时，才执行</span></div><div class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kClassPropertiesKey)) &#123;</div><div class="line">        [<span class="keyword">self</span> __inspectProperties];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在自定义的mapper，则将它保存在关联对象里面，key是kMapperObjectKey</span></div><div class="line">    <span class="keyword">id</span> mapper = [[<span class="keyword">self</span> <span class="keyword">class</span>] keyMapper];</div><div class="line">    <span class="keyword">if</span> ( mapper &amp;&amp; !objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kMapperObjectKey) ) &#123;</div><div class="line">        objc_setAssociatedObject(</div><div class="line">                                 <span class="keyword">self</span>.class,</div><div class="line">                                 &amp;kMapperObjectKey,</div><div class="line">                                 mapper,</div><div class="line">                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                 );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的是，这里的<code>__inspectProperties:</code>方法是该框架的核心方法之一：它的任务是保存了所有需要赋值的属性。用作在将来与传进来字典进行映射：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)__inspectProperties</div><div class="line">&#123;</div><div class="line"><span class="comment">//    最终保存所有属性的字典，形式为：</span></div><div class="line"><span class="comment">//    &#123;</span></div><div class="line"><span class="comment">//        age = "@property primitive age (Setters = [])";</span></div><div class="line"><span class="comment">//        friends = "@property NSArray*&lt;Friend&gt; friends (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        gender = "@property NSString* gender (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        name = "@property NSString* name (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span>* propertyIndex = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="comment">//获取当前的类名</span></div><div class="line">    Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];    </div><div class="line">    <span class="built_in">NSScanner</span>* scanner = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span>* propertyType = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 循环条件：当class 是 JSONModel自己的时候终止</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">class</span> != [JSONModel <span class="keyword">class</span>]) &#123;        </div><div class="line">        <span class="comment">//属性的个数</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</div><div class="line">        <span class="comment">//获得属性列表（所有@property声明的属性）</span></div><div class="line">        objc_property_t *properties = class_copyPropertyList(<span class="keyword">class</span>, &amp;propertyCount);</div><div class="line">        <span class="comment">//遍历所有的属性</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</div><div class="line">            <span class="comment">//获得属性名称</span></div><div class="line">            objc_property_t property = properties[i];<span class="comment">//获得当前的属性</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);<span class="comment">//name（C字符串）            </span></div><div class="line">            <span class="comment">//JSONModel里的每一个属性，都被封装成一个JSONModelClassProperty对象</span></div><div class="line">            JSONModelClassProperty* p = [[JSONModelClassProperty alloc] init];</div><div class="line">            p.name = @(propertyName);<span class="comment">//propertyName:属性名称，例如：name，age，gender</span></div><div class="line">            <span class="comment">//获得属性类型</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *attrs = property_getAttributes(property);</div><div class="line">            <span class="built_in">NSString</span>* propertyAttributes = @(attrs);</div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_name</span></div><div class="line">            <span class="comment">// Tq,N,V_age</span></div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_gender</span></div><div class="line">            <span class="comment">// T@"NSArray&lt;Friend&gt;",&amp;,N,V_friends            </span></div><div class="line">            <span class="built_in">NSArray</span>* attributeItems = [propertyAttributes componentsSeparatedByString:<span class="string">@","</span>];</div><div class="line">            <span class="comment">//说明是只读属性，不做任何操作</span></div><div class="line">            <span class="keyword">if</span> ([attributeItems containsObject:<span class="string">@"R"</span>]) &#123;</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">//to next property</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//检查出是布尔值</span></div><div class="line">            <span class="keyword">if</span> ([propertyAttributes hasPrefix:<span class="string">@"Tc,"</span>]) &#123;</div><div class="line">                p.structName = <span class="string">@"BOOL"</span>;<span class="comment">//使其变为结构体</span></div><div class="line">            &#125;            </div><div class="line">            <span class="comment">//实例化一个scanner</span></div><div class="line">            scanner = [<span class="built_in">NSScanner</span> scannerWithString: propertyAttributes];</div><div class="line">            [scanner scanUpToString:<span class="string">@"T"</span> intoString: <span class="literal">nil</span>];</div><div class="line">            [scanner scanString:<span class="string">@"T"</span> intoString:<span class="literal">nil</span>];</div><div class="line">            <span class="comment">//http://blog.csdn.net/kmyhy/article/details/8258858           </span></div><div class="line">            <span class="keyword">if</span> ([scanner scanString:<span class="string">@"@\""</span> intoString: &amp;propertyType]) &#123;                </div><div class="line">                 <span class="comment">//属性是一个对象</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@"\"&lt;"</span>]</div><div class="line">                                        intoString:&amp;propertyType];<span class="comment">//propertyType -&gt; NSString                </span></div><div class="line">                p.type = <span class="built_in">NSClassFromString</span>(propertyType);<span class="comment">// p.type = @"NSString"</span></div><div class="line">                p.isMutable = ([propertyType rangeOfString:<span class="string">@"Mutable"</span>].location != <span class="built_in">NSNotFound</span>); <span class="comment">//判断是否是可变的对象</span></div><div class="line">                p.isStandardJSONType = [allowedJSONTypes containsObject:p.type];<span class="comment">//是否是该框架兼容的类型</span></div><div class="line">                <span class="comment">//存在协议(数组，也就是嵌套模型)</span></div><div class="line">                <span class="keyword">while</span> ([scanner scanString:<span class="string">@"&lt;"</span> intoString:<span class="literal">NULL</span>]) &#123;</div><div class="line">                    <span class="built_in">NSString</span>* protocolName = <span class="literal">nil</span>;</div><div class="line">                    [scanner scanUpToString:<span class="string">@"&gt;"</span> intoString: &amp;protocolName];</div><div class="line">                    <span class="keyword">if</span> ([protocolName isEqualToString:<span class="string">@"Optional"</span>]) &#123;</div><div class="line">                        p.isOptional = <span class="literal">YES</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Index"</span>]) &#123;</div><div class="line"><span class="meta">#pragma GCC diagnostic push</span></div><div class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">                        p.isIndex = <span class="literal">YES</span>;</div><div class="line"><span class="meta">#pragma GCC diagnostic pop</span></div><div class="line">                        objc_setAssociatedObject(</div><div class="line">                                                 <span class="keyword">self</span>.class,</div><div class="line">                                                 &amp;kIndexPropertyNameKey,</div><div class="line">                                                 p.name,</div><div class="line">                                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                                 );</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Ignore"</span>]) &#123;</div><div class="line">                        p = <span class="literal">nil</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        p.protocol = protocolName;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//到最接近的&gt;为止</span></div><div class="line">                    [scanner scanString:<span class="string">@"&gt;"</span> intoString:<span class="literal">NULL</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;            </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ([scanner scanString:<span class="string">@"&#123;"</span> intoString: &amp;propertyType])                </div><div class="line">                <span class="comment">//属性是结构体</span></div><div class="line">                [scanner scanCharactersFromSet:[<span class="built_in">NSCharacterSet</span> alphanumericCharacterSet]</div><div class="line">                                    intoString:&amp;propertyType];</div><div class="line">                p.isStandardJSONType = <span class="literal">NO</span>;</div><div class="line">                p.structName = propertyType;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//属性是基本类型：Tq,N,V_age</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@","</span>]</div><div class="line">                                        intoString:&amp;propertyType];</div><div class="line">                <span class="comment">//propertyType:q</span></div><div class="line">                propertyType = valueTransformer.primitivesNames[propertyType];              </div><div class="line">                <span class="comment">//propertyType:long</span></div><div class="line">                <span class="comment">//基本类型数组</span></div><div class="line">                <span class="keyword">if</span> (![allowedPrimitiveTypes containsObject:propertyType]) &#123;</div><div class="line">                    <span class="comment">//类型不支持</span></div><div class="line">                    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"JSONModelProperty type not allowed"</span></div><div class="line">                                                   reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Property type of %@.%@ is not supported by JSONModel."</span>, <span class="keyword">self</span>.class, p.name]</div><div class="line">                                                 userInfo:<span class="literal">nil</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSString</span> *nsPropertyName = @(propertyName);            </div><div class="line">            <span class="comment">//可选的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsOptional:nsPropertyName])&#123;</div><div class="line">                p.isOptional = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//可忽略的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsIgnored:nsPropertyName])&#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//集合类</span></div><div class="line">            Class customClass = [[<span class="keyword">self</span> <span class="keyword">class</span>] classForCollectionProperty:nsPropertyName];            </div><div class="line">            <span class="keyword">if</span> (customClass) &#123;</div><div class="line">                p.protocol = <span class="built_in">NSStringFromClass</span>(customClass);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//忽略block</span></div><div class="line">            <span class="keyword">if</span> ([propertyType isEqualToString:<span class="string">@"Block"</span>]) &#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果字典里不存在，则添加到属性字典里（终于添加上去了。。。）</span></div><div class="line">            <span class="keyword">if</span> (p &amp;&amp; ![propertyIndex objectForKey:p.name]) &#123;</div><div class="line">                [propertyIndex setValue:p forKey:p.name];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//setter 和 getter</span></div><div class="line">            <span class="keyword">if</span> (p)</div><div class="line">            &#123;   <span class="comment">//name -&gt;Name</span></div><div class="line">                <span class="built_in">NSString</span> *name = [p.name stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:[p.name substringToIndex:<span class="number">1</span>].uppercaseString];</div><div class="line">                <span class="comment">// getter</span></div><div class="line">                SEL <span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"JSONObjectFor%@"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>])</div><div class="line">                    p.customGetter = <span class="keyword">getter</span>;</div><div class="line">                <span class="comment">// setters</span></div><div class="line">                p.customSetters = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">                SEL genericSetter = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@WithJSONObject:"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:genericSetter])</div><div class="line">                    p.customSetters[<span class="string">@"generic"</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;genericSetter objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                <span class="keyword">for</span> (Class type <span class="keyword">in</span> allowedJSONTypes)</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">NSString</span> *<span class="keyword">class</span> = <span class="built_in">NSStringFromClass</span>([JSONValueTransformer classByResolvingClusterClasses:type]);</div><div class="line">                    <span class="keyword">if</span> (p.customSetters[<span class="keyword">class</span>])</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    SEL <span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@With%@:"</span>, name, <span class="keyword">class</span>]);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">setter</span>])</div><div class="line">                        p.customSetters[<span class="keyword">class</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;<span class="keyword">setter</span> objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        free(properties);</div><div class="line">        <span class="comment">//再指向自己的父类，知道等于JSONModel才停止</span></div><div class="line">        <span class="keyword">class</span> = [<span class="keyword">class</span> superclass];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//最后保存所有当前类，JSONModel的所有的父类的属性</span></div><div class="line">    objc_setAssociatedObject(</div><div class="line">                             <span class="keyword">self</span>.class,</div><div class="line">                             &amp;kClassPropertiesKey,</div><div class="line">                             [propertyIndex <span class="keyword">copy</span>],</div><div class="line">                             OBJC_ASSOCIATION_RETAIN</div><div class="line">                             );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意几点：</p>
<ol>
<li>作者利用一个<code>while</code>函数，获取当前类和当前类的除JSONModel的所有父类的属性保存在一个字典中。在将来用于和传入的字典进行映射。</li>
<li>作者用<code>JSONModelClassProperty</code>类封装了JSONModel的每一个属性。这个类有两个重要的属性：一个是<code>name</code>，它是属性的名称(例如gender)。另一个是<code>type</code>，它是属性的类型（例如NSString）。</li>
<li>作者将属性分为了如下几个类型：<ol>
<li>对象（不含有协议）。</li>
<li>对象（含有协议，属于模型嵌套）。</li>
<li>基本数据类型。</li>
<li>结构体。</li>
</ol>
</li>
</ol>
</blockquote>
<p>我们来看一下方法4的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__doesDictionary:(<span class="built_in">NSDictionary</span>*)dict matchModelWithKeyMapper:(JSONKeyMapper*)keyMapper error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//拿到字典里所有的key</span></div><div class="line">    <span class="built_in">NSArray</span>* incomingKeysArray = [dict allKeys];    </div><div class="line">    <span class="comment">//返回保存所有属性名称的数组(name,age,gender...)</span></div><div class="line">    <span class="built_in">NSMutableSet</span>* requiredProperties = [<span class="keyword">self</span> __requiredPropertyNames].mutableCopy;    </div><div class="line">    <span class="comment">//从array拿到set</span></div><div class="line">    <span class="built_in">NSSet</span>* incomingKeys = [<span class="built_in">NSSet</span> setWithArray: incomingKeysArray];</div><div class="line">    <span class="comment">//如果用户自定义了mapper，则进行转换</span></div><div class="line">    <span class="keyword">if</span> (keyMapper || globalKeyMapper) &#123;</div><div class="line">        <span class="built_in">NSMutableSet</span>* transformedIncomingKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity: requiredProperties.count];</div><div class="line">        <span class="built_in">NSString</span>* transformedName = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//便利需要转换的属性列表</span></div><div class="line">        <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">            <span class="comment">//被转换成的属性名称 gender（模型内） -&gt; sex（字典内）</span></div><div class="line">            transformedName = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">            <span class="comment">//拿到sex以后，查看传入的字典里是否有sex对应的值</span></div><div class="line">            <span class="keyword">id</span> value;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                value = [dict valueForKeyPath:transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                value = dict[transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果值存在，则将sex添加到传入的keys数组中</span></div><div class="line">            <span class="keyword">if</span> (value) &#123;</div><div class="line">                [transformedIncomingKeys addObject: property.name];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        incomingKeys = transformedIncomingKeys;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//查看当前的model的属性的集合是否大于传入的属性集合，如果是，则返回错误。</span></div><div class="line">    <span class="comment">//也就是说模型类里的属性是不能多于传入字典里的key的，例如：</span></div><div class="line">    <span class="keyword">if</span> (![requiredProperties isSubsetOfSet:incomingKeys]) &#123;</div><div class="line">        <span class="comment">//获取多出来的属性</span></div><div class="line">        [requiredProperties minusSet:incomingKeys];</div><div class="line">        <span class="comment">//not all required properties are in - invalid input</span></div><div class="line">        JMLog(<span class="string">@"Incoming data was invalid [%@ initWithDictionary:]. Keys missing: %@"</span>, <span class="keyword">self</span>.class, requiredProperties);</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMissingKeys:requiredProperties];</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不需要了，释放掉</span></div><div class="line">    incomingKeys= <span class="literal">nil</span>;</div><div class="line">    requiredProperties= <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要需要注意的：</p>
<ol>
<li>model类里面定义的属性集合是不能大于传入的字典里的key集合的。</li>
<li>如果存在了用户自定义的mapper，则需要按照用户的定义来进行转换。<br>（在这里是奖gender转换为了sex）。</li>
</ol>
</blockquote>
<p>最后来看一下本框架第二个核心代码(上面的方法5)，也就是真正从字典里获取值并赋给当前模型对象的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__importDictionary:(<span class="built_in">NSDictionary</span>*)dict withKeyMapper:(JSONKeyMapper*)keyMapper validation:(<span class="built_in">BOOL</span>)validation error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//遍历保存的所有属性的字典</span></div><div class="line">    <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">        <span class="comment">//将属性的名称拿过来，作为key，用这个key来查找传进来的字典里对应的值</span></div><div class="line">        <span class="built_in">NSString</span>* jsonKeyPath = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">        <span class="comment">//用来保存从字典里获取的值</span></div><div class="line">        <span class="keyword">id</span> jsonValue;        </div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            jsonValue = [dict valueForKeyPath: jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            jsonValue = dict[jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//字典不存在对应的key</span></div><div class="line">        <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">            <span class="comment">//如果这个key是可以不存在的</span></div><div class="line">            <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;            </div><div class="line">            <span class="comment">//如果这个key是必须有的，则返回错误</span></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Value of required model key %@ is null"</span>, property.name];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//获取 取到的值的类型</span></div><div class="line">        Class jsonValueClass = [jsonValue <span class="keyword">class</span>];</div><div class="line">        <span class="built_in">BOOL</span> isValueOfAllowedType = <span class="literal">NO</span>;</div><div class="line">        <span class="comment">//查看是否是本框架兼容的属性类型</span></div><div class="line">        <span class="keyword">for</span> (Class allowedType <span class="keyword">in</span> allowedJSONTypes) &#123;</div><div class="line">            <span class="keyword">if</span> ( [jsonValueClass isSubclassOfClass: allowedType] ) &#123;</div><div class="line">                isValueOfAllowedType = <span class="literal">YES</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//如果不兼容，则返回NO，mapping失败</span></div><div class="line">        <span class="keyword">if</span> (isValueOfAllowedType==<span class="literal">NO</span>) &#123;</div><div class="line">            <span class="comment">//type not allowed</span></div><div class="line">            JMLog(<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass));</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass)];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是兼容的类型：</span></div><div class="line">        <span class="keyword">if</span> (property) &#123;</div><div class="line">            <span class="comment">// 查看是否有自定义setter，并设置</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __customSetValue:jsonValue forProperty:property]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 基本类型</span></div><div class="line">            <span class="keyword">if</span> (property.type == <span class="literal">nil</span> &amp;&amp; property.structName==<span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//kvc赋值</span></div><div class="line">                <span class="keyword">if</span> (jsonValue != [<span class="keyword">self</span> valueForKey:property.name]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果传来的值是空，即使当前的属性对应的值不是空，也要将空值赋给它</span></div><div class="line">            <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> valueForKey:property.name] != <span class="literal">nil</span>) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:<span class="literal">nil</span> forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 1. 属性本身是否是jsonmodel类型</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __isJSONModelSubClass:property.type]) &#123;</div><div class="line">                <span class="comment">//通过自身的转模型方法，获取对应的值</span></div><div class="line">                JSONModelError* initErr = <span class="literal">nil</span>;</div><div class="line">                <span class="keyword">id</span> value = [[property.type alloc] initWithDictionary: jsonValue error:&amp;initErr];</div><div class="line">                <span class="keyword">if</span> (!value) &#123;               </div><div class="line">                    <span class="comment">//如果该属性不是必须的，则略过</span></div><div class="line">                    <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;</div><div class="line">                    <span class="comment">//如果该属性是必须的，则返回错误</span></div><div class="line">                    <span class="keyword">if</span>((err != <span class="literal">nil</span>) &amp;&amp; (initErr != <span class="literal">nil</span>))</div><div class="line">                    &#123;</div><div class="line">                        *err = [initErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;            </div><div class="line">                <span class="comment">//当前的属性值为空，则赋值</span></div><div class="line">                <span class="keyword">if</span> (![value isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:value forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果不是jsonmodel的类型，则可能是一些普通的类型：NSArray，NSString。。。</span></div><div class="line">                <span class="comment">// 是否是模型嵌套（带有协议）</span></div><div class="line">                <span class="keyword">if</span> (property.protocol) &#123;</div><div class="line">                    <span class="comment">//转化为数组，这个数组就是例子中的friends属性。</span></div><div class="line">                    jsonValue = [<span class="keyword">self</span> __transform:jsonValue forProperty:property error:err];</div><div class="line">                   </div><div class="line">                    <span class="keyword">if</span> (!jsonValue) &#123;</div><div class="line">                        <span class="keyword">if</span> ((err != <span class="literal">nil</span>) &amp;&amp; (*err == <span class="literal">nil</span>)) &#123;</div><div class="line">                            <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Failed to transform value, but no error was set during transformation. (%@)"</span>, property];</div><div class="line">                            JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                            *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 对象类型</span></div><div class="line">                <span class="keyword">if</span> (property.isStandardJSONType &amp;&amp; [jsonValue isKindOfClass: property.type]) &#123;</div><div class="line">                    <span class="comment">//可变类型</span></div><div class="line">                    <span class="keyword">if</span> (property.isMutable) &#123;</div><div class="line">                        jsonValue = [jsonValue mutableCopy];</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//赋值</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 当前的值的类型与对应的属性的类型不一样的时候，需要查看用户是否自定义了转换器（例如从NSSet到NSArray转换：- (NSSet *)NSSetFromNSArray:(NSArray *)array）</span></div><div class="line">                <span class="keyword">if</span> (</div><div class="line">                    (![jsonValue isKindOfClass:property.type] &amp;&amp; !isNull(jsonValue))</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//the property is mutable</span></div><div class="line">                    property.isMutable</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//custom struct property</span></div><div class="line">                    property.structName</div><div class="line">                    ) &#123;</div><div class="line">                    <span class="comment">// searched around the web how to do this better</span></div><div class="line">                    <span class="comment">// but did not find any solution, maybe that's the best idea? (hardly)</span></div><div class="line">                    Class sourceClass = [JSONValueTransformer classByResolvingClusterClasses:[jsonValue <span class="keyword">class</span>]];</div><div class="line">                    <span class="comment">//JMLog(@"to type: [%@] from type: [%@] transformer: [%@]", p.type, sourceClass, selectorName);</span></div><div class="line"></div><div class="line">                    <span class="comment">//build a method selector for the property and json object classes</span></div><div class="line">                    <span class="built_in">NSString</span>* selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@From%@:"</span>,</div><div class="line">                                              (property.structName? property.structName : property.type), <span class="comment">//target name</span></div><div class="line">                                              sourceClass]; <span class="comment">//source name</span></div><div class="line">                    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                    <span class="comment">//查看自定义的转换器是否存在</span></div><div class="line">                    <span class="built_in">BOOL</span> foundCustomTransformer = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                        foundCustomTransformer = <span class="literal">YES</span>;                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//try for hidden custom transformer</span></div><div class="line">                        selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"__%@"</span>,selectorName];</div><div class="line">                        selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                        <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                            foundCustomTransformer = <span class="literal">YES</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//如果存在自定义转换器，则进行转换</span></div><div class="line">                    <span class="keyword">if</span> (foundCustomTransformer) &#123;                        </div><div class="line">                        IMP imp = [valueTransformer methodForSelector:selector];</div><div class="line">                        <span class="keyword">id</span> (*func)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)imp;</div><div class="line">                        jsonValue = func(valueTransformer, selector, jsonValue);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                            [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;                       </div><div class="line">                        <span class="comment">//没有自定义转换器，返回错误</span></div><div class="line">                        <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ type not supported for %@.%@"</span>, property.type, [<span class="keyword">self</span> <span class="keyword">class</span>], property.name];</div><div class="line">                        JSONModelError* dataErr = [JSONModelError errorInvalidDataWithTypeMismatch:msg];</div><div class="line">                        *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;                        </div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 3.4) handle "all other" cases (if any)</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是：</p>
<ul>
<li>作者在最后给属性赋值的时候使用的是kvc的<code>setValue:ForKey:</code>的方法。</li>
<li>作者判断了模型里的属性的类型是否是JSONModel的子类，可见作者的考虑是非常周全的。</li>
<li>整个框架看下来，有很多的地方涉及到了错误判断，作者将将错误类型单独抽出一个类（<code>JSONModelError</code>），里面支持的错误类型很多，可以侧面反应作者思维之缜密。而且这个做法也可以在我们写自己的框架或者项目中使用。</li>
</ul>
</blockquote>
<p>错误判断的一个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JSONModelError.m</span></div><div class="line">+(<span class="keyword">id</span>)errorInvalidDataWithMessage:(<span class="built_in">NSString</span>*)message</div><div class="line">&#123;</div><div class="line">    message = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Invalid JSON data: %@"</span>, message];</div><div class="line">    <span class="keyword">return</span> [JSONModelError errorWithDomain:JSONModelErrorDomain</div><div class="line">                                      code:kJSONModelErrorInvalidData</div><div class="line">                                  userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:message&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>夸了作者这么多，唯一我个人不太喜欢的地方就是if语句下只有一行的时候，作者不喜欢加上大括号：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">    [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div></pre></td></tr></table></figure></p>
<p>但是我觉得应该加的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])&#123;</div><div class="line">  [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ul>
<li>作者用NSScanner来扫描字符串，将从类结构体里拿过来的属性的描述字符串<code>T@\&quot;NSString\&quot;,C,N,V_name</code>中扫描出了类型：<code>NSString</code>。</li>
<li>作者两次用到了NSSet：当集合里的元素顺序不重要的时候，优先考虑用NSSet。</li>
</ul>
<p>总的来说这个框架的难度还是不大的，但可能因为是第一次阅读不涉及UIVIiew的框架，感觉有些枯燥，不过慢慢习惯就好啦～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列的&lt;a href=&quot;http://www.jianshu.com/nb/9137726&quot;&gt;源码解析&lt;/a&gt;分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。&lt;/p&gt;
&lt;p&gt;想来想去，还是从&lt;a href=&quot;https://github.com/jsonmodel/jsonmodel&quot;&gt;JSONModel&lt;/a&gt;开始吧～&lt;/p&gt;
&lt;p&gt;首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。&lt;/p&gt;
&lt;p&gt;该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>VVeboTableView源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/14/VVeboTableView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/14/VVeboTableView源码解析/</id>
    <published>2017-02-14T02:57:30.000Z</published>
    <updated>2017-03-20T07:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次分享一个关于性能优化的源码。</p>
<p>我们知道<code>UITabelView</code>在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，<code>UITabelView</code>的性能将直接影响这个app的性能。</p>
<p>如果<code>UITabelView</code>里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。</p>
<p>但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。</p>
<p>最近在看一些iOS性能优化的文章，我找到了<a href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableView</a>这个框架。严格来说这个不属于框架，而是作者用自己的方式优化<code>UITableView</code>的一个实现。</p>
<p>作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？</p>
<p>看了源码之后，我把作者的思路整理了出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png" alt="优化思路图"></p>
<p>下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。</p>
<a id="more"></a>
<h2 id="1-减少CPU／GPU计算量"><a href="#1-减少CPU／GPU计算量" class="headerlink" title="1. 减少CPU／GPU计算量"></a>1. 减少CPU／GPU计算量</h2><h3 id="1-1-cell的重用机制"><a href="#1-1-cell的重用机制" class="headerlink" title="1.1 cell的重用机制"></a>1.1 cell的重用机制</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//cell重用</span></div><div class="line">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cell==<span class="literal">nil</span>) &#123;</div><div class="line">        cell = [[VVeboTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制</span></div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分就不赘述了，相信大家都可以掌握。</p>
<h3 id="1-2-将cell高度和-cell里的控件的frame缓存在model里"><a href="#1-2-将cell高度和-cell里的控件的frame缓存在model里" class="headerlink" title="1.2 将cell高度和 cell里的控件的frame缓存在model里"></a>1.2 将cell高度和 cell里的控件的frame缓存在model里</h3><p>这一步我们需要在字典转模型里统一计算(不需要看代码细节，只需要知道这里在模型里保存了需要保存的控件的frame和整个cell的高度即可)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadData&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> temp) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *user = dict[<span class="string">@"user"</span>];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *retweet = [dict valueForKey:<span class="string">@"retweeted_status"</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (retweet) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">            ...</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">                <span class="built_in">CGSize</span> size = [subData[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_SUBCONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">                <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">                subData[<span class="string">@"textRect"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_BIG, width, sizeHeight)];</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="keyword">if</span> (subData[<span class="string">@"pic_urls"</span>] &amp;&amp; [subData[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                    sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">                &#125;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                subData[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            data[<span class="string">@"subData"</span>] = subData;</div><div class="line">           </div><div class="line">        </div><div class="line">            <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">            <span class="built_in">CGSize</span> size = [data[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_CONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">            <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">            ...</div><div class="line">            sizeHeight += SIZE_GAP_TOP+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">if</span> (data[<span class="string">@"pic_urls"</span>] &amp;&amp; [data[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [data valueForKey:<span class="string">@"subData"</span>];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (subData) &#123;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="built_in">CGRect</span> frame = [subData[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">                ...</div><div class="line">                sizeHeight += frame.size.height;</div><div class="line">                data[<span class="string">@"subData"</span>] = subData;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            sizeHeight += <span class="number">30</span>;</div><div class="line">            data[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">        &#125;</div><div class="line">        [datas addObject:data];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取高度缓存</span></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *dict = datas[indexPath.row];</div><div class="line">    <span class="keyword">float</span> height = [dict[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>].size.height;</div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到，作者根据帖子类型的不同：原贴(subData)的存在与否），来逐渐叠加cell的高度。</p>
<p>而缓存的控件的frame，我们在下面讲解绘制cell的代码里详细介绍。</p>
<h3 id="1-3-减少cell内部控件的层级"><a href="#1-3-减少cell内部控件的层级" class="headerlink" title="1.3 减少cell内部控件的层级"></a>1.3 减少cell内部控件的层级</h3><p>我们先来看一下一个带有原贴的转发贴的布局：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_3.png" alt="布局"></p>
<p>可能有小伙伴会将上中下这三个部分各自封装成一个view，再通过每个view来管理各自的子view。但是这个框架的作者却将它们都排列到一层上。</p>
<p>减少了子view的层级，有助于减少cpu对各种约束的计算。这在子view的数量，层级都很多的情况下对cpu的压力会减轻很多。</p>
<h3 id="1-4-通过覆盖圆角图片来实现头像的圆角效果"><a href="#1-4-通过覆盖圆角图片来实现头像的圆角效果" class="headerlink" title="1.4 通过覆盖圆角图片来实现头像的圆角效果"></a>1.4 通过覆盖圆角图片来实现头像的圆角效果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头像，frame固定</span></div><div class="line">avatarView = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];<span class="comment">//[[VVeboAvatarView alloc] initWithFrame:avatarRect];</span></div><div class="line">avatarView.frame = <span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_TOP, SIZE_AVATAR, SIZE_AVATAR);</div><div class="line">avatarView.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</div><div class="line">avatarView.hidden = <span class="literal">NO</span>;</div><div class="line">avatarView.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">avatarView.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:avatarView];</div><div class="line"><span class="comment">//覆盖在头像上面的图片，制造圆角效果：frame</span></div><div class="line">cornerImage = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, SIZE_AVATAR+<span class="number">5</span>, SIZE_AVATAR+<span class="number">5</span>)];</div><div class="line">cornerImage.center = avatarView.center;</div><div class="line">cornerImage.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"corner_circle@2x.png"</span>];</div><div class="line">cornerImage.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:cornerImage];</div></pre></td></tr></table></figure>
<p>在这里，作者没有使用任何复杂的技术来实现图片的圆角（使用layer或者裁剪图片），只是将一张圆角颜色和cell背景色一致的图片覆盖在了原来的头像上，实现了圆角的效果（但是这个方法不太适用于有多个配色方案的app）。</p>
<h2 id="2-按需加载cell"><a href="#2-按需加载cell" class="headerlink" title="2. 按需加载cell"></a>2. 按需加载cell</h2><p>上文提到过，<code>UITableView</code>持有一个<code>needLoadArr</code>数组，它保存着需要刷新的cell的<code>NSIndexPath</code>。</p>
<p>我们先来看一下<code>needLoadArr</code>是如何使用的：</p>
<h3 id="2-1-在cellForRow-方法里只加载可见cell"><a href="#2-1-在cellForRow-方法里只加载可见cell" class="headerlink" title="2.1 在cellForRow:方法里只加载可见cell"></a>2.1 在cellForRow:方法里只加载可见cell</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    ...</div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawCell:(VVeboTableViewCell *)cell withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSDictionary</span> *data = [datas objectAtIndex:indexPath.row];    </div><div class="line">    ...</div><div class="line">    cell.data = data;</div><div class="line">    <span class="comment">//当前的cell的indexPath不在needLoadArr里面，不用绘制</span></div><div class="line">    <span class="keyword">if</span> (needLoadArr.count&gt;<span class="number">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        [cell clear];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//将要滚动到顶部，不绘制</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//真正绘制cell的代码</span></div><div class="line">    [cell draw];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"><a href="#2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引" class="headerlink" title="2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"></a>2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引</h3><p>知道了如何使用<code>needLoadArr</code>，我们看一下<code>needLoadArr</code>里面的元素师如何添加和删除。</p>
<h4 id="添加元素NSIndexPath"><a href="#添加元素NSIndexPath" class="headerlink" title="添加元素NSIndexPath"></a>添加元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//targetContentOffset ： 停止后的contentOffset</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</div><div class="line">    </div><div class="line">    <span class="comment">//当前可见第一行row的index</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</div><div class="line">    </div><div class="line">    <span class="comment">//设置最小跨度，当滑动的速度很快，超过这个跨度时候执行按需加载</span></div><div class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//快速滑动(跨度超过了8个cell)</span></div><div class="line">    <span class="keyword">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//某个区域里的单元格的indexPath</span></div><div class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</div><div class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (velocity.y&lt;<span class="number">0</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向上滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</div><div class="line">            </div><div class="line">            <span class="comment">//超过倒数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row+<span class="number">3</span>&lt;datas.count) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向下滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</div><div class="line">            <span class="comment">//超过正数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row&gt;<span class="number">3</span>) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//添加arr里的内容到needLoadArr的末尾</span></div><div class="line">        [needLoadArr addObjectsFromArray:arr];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了如何向<code>needLoadArr</code>里添加元素，现在看一下何时（重置）清理这个array：</p>
<h4 id="移除元素NSIndexPath"><a href="#移除元素NSIndexPath" class="headerlink" title="移除元素NSIndexPath"></a>移除元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用户触摸时第一时间加载内容</span></div><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!scrollToToping) &#123;</div><div class="line">        [needLoadArr removeAllObjects];</div><div class="line">        [<span class="keyword">self</span> loadContent];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    [needLoadArr removeAllObjects];</div><div class="line">&#125;</div><div class="line"><span class="comment">//将要滚动到顶部</span></div><div class="line">- (<span class="built_in">BOOL</span>)scrollViewShouldScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//停止滚动</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div><div class="line"><span class="comment">//滚动到了顶部</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，当手指触碰到tableview时 和 开始拖动tableview的时候就要清理这个数组。</p>
<p>而且在手指触碰到tableview时和 tableview停止滚动后就会执行<code>loadContent</code>方法，用来加载可见区域的cell。</p>
<p><code>loadContent</code>方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadContent&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//正在滚动到顶部</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//可见cell数</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.indexPathsForVisibleRows.count&lt;=<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//触摸的时候刷新可见cell</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.visibleCells&amp;&amp;<span class="keyword">self</span>.visibleCells.count&gt;<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> temp <span class="keyword">in</span> [<span class="keyword">self</span>.visibleCells <span class="keyword">copy</span>]) &#123;</div><div class="line">            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;</div><div class="line">            [cell draw];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里注意一下，tableview的<code>visibleCells</code>属性是可见的cell的数组。</p>
<h2 id="3-异步处理cell"><a href="#3-异步处理cell" class="headerlink" title="3. 异步处理cell"></a>3. 异步处理cell</h2><p>在讲解cell是如何显示出来之前，我们大致看一下这个cell都有哪些控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_4.png" alt="控件名称"></p>
<p>了解到控件的名称，位置之后，我们看一下作者是如何布局这些控件的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_2.png" alt="控件布局"><br>在上面可以大致看出来，除了需要异步网络加载的头像(avatarView)和帖子图片(multiPhotoScrollView)，作者都将这些控件画在了一张图上面（postBgView）。</p>
<p>而且我们可以看到，在postBgView上面需要异步显示的内容分为四种：</p>
<ol>
<li>UIImageView：本地图片（comments, more,reposts）。</li>
<li>UIView：背景，分割线(topLine)。</li>
<li>NSString：name，from字符串。</li>
<li>Label：原贴的detailLabel 和 当前贴的 label。</li>
</ol>
<p>下面结合代码来讲解这四种绘制：</p>
<p>首先看一下cell内部的核心绘制方法：</p>
<p>现在我们来看一下cell绘制的核心方法,draw方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将cell的主要内容绘制到图片上</span></div><div class="line">- (<span class="keyword">void</span>)draw&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//drawed = YES说明正在绘制，则立即返回。因为绘制是异步的，所以在开始绘制之后需要立即设为yes，防止重复绘制</span></div><div class="line">    <span class="keyword">if</span> (drawed) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//标记当前的绘制</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawColorFlag;</div><div class="line">    </div><div class="line">    drawed = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//获取整个cell的frame，已经换存在模型里了</span></div><div class="line">        <span class="built_in">CGRect</span> rect = [_data[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//开启图形上下文</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">YES</span>, <span class="number">0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//获取图形上下文</span></div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        </div><div class="line">        <span class="comment">//背景颜色</span></div><div class="line">        [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line">        <span class="comment">//通过rect填充背景颜色</span></div><div class="line">        <span class="built_in">CGContextFillRect</span>(context, rect);</div><div class="line">        </div><div class="line">        <span class="comment">//如果有原帖（说明当前贴是转发贴）</span></div><div class="line">        <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">            </div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">243</span>/<span class="number">255.0</span> green:<span class="number">243</span>/<span class="number">255.0</span> blue:<span class="number">243</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGRect</span> subFrame = [_data[<span class="string">@"subData"</span>][<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, subFrame);</div><div class="line">            </div><div class="line">            <span class="comment">//原帖上面的分割线</span></div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, subFrame.origin.y, rect.size.width, <span class="number">.5</span>));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">float</span> x = leftX;</div><div class="line">            <span class="keyword">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class="number">6</span>))/<span class="number">2</span><span class="number">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class="number">-5</span>;</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字</span></div><div class="line">            [_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                             andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                                andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字下面的info</span></div><div class="line">            y += SIZE_FONT_NAME+<span class="number">5</span>;</div><div class="line">            <span class="keyword">float</span> fromX = leftX;</div><div class="line">            <span class="keyword">float</span> size = [<span class="built_in">UIScreen</span> screenWidth]-leftX;</div><div class="line">            <span class="built_in">NSString</span> *from = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@  %@"</span>, _data[<span class="string">@"time"</span>], _data[<span class="string">@"from"</span>]];</div><div class="line">            </div><div class="line">            [from drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE)</div><div class="line">                   andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                      andHeight:rect.size.height andWidth:size];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//评论角</span></div><div class="line">            <span class="built_in">CGRect</span> countRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30</span>, [<span class="built_in">UIScreen</span> screenWidth], <span class="number">30</span>);</div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, countRect);</div><div class="line">            <span class="keyword">float</span> alpha = <span class="number">1</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> x = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT<span class="number">-10</span>;</div><div class="line">            <span class="built_in">NSString</span> *comments = _data[<span class="string">@"comments"</span>];</div><div class="line">            <span class="keyword">if</span> (comments) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [comments sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= size.width;</div><div class="line">                </div><div class="line">                <span class="comment">//图片文字</span></div><div class="line">                [comments drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                              andHeight:rect.size.height];</div><div class="line">                </div><div class="line">                <span class="comment">//评论图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                </div><div class="line">                commentsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, [<span class="built_in">UIScreen</span> screenWidth]-x+<span class="number">5</span>, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//转发角</span></div><div class="line">            <span class="built_in">NSString</span> *reposts = _data[<span class="string">@"reposts"</span>];</div><div class="line">            <span class="keyword">if</span> (reposts) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [reposts sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= MAX(size.width, <span class="number">5</span>)+SIZE_GAP_BIG;</div><div class="line">                </div><div class="line">                <span class="comment">//转发文字</span></div><div class="line">                [reposts drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                 </div><div class="line">                             andHeight:rect.size.height];</div><div class="line">               </div><div class="line">                <span class="comment">//转发图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_repost.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">11</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                repostsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, commentsRect.origin.x-x, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//更多角</span></div><div class="line">            [<span class="string">@"•••"</span> drawInContext:context</div><div class="line">                     withPosition:<span class="built_in">CGPointMake</span>(SIZE_GAP_LEFT, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                          andFont:FontWithSize(<span class="number">11</span>)</div><div class="line">                     andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">.5</span>]</div><div class="line">                        andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制原帖底部的分割线</span></div><div class="line">            <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">                [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">                <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30.5</span>, rect.size.width, <span class="number">.5</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//将整个contex转化为图片，赋给背景imageview</span></div><div class="line">        <span class="built_in">UIImage</span> *temp = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (flag==drawColorFlag) &#123;</div><div class="line">                postBGView.frame = rect;</div><div class="line">                postBGView.image = <span class="literal">nil</span>;</div><div class="line">                postBGView.image = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//绘制两个label的text</span></div><div class="line">    [<span class="keyword">self</span> drawText];</div><div class="line">    </div><div class="line">    <span class="comment">//加载帖子里的网路图片，使用SDWebImage</span></div><div class="line">    [<span class="keyword">self</span> loadThumb];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面抽出每一种绘制内容的代码，分别讲解：</p>
<h3 id="3-1-异步加载网络图片"><a href="#3-1-异步加载网络图片" class="headerlink" title="3.1 异步加载网络图片"></a>3.1 异步加载网络图片</h3><p>关于网络图片的异步加载和缓存，作者使用了第三方框架：<code>SDWebImage</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setData:(<span class="built_in">NSDictionary</span> *)data&#123;</div><div class="line">    _data = data;</div><div class="line">    [avatarView setBackgroundImage:<span class="literal">nil</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    <span class="keyword">if</span> ([data valueForKey:<span class="string">@"avatarUrl"</span>]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:[data valueForKey:<span class="string">@"avatarUrl"</span>]];</div><div class="line">        [avatarView sd_setBackgroundImageWithURL:url forState:<span class="built_in">UIControlStateNormal</span> placeholderImage:<span class="literal">nil</span> options:SDWebImageLowPriority];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>SDWebImage</code>，我相信大家都不会陌生，我前一阵写了一篇源码解析，有兴趣的话可以看一下：<a href="http://www.jianshu.com/p/93696717b4a3" target="_blank" rel="external">SDWebImage源码解析</a>。</p>
<h3 id="3-2-异步绘制本地图片"><a href="#3-2-异步绘制本地图片" class="headerlink" title="3.2 异步绘制本地图片"></a>3.2 异步绘制本地图片</h3><p>本地图片的绘制，只需要提供图片在bundle内部的名字和frame就可以绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div></pre></td></tr></table></figure>
<p>###3.3  异步绘制UIView</p>
<p>对于<code>UIView</code>的绘制，我们只需要知道要绘制的<code>UIView</code>的frame和颜色即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//背景颜色</span></div><div class="line">[[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line"><span class="comment">//通过rect填充背景颜色</span></div><div class="line"><span class="built_in">CGContextFillRect</span>(context, rect);</div></pre></td></tr></table></figure>
<p>讲到现在，就剩下了关于文字的绘制，包括脱离了UILabel的纯文本的绘制和UILabel里文本的绘制，我们先说一下关于简单的纯NSString的绘制：</p>
<h3 id="3-4-异步绘制NSString"><a href="#3-4-异步绘制NSString" class="headerlink" title="3.4  异步绘制NSString"></a>3.4  异步绘制NSString</h3><p>作者通过传入字符串的字体，颜色和行高，以及位置就实现了纯文本的绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制名字</span></div><div class="line">[_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                 andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">             andHeight:rect.size.height];</div></pre></td></tr></table></figure>
<p>这个方法是作者在<code>NSString</code>的一个分类里自定义的，我们看一下它的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)context withPosition:(<span class="built_in">CGPoint</span>)p andFont:(<span class="built_in">UIFont</span> *)font andTextColor:(<span class="built_in">UIColor</span> *)color andHeight:(<span class="keyword">float</span>)height andWidth:(<span class="keyword">float</span>)width&#123;    </div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(width, font.pointSize+<span class="number">10</span>);    </div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);    </div><div class="line">    <span class="comment">//移动坐标系统，所有点的y增加了height</span></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,height);</div><div class="line">    </div><div class="line">    <span class="comment">//缩放坐标系统，所有点的x乘以1.0，所有的点的y乘以-1.0</span></div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//文字颜色</span></div><div class="line">    <span class="built_in">UIColor</span>* textColor = color;</div><div class="line">    </div><div class="line">    <span class="comment">//生成CTFont</span></div><div class="line">    <span class="built_in">CTFontRef</span> font1 = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)font.fontName, font.pointSize,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//用于创建CTParagraphStyleRef的一些基本数据</span></div><div class="line">    <span class="built_in">CGFloat</span> minimumLineHeight = font.pointSize,maximumLineHeight = minimumLineHeight+<span class="number">10</span>, linespace = <span class="number">5</span>;</div><div class="line">    <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByTruncatingTail;</div><div class="line">    </div><div class="line">    <span class="comment">//左对齐</span></div><div class="line">    <span class="built_in">CTTextAlignment</span> alignment = kCTLeftTextAlignment;</div><div class="line">    </div><div class="line">    <span class="comment">//创建CTParagraphStyleRef</span></div><div class="line">    <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">        &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">    &#125;,<span class="number">6</span>);</div><div class="line">    <span class="comment">//设置属性字典；对象，key</span></div><div class="line">    <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</div><div class="line">                                (__bridge <span class="keyword">id</span>)font1,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                style,kCTParagraphStyleAttributeName,</div><div class="line">                                <span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">//生成path，添加到cgcontex上</span></div><div class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</div><div class="line">    <span class="built_in">CGPathAddRect</span>(path,<span class="literal">NULL</span>,<span class="built_in">CGRectMake</span>(p.x, height-p.y-size.height,(size.width),(size.height)));</div><div class="line">    </div><div class="line">    <span class="comment">//生成CF属性字符串</span></div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span> attributes:attributes];</div><div class="line">    <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)attributedStr;</div><div class="line">    </div><div class="line">    <span class="comment">//从attributedString拿到ctframesetter</span></div><div class="line">    <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">    </div><div class="line">    <span class="comment">//从framesetter拿到 core text 的 ctframe</span></div><div class="line">    <span class="built_in">CTFrameRef</span> ctframe = <span class="built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="built_in">CFAttributedStringGetLength</span>(attributedString)),path,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//将ctframe绘制到context里面</span></div><div class="line">    <span class="built_in">CTFrameDraw</span>(ctframe,context);</div><div class="line">    </div><div class="line">    <span class="comment">//因为不是对象类型，需要释放</span></div><div class="line">    <span class="built_in">CGPathRelease</span>(path);</div><div class="line">    <span class="built_in">CFRelease</span>(font1);</div><div class="line">    <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">    <span class="built_in">CFRelease</span>(ctframe);</div><div class="line">    [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//恢复context坐标系统</span></div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>, height);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，作者根据文字的起点，颜色，字体大小和行高，使用Core Text，将文字绘制在了传入的context上面。</p>
<h3 id="3-5-异步绘制UILabel"><a href="#3-5-异步绘制UILabel" class="headerlink" title="3.5 异步绘制UILabel"></a>3.5 异步绘制UILabel</h3><p>而对于<code>UILabel</code>里面的绘制，作者也采取了类似的方法：</p>
<p>首先看一下在cell实现文件里，关于绘制label文字方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将文本内容绘制到图片上，也是异步绘制</span></div><div class="line">- (<span class="keyword">void</span>)drawText&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果发现label或detailLabel不存在，则重新add一次</span></div><div class="line">    <span class="keyword">if</span> (label==<span class="literal">nil</span>||detailLabel==<span class="literal">nil</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> addLabel];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//传入frame</span></div><div class="line">    label.frame = [_data[<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">    <span class="comment">//异步绘制text</span></div><div class="line">    [label setText:_data[<span class="string">@"text"</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在原帖</span></div><div class="line">    <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">        </div><div class="line">        detailLabel.frame = [[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        <span class="comment">//异步绘制text</span></div><div class="line">        [detailLabel setText:[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"text"</span>]];</div><div class="line">        detailLabel.hidden = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，对于帖子而言，是否存在原贴（当前贴是否是转发贴）是不固定的，所以需要在判断之后，用<code>hidden</code>属性来控制相应控件的隐藏和显示，而不是用<code>addSubView</code>的方法。</p>
<p>这里的label是作者自己封装的<code>VVeboLabel</code>。它具有高亮显示点击，利用正则表达式区分不同类型的特殊文字（话题名，用户名，网址，emoji）的功能。</p>
<p>简单介绍一下这个封装好的label：</p>
<ul>
<li>继承于<code>UIView</code>,可以响应用户点击，在初始化之后，<code>_textAlignment</code>,<code>_textColor</code>,<code>_font</code>,<code>_lienSpace</code>属性都会被初始化。</li>
<li>使用Core Text绘制文字。</li>
<li>持有两种UIImageView，用来显示默认状态和高亮状态的图片（将字符串绘制成图片）。</li>
<li>保存了四种特殊文字的颜色，用正则表达式识别以后，给其着色。</li>
</ul>
<p>这里讲一下这个label的<code>setText:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用coretext将文本绘制到图片。</span></div><div class="line">- (<span class="keyword">void</span>)setText:(<span class="built_in">NSString</span> *)text&#123;</div><div class="line">   </div><div class="line">    <span class="comment">//labelImageView 普通状态时的imageview</span></div><div class="line">    <span class="comment">//highlightImageView 高亮状态时的iamgeview</span></div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//绘制标记，初始化时赋一个随机值；clear之后更新一个随机值</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawFlag;</div><div class="line">    </div><div class="line">    <span class="comment">//是否正在高亮（在点击label的时候设置为yes，松开的时候设置为NO）</span></div><div class="line">    <span class="built_in">BOOL</span> isHighlight = highlighting;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSString</span> *temp = text;</div><div class="line">        _text = text;</div><div class="line">        <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.frame.size;</div><div class="line">        size.height += <span class="number">10</span>;</div><div class="line">       </div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, ![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]], <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="keyword">if</span> (context==<span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]]) &#123;</div><div class="line">            [<span class="keyword">self</span>.backgroundColor set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">        <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">        <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//Determine default text color</span></div><div class="line">        <span class="built_in">UIColor</span>* textColor = <span class="keyword">self</span>.textColor;</div><div class="line">        </div><div class="line">        <span class="comment">//Set line height, font, color and break mode</span></div><div class="line">        <span class="built_in">CGFloat</span> minimumLineHeight = <span class="keyword">self</span>.font.pointSize,maximumLineHeight = minimumLineHeight, linespace = <span class="keyword">self</span>.lineSpace;</div><div class="line">        </div><div class="line">        <span class="built_in">CTFontRef</span> font = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)<span class="keyword">self</span>.font.fontName, <span class="keyword">self</span>.font.pointSize,<span class="literal">NULL</span>);</div><div class="line">        <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByWordWrapping;</div><div class="line">        <span class="built_in">CTTextAlignment</span> alignment = <span class="built_in">CTTextAlignmentFromUITextAlignment</span>(<span class="keyword">self</span>.textAlignment);</div><div class="line">        <span class="comment">//Apply paragraph settings</span></div><div class="line">        <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">            &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">        &#125;,<span class="number">6</span>);</div><div class="line">    </div><div class="line">        <span class="comment">//属性字典</span></div><div class="line">        <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:(__bridge <span class="keyword">id</span>)font,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                    textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                    style,kCTParagraphStyleAttributeName,</div><div class="line">                                    <span class="literal">nil</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//拿到CFAttributedStringRef</span></div><div class="line">        <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:text attributes:attributes];</div><div class="line">        <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)[<span class="keyword">self</span> highlightText:attributedStr];</div><div class="line">        </div><div class="line">        <span class="comment">//根据attributedStringRef 获取CTFramesetterRef</span></div><div class="line">        <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">        </div><div class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">5</span>,(size.width),(size.height<span class="number">-5</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//根据 framesetter 和 attributedString 绘制text</span></div><div class="line">            [<span class="keyword">self</span> drawFramesetter:framesetter attributedString:attributedStr textRange:<span class="built_in">CFRangeMake</span>(<span class="number">0</span>, text.length) inRect:rect context:context];</div><div class="line">            </div><div class="line">            <span class="comment">//恢复context</span></div><div class="line">            <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">            <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">            <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//截取当前图片</span></div><div class="line">            <span class="built_in">UIImage</span> *screenShotimage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">            <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                </div><div class="line">                <span class="built_in">CFRelease</span>(font);</div><div class="line">                <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">                [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (drawFlag==flag) &#123;</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (isHighlight) &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//高亮状态：把图片付给highlightImageView</span></div><div class="line">                        <span class="keyword">if</span> (highlighting) &#123;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                highlightImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                highlightImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//非高亮状态，把图片付给labelImageView</span></div><div class="line">                        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                labelImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                labelImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"><span class="comment">//                    [self debugDraw];//绘制可触摸区域</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个被作者封装好的Label里面还有很多其他的方法，比如用正则表达式高亮显示特殊字符串等等。</p>
<p>关于tableView的优化，作者做了很多处理，使得这种显示内容比较丰富的cell在4s真机上好不卡顿，非常值得学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次分享一个关于性能优化的源码。&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;UITabelView&lt;/code&gt;在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，&lt;code&gt;UITabelView&lt;/code&gt;的性能将直接影响这个app的性能。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;UITabelView&lt;/code&gt;里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。&lt;/p&gt;
&lt;p&gt;但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。&lt;/p&gt;
&lt;p&gt;最近在看一些iOS性能优化的文章，我找到了&lt;a href=&quot;https://github.com/johnil/VVeboTableViewDemo&quot;&gt;VVeboTableView&lt;/a&gt;这个框架。严格来说这个不属于框架，而是作者用自己的方式优化&lt;code&gt;UITableView&lt;/code&gt;的一个实现。&lt;/p&gt;
&lt;p&gt;作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;看了源码之后，我把作者的思路整理了出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png&quot; alt=&quot;优化思路图&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PNChart源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/09/PNChart%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/09/PNChart源码解析/</id>
    <published>2017-02-09T03:33:20.000Z</published>
    <updated>2017-03-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一. 框架介绍"></a>一. 框架介绍</h2><p><a href="https://github.com/kevinzhow/PNChart">PNChart</a>是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。</p>
<p>该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类<code>PNGenericChart</code>,第二层就是所有类型的图表。提供一张图来直观感受一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png" alt="层级图"></p>
<blockquote>
<p>在这张图里，需要注意以下几点：</p>
<ol>
<li>带箭头的线和不带箭头的线的区别。</li>
<li><code>Data</code>类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有<code>Data</code>类，因为饼状图没有多组数据，而折线图<code>LineChart</code>是支持多组数据的，所以有<code>Data</code>类。</li>
<li><code>Item</code>类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。</li>
<li><code>BarChart</code>类里面的每一根柱子都是<code>PNBar</code>的实例（该类型的图表不在本篇讲解的范围之内）。</li>
</ol>
</blockquote>
<a id="more"></a>
<p>今天就来介绍一下该框架里的折线图的源码。上文提到过，该框架的折线图是支持多组数据的，也就是在同一张图表上显示多条折线。先带大家看一下效果图：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_2.png" alt="折线图"></p>
<p>折线图在效果上还是很简洁美观的，如果现在的你还不知道如何使用<code>CAShapeLayer</code>和<code>UIBezierPath</code>画图并附加动画效果，那么本篇源码解析非常适合你。</p>
<p>阅读本文之后，你可以掌握有关图形绘制的相关知识，也可以掌握自定义各种图形（<code>UIView</code>）的方法，而且你也应该有能力作出这样的图表，甚至更好！</p>
<p>在开始讲解之前，我先粗略介绍一下利用<code>CAShapeLayer</code>画图的过程。这个过程有三个大前提：</p>
<ul>
<li>因为<code>UIView</code>是对<code>CALayer</code>的封装，所以我们可以通过改变<code>UIView</code>所持有的<code>layer</code>属性来直接改变<code>UIView</code>的显示效果。</li>
<li><code>CAShapeLayer</code>是<code>CALayer</code>的子类。</li>
<li><code>CAShapeLayer</code>的使用是依赖于<code>UIBezierPath</code>的。<code>UIBezierPath</code>就是“路径”，可以理解为形状。不难理解，想象一下，如果我们想画一个图形，那么这个图形的形状（包括颜色）是必不可少的，而这个角色，就需要<code>UIBezierPath</code>来充当。</li>
</ul>
<p>那么了这三个大前提，我们就可以知道如何画图了：</p>
<ol>
<li>实例化一个<code>UIBezierPath</code>，并赋给<code>CAShapeLayer</code>实例的<code>path</code>属性。</li>
<li>将这个<code>CAShapeLayer</code>的实例添加到<code>UIView</code>的<code>layer</code>上。</li>
</ol>
<p>简单的代码演示上述过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">...自定义path...</div><div class="line"><span class="built_in">CAShapeLayer</span> *shapLayer = [<span class="built_in">CAShapeLayer</span> alloc] init];</div><div class="line">shapLayer.path = path;</div><div class="line">[<span class="keyword">self</span>.view.layer addSubLayer:shapeLayer];</div></pre></td></tr></table></figure></p>
<p>现在大致了解了画图的过程，我们来看一下该框架的作者是如何实现一个折线图的吧！</p>
<h2 id="二-源码解析"><a href="#二-源码解析" class="headerlink" title="二. 源码解析"></a>二. 源码解析</h2><p>首先看一下整个绘制折线图的步骤：</p>
<ol>
<li>图表的初始化。</li>
<li>获取横轴和纵轴的数据。</li>
<li>计算折线上所有拐点的x，y值。</li>
<li>计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）。</li>
<li>生成每个拐点上面的Label（可有可无）。</li>
<li>计算每条线段的贝塞尔曲线（UIBezierPath）。</li>
<li>将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</li>
<li>绘制所有折线（所有线段+所有圆圈）。</li>
<li>添加动画(可有可无)。</li>
<li>绘制x，y坐标轴。</li>
</ol>
<p>在集合代码具体讲解之前，我们要清楚三点（非常非常重要）：</p>
<ol>
<li>此折线图框架是可以设置拐点的样式的:可以设置为没有样式，也可以设置有样式：圆圈，方块，三角形。<ul>
<li>如果没有样式，则是简单的线段与线段的连接，在拐点处没有任何其他控件。</li>
<li>如果是有样式的，那么这条折线里的每条线段（在本篇文章里统一说成线段）之间是<strong>分离的</strong>，因为线段中间有一个拐点控件。本篇文章介绍的是圆圈样式（如上图所示，拐点控件是一个圆圈）。</li>
</ul>
</li>
<li>上文提到过，该折线图框架可以在一张图表里同时显示多条折线，也就是可以设置多组数据（一条折线对应一组数据）。因此，上面的3，4，5，6，7项都是用各自不同的一个数组保存的，数组里的每一个元素对应一条折线的数据。</li>
<li>既然同一个张图表可以显示多条折线：<ul>
<li>那么有些属性就是这些折线共有的，比如横坐标的value，这些属性保存在<code>PNLineChart</code>的实例里面。</li>
<li>有些属性是每条折线私有的，比如每条折线的颜色，纵坐标value等等，这些属性保存在<code>PNLineChartData</code>里面。每一条折线对应一个<code>PNLineChartData</code>实例。这些实例汇总到一个数组里面，这个数组由<code>PNLineChart</code>的实例管理。</li>
</ul>
</li>
</ol>
<p>在充分了解了这三点之后，我们结合一下代码来看一下具体的实现：</p>
<h3 id="1-图表的初始化"><a href="#1-图表的初始化" class="headerlink" title="1. 图表的初始化"></a>1. 图表的初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> setupDefaultValues];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setupDefaultValues &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> setupDefaultValues];</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//四个内边距</span></div><div class="line">    _chartMarginLeft = <span class="number">25.0</span>;</div><div class="line">    _chartMarginRight = <span class="number">25.0</span>;</div><div class="line">    _chartMarginTop = <span class="number">25.0</span>;</div><div class="line">    _chartMarginBottom = <span class="number">25.0</span>;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//真正绘制图表的画布（CavanWidth）的宽高</span></div><div class="line">    _chartCavanWidth = <span class="keyword">self</span>.frame.size.width - _chartMarginLeft - _chartMarginRight;</div><div class="line">    _chartCavanHeight = <span class="keyword">self</span>.frame.size.height - _chartMarginBottom - _chartMarginTop;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面这段代码我刻意省去了其他一些基本的设置，突出了图表布局的设置。</p>
<p>布局的设置是图表绘制的前提，因为在最开始的时候，就应该计算出“画布”，也就是图表内容（不包括坐标轴和坐标label）的具体大小和位置（内边距以内的部分）。</p>
<p>在这里，我们需要获取真正绘制图表的画布的宽高(<code>_chartCavanWidth</code>和<code>_chartCavanHeight</code>)。而且，要留意的是<code>_chartMarginLeft</code>在将来是要用作y轴Label的宽度，而<code>_chartMarginBottom</code>在将来是要用作x轴Label的高度的。</p>
</blockquote>
<p>用一张图直观看一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_4.png" alt="整个控件的大小和画布的大小"></p>
<h3 id="2-获取横轴和纵轴的数据"><a href="#2-获取横轴和纵轴的数据" class="headerlink" title="2. 获取横轴和纵轴的数据"></a>2. 获取横轴和纵轴的数据</h3><p>现在画布的位置和大小确定了，我们可以来看一下折线图是怎么画的了。<br>整个图表的绘制都基于三组数据（也可以是两组，为什么是两组，我稍后会给出解释），在讲解该框架是如何利用这些数据之前，我们来看一下这些数据是如何传进图表的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//设置x轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div><div class="line"><span class="comment">//设置y轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                             <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                             ]</div><div class="line"> ];</div><div class="line"><span class="comment">// Line Chart</span></div><div class="line"><span class="comment">//设置每个点的y值</span></div><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">PNLineChartData *data = [PNLineChartData new];</div><div class="line">data.pointLabelColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">data.color = PNTwitterColor;</div><div class="line">data.alpha = <span class="number">0.5</span>f;</div><div class="line">data.itemCount = dataArray.count;</div><div class="line">data.inflexionPointStyle = PNLineChartPointStyleCircle;</div><div class="line"><span class="comment">//这个block的作用是将上面的dataArray里的每一个值传给line chart。</span></div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">    <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">    <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//因为只有一条折线，所以只有一组数据</span></div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div><div class="line"><span class="comment">//绘制图表</span></div><div class="line">[<span class="keyword">self</span>.lineChart strokeChart];</div><div class="line"><span class="comment">//设置代理，响应点击</span></div><div class="line"><span class="keyword">self</span>.lineChart.delegate = <span class="keyword">self</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.lineChart];</div></pre></td></tr></table></figure>
<p>上面的代码我可以略去了很多多余的设置，目的是突出图表数据的设置。</p>
<p>不难看出，这里有三个数据传给了lineChart：</p>
<p>1.x轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的xLabel数组里元素的数量，内容宽度(<code>_chartCavanWidth</code>)和下边距（<code>_chartMarginBottom</code>），计算每个xlabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的xLabel（包括内容，位置）并显示出来，最后保存在<code>_xChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>2.y轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                ]</div><div class="line">    ];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的yLabel数组里元素的数量，内容高度(<code>_chartCavanHeight</code>)和左边距(<code>_chartMarginLeft</code>)，计算出每个ylabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的yLabel（包括内容，位置）并显示出来，最后保存在<code>_yChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>3.一条折线上每个点的实际值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">        <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">    &#125;;</div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div></pre></td></tr></table></figure>
<blockquote>
<p>着重讲一下block：为什么不直接把这个数组(<code>dataArray</code>)作为line chart的属性传进去呢？我认为作者是想提供一个接口给用户一个自己转化y值的机会。</p>
<p>像上文所说的，这里1，2是属于<code>lineChart</code>的数据，它适用于这张图表上所有的折线的。而3是属于某一条折线的。</p>
<p>现在回答一下为什么可以只传入两组数据：因为y轴数据可以由每个点的实际值数组得出。可以简单想一下，我们可以获取这些真实值里面的最大值，然后将它n等分，就自然得到了y轴数据了。</p>
</blockquote>
<p>我们已经布局了x轴和y轴的所有label，现在开始真正计算图表的数据了。</p>
<blockquote>
<p>注意：下面要介绍的3，4，5，6项都是在同一方法中计算出来，为了避免代码过长，我将每个部分分解开来做出解释。因为在同一方法里，所以这些涉及到for循环的语句是一致的。</p>
<p>整个图表的绘制都是依赖于数据的处理，所以3，4，5，6项也是理解该框架的一个关键！</p>
</blockquote>
<p>首先，我们需要计算每个数据点（拐点）的准确位置：</p>
<h3 id="3-计算折线上所有拐点的x，y值。"><a href="#3-计算折线上所有拐点的x，y值。" class="headerlink" title="3. 计算折线上所有拐点的x，y值。"></a>3. 计算折线上所有拐点的x，y值。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="comment">//还记得chartData属性么？它是用来保存多组折线的数据的，在这里只有一个折线，所以这个循环只循环一次）</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">   <span class="comment">//保存每条折线上的所有点的CGPoint  </span></div><div class="line">   <span class="built_in">NSMutableArray</span> *linePointsArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    <span class="comment">//遍历每条折线里的每个点    </span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//传入index，获取y值(调用的是上文提到的block)</span></div><div class="line">        yValue = chartData.getData(i).y;</div><div class="line">        <span class="comment">//当前点的x： _chartMarginLeft + _xLabelWidth / 2.0为0坐标，每多一个点就多一个_xLabelWidth</span></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) (i * _xLabelWidth + _chartMarginLeft + _xLabelWidth / <span class="number">2.0</span>);</div><div class="line">            </div><div class="line">        <span class="comment">//当前点的y：根据当前点的值和当前点所在的数组里的最大值的比例 以及 图表的总高度，算出当前点在图表里的y坐标</span></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>)[<span class="keyword">self</span> yValuePositionInLineChart:yValue];</div><div class="line">        <span class="comment">//保存所有拐点的坐标</span></div><div class="line">        [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//保存多条折线的CGPoint（这里只有一条折线，所以该数组只有一个元素）</span></div><div class="line">  [pathPoints addObject:[linePointsArray <span class="keyword">copy</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里需要注意两点：</p>
<ol>
<li>这里的<code>pathPoints</code>对应的是<code>lineChart</code>的<code>_pathPoints</code>属性。它是一个二维数组，保存每条折线上所有点的<code>CGPoint</code>。</li>
<li>y值的计算：是需要从y的真实值转化为这个拐点在图表里的y坐标，转化方法的实现(仔细看几遍就懂了)：</li>
</ol>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)yValuePositionInLineChart:(<span class="built_in">CGFloat</span>)y &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> innerGrade;<span class="comment">//真实的最大值与最小值的差 与 当前点与最小值的差 的比值</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(_yValueMax - _yValueMin)) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//特殊情况：当_yValueMax和_yValueMin相等的时候</span></div><div class="line">        innerGrade = <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        innerGrade = ((<span class="built_in">CGFloat</span>) y - _yValueMin) / (_yValueMax - _yValueMin);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//innerGrade 与画布的高度（_chartCavanHeight）相乘，就能得出在画布中的高度</span></div><div class="line">    <span class="keyword">return</span> _chartCavanHeight - (innerGrade * _chartCavanHeight) - (_yLabelHeight / <span class="number">2</span>) + _chartMarginTop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"><a href="#4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）" class="headerlink" title="4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"></a>4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//每条折线所有圆圈的贝塞尔曲线</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *pointPath = [<span class="built_in">UIBezierPath</span> bezierPath];    </div><div class="line">    <span class="comment">//inflexionWidth默认是6,是两个线段中间的距离（因为中间有一个圈圈，所以需要定一个距离）</span></div><div class="line">    <span class="built_in">CGFloat</span> inflexionWidth = chartData.inflexionPointWidth;</div><div class="line">    <span class="comment">//遍历每条折线里的每个点</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;  </div><div class="line">        <span class="comment">//1. 计算圆圈的rect：已当前点为中心，以inflexionWidth为半径</span></div><div class="line">        <span class="built_in">CGRect</span> circleRect = <span class="built_in">CGRectMake</span>(x - inflexionWidth / <span class="number">2</span>, y - inflexionWidth / <span class="number">2</span>, inflexionWidth, inflexionWidth);    </div><div class="line">        <span class="comment">//2. 计算圆圈的中心：由圆圈的x，y和inflexionWidth算出</span></div><div class="line">        <span class="built_in">CGPoint</span> circleCenter = <span class="built_in">CGPointMake</span>(circleRect.origin.x + (circleRect.size.width / <span class="number">2</span>), circleRect.origin.y + (circleRect.size.height / <span class="number">2</span>));</div><div class="line">        <span class="comment">//3.1 移动到圆圈的右中部</span></div><div class="line">        [pointPath moveToPoint:<span class="built_in">CGPointMake</span>(circleCenter.x + (inflexionWidth / <span class="number">2</span>), circleCenter.y)];        </div><div class="line">        <span class="comment">//3.2 画线（圆形）</span></div><div class="line">        [pointPath addArcWithCenter:circleCenter radius:inflexionWidth / <span class="number">2</span> startAngle:<span class="number">0</span> endAngle:(<span class="built_in">CGFloat</span>) (<span class="number">2</span> * M_PI) clockwise:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//保存到pointsPath数组里</span></div><div class="line">    [pointsPath insertObject:pointPath atIndex:lineIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>pointsPath</code>对应的是<code>lineChart</code>的<code>_pointsPath</code>属性。它是一个一维数组，保存每条折线上的圆圈贝塞尔曲线（UIBezierPath）。</p>
</blockquote>
<h3 id="5-生成每个拐点上面的Label（可有可无）"><a href="#5-生成每个拐点上面的Label（可有可无）" class="headerlink" title="5. 生成每个拐点上面的Label（可有可无）"></a>5. 生成每个拐点上面的Label（可有可无）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (chartData.showPointLabel) &#123;</div><div class="line">            [gradePathArray addObject:[<span class="keyword">self</span> createPointLabelFor:chartData.getData(i).rawY pointCenter:circleCenter width:inflexionWidth withChartData:chartData]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，在这里，这些label的实现是通过一个<code>CATextLayer</code>实现的，并不是生成一个个<code>Label</code>放在数组里保存，具体实现方法如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CATextLayer</span> *)createPointLabelFor:(<span class="built_in">CGFloat</span>)grade pointCenter:(<span class="built_in">CGPoint</span>)pointCenter width:(<span class="built_in">CGFloat</span>)width withChartData:(PNLineChartData *)chartData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//grade：提供textLayer显示的数值</span></div><div class="line">    <span class="comment">//pointCenter：根据pointCenter算出textLayer的x，y</span></div><div class="line">    <span class="comment">//width：根据width得到textLayer的总宽度</span></div><div class="line">    <span class="comment">//chartData：获取chartData里保存的textLayer上应该保存的字体大小和颜色</span></div><div class="line">    </div><div class="line">    <span class="built_in">CATextLayer</span> *textLayer = [[<span class="built_in">CATextLayer</span> alloc] init];</div><div class="line">    [textLayer setAlignmentMode:kCAAlignmentCenter];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的背景色</span></div><div class="line">    [textLayer setForegroundColor:[chartData.pointLabelColor <span class="built_in">CGColor</span>]];</div><div class="line">    [textLayer setBackgroundColor:<span class="keyword">self</span>.backgroundColor.CGColor];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的字体大小和颜色</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFont != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setFont:(__bridge <span class="built_in">CFTypeRef</span>) (chartData.pointLabelFont)];</div><div class="line">        textLayer.fontSize = [chartData.pointLabelFont pointSize];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的高度</span></div><div class="line">    <span class="built_in">CGFloat</span> textHeight = (<span class="built_in">CGFloat</span>) (textLayer.fontSize * <span class="number">1.1</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> textWidth = width * <span class="number">8</span>;</div><div class="line">    <span class="built_in">CGFloat</span> textStartPosY;</div><div class="line">    </div><div class="line">    textStartPosY = pointCenter.y - textLayer.fontSize;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.layer addSublayer:textLayer];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的文字显示格式</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFormat != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:chartData.pointLabelFormat, grade]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:_yLabelFormat, grade]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的位置和scale（1x，2x，3x）</span></div><div class="line">    [textLayer setFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, textWidth, textHeight)];</div><div class="line">    [textLayer setPosition:<span class="built_in">CGPointMake</span>(pointCenter.x, textStartPosY)];</div><div class="line">    textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> textLayer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-计算每条线段的贝塞尔曲线（UIBezierPath）"><a href="#6-计算每条线段的贝塞尔曲线（UIBezierPath）" class="headerlink" title="6. 计算每条线段的贝塞尔曲线（UIBezierPath）"></a>6. 计算每条线段的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//每一条线段的贝塞尔曲线（UIBezierPath），用数组装起来</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="comment">//chartPath（二维数组）：保存所有折线上所有线段的贝塞尔曲线。现在只有一条折线，所以只有一个元素</span></div><div class="line">    [chartPath insertObject:progressLines atIndex:lineIndex];</div><div class="line">    </div><div class="line">    <span class="comment">//progressLinePaths的每个元素是一个字典，字典里存放每一条线段的端点（from，to）</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *&gt; *progressLinePaths = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> last_x = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last_y = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//x，y的算法参考上文第三项</span></div><div class="line">            <span class="comment">// 计算index为0以后的点的位置</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) sqrt(pow(x - last_x, <span class="number">2</span>) + pow(y - last_y, <span class="number">2</span>));</div><div class="line">            <span class="keyword">float</span> last_x1 = last_x + (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> last_y1 = last_y + (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            <span class="keyword">float</span> x1 = x - (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> y1 = y - (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            </div><div class="line">            <span class="comment">//当前线段的端点</span></div><div class="line">            from = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(last_x1, last_y1)];</div><div class="line">            to = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x1, y1)];</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(from != <span class="literal">nil</span> &amp;&amp; to != <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//保存每一段的端点</span></div><div class="line">                [progressLinePaths addObject:@&#123;<span class="string">@"from"</span>: from,  <span class="string">@"to"</span>:to&#125;];</div><div class="line">                <span class="comment">//保存所有的端点</span></div><div class="line">                [lineStartEndPointsArray addObject:from];</div><div class="line">                [lineStartEndPointsArray addObject:to];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//保存所有折点的坐标</span></div><div class="line">            [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">            <span class="comment">//将当前的x转化为下一个点的last_x（y也一样）</span></div><div class="line">            last_x = x;</div><div class="line">            last_y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointsOfPath：保存所有折线里的所有线段两端的端点</span></div><div class="line">    [pointsOfPath addObject:[lineStartEndPointsArray <span class="keyword">copy</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//根据每一条线段的两个端点，成生每条线段的贝塞尔曲线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *calculatedRanges =</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            [currentProgressLine moveToPoint:[range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [currentProgressLine addLineToPoint:[range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"><a href="#7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。" class="headerlink" title="7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"></a>7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</h3><h4 id="7-1-所有线段的layer："><a href="#7-1-所有线段的layer：" class="headerlink" title="7.1 所有线段的layer："></a>7.1 所有线段的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)populateChartLines &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条线段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = <span class="keyword">self</span>.chartPath[lineIndex];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//_chartLineArray:二维数组，装载每个chartData对应的一个数组。这个数组的元素是这一条折线上所有线段对应的CAShapeLayer</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray[lineIndex] removeAllObjects];</div><div class="line">        </div><div class="line">        <span class="built_in">NSUInteger</span> progressLineIndex = <span class="number">0</span>;;</div><div class="line">        </div><div class="line">        <span class="comment">//遍历含有UIBezierPath对象元素的数组。在每个循环里新建一个CAShapeLayer对象，将UIBezierPath赋给它。</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *progressLinePath <span class="keyword">in</span> progressLines) &#123;</div><div class="line">            </div><div class="line">            PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">            </div><div class="line">            ...</div><div class="line">            </div><div class="line">            <span class="comment">//将当前线段的UIBezierPath赋给当前线段的CAShapeLayer</span></div><div class="line">            chartLine.path = progressLinePath.CGPath;</div><div class="line">            </div><div class="line">            <span class="comment">//添加layer</span></div><div class="line">            [<span class="keyword">self</span>.layer addSublayer:chartLine];</div><div class="line">            </div><div class="line">            <span class="comment">//保存当前线段的layer</span></div><div class="line">            [<span class="keyword">self</span>.chartLineArray[lineIndex] addObject:chartLine];</div><div class="line">            progressLineIndex++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-2-所有圆圈的layer："><a href="#7-2-所有圆圈的layer：" class="headerlink" title="7.2 所有圆圈的layer："></a>7.2 所有圆圈的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)recreatePointLayers &#123;</div><div class="line">- </div><div class="line">    <span class="keyword">for</span> (PNLineChartData *chartData <span class="keyword">in</span> _chartData) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">// create as many chart line layers as there are data-lines</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray addObject:[<span class="built_in">NSMutableArray</span> new]];</div><div class="line"></div><div class="line">        <span class="comment">// create point</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">        pointLayer.strokeColor = [[chartData.color colorWithAlphaComponent:chartData.alpha] <span class="built_in">CGColor</span>];</div><div class="line">        pointLayer.lineCap = kCALineCapRound;</div><div class="line">        pointLayer.lineJoin = kCALineJoinBevel;</div><div class="line">        pointLayer.fillColor = <span class="literal">nil</span>;</div><div class="line">        pointLayer.lineWidth = chartData.lineWidth;</div><div class="line">        [<span class="keyword">self</span>.layer addSublayer:pointLayer];</div><div class="line">        [<span class="keyword">self</span>.chartPointArray addObject:pointLayer];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里并没有将所有圆圈的<code>UIBezierPath</code>赋给对应的<code>layer</code>，而是在下一步，绘图的时候做的。</p>
</blockquote>
<h3 id="8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画"><a href="#8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画" class="headerlink" title="8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画"></a>8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)strokeChart &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 绘制所有折线（所有线段+所有圆圈）</span></div><div class="line">    <span class="comment">// 遍历所有折线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">       </div><div class="line">        PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的CAShapeLayer</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">CAShapeLayer</span> *&gt; *chartLines =<span class="keyword">self</span>.chartLineArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的CAShapeLayer</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = (<span class="built_in">CAShapeLayer</span> *) <span class="keyword">self</span>.chartPointArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//开始绘制折线</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.frame.size);</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的UIBezierPath</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = _chartPath[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的UIBezierPath</span></div><div class="line">        <span class="built_in">UIBezierPath</span> *pointPath = _pointPath[lineIndex];</div><div class="line"></div><div class="line">        <span class="comment">//7.2将圆圈的UIBezierPath赋给了圆圈的CAShapeLayer</span></div><div class="line">        pointLayer.path = pointPath.CGPath;</div><div class="line"></div><div class="line">        <span class="comment">//添加动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> begin];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; progressLines.count; index++) &#123;</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = chartLines[index];</div><div class="line">            <span class="comment">//chartLine strokeColor is already set. no need to override here</span></div><div class="line">            [chartLine addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">            chartLine.strokeEnd = <span class="number">1.0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// if you want cancel the point animation, comment this code, the point will show immediately</span></div><div class="line">        <span class="keyword">if</span> (chartData.inflexionPointStyle != PNLineChartPointStyleNone) &#123;</div><div class="line">            [pointLayer addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//提交动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> commit];</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="comment">//绘制完毕</span></div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意两点：</p>
<blockquote>
<p>1.如果想给layer添加动画，只需要实例化一个animation（在这里是<code>CABasicAnimation</code>）并调用layer的<code>addAnimation:</code>方法即可。我们看一下关于<code>CABasicAnimation</code>的实例化代码：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CABasicAnimation</span> *)pathAnimation &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.displayAnimated &amp;&amp; !_pathAnimation) &#123;</div><div class="line">        _pathAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">        <span class="comment">//持续时间</span></div><div class="line">        _pathAnimation.duration = <span class="number">1.0</span>;</div><div class="line">         <span class="comment">//类型</span></div><div class="line">        _pathAnimation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">        _pathAnimation.fromValue = @<span class="number">0.0</span>f;</div><div class="line">        _pathAnimation.toValue = @<span class="number">1.0</span>f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">self</span>.displayAnimated) &#123;</div><div class="line">        _pathAnimation = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _pathAnimation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2.在这里调用了<code>setNeedsDisplay</code>方法之后，会调用<code>drawRect：</code>方法，在这个方法里，完成了x，y坐标轴的绘制：</p>
</blockquote>
<h3 id="10-绘制x，y坐标轴"><a href="#10-绘制x，y坐标轴" class="headerlink" title="10.绘制x，y坐标轴"></a>10.绘制x，y坐标轴</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制坐标轴和背景竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isShowCoordinateAxis) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = <span class="number">10.</span>f;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPopContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPushContext</span>(ctx);</div><div class="line">        <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="keyword">self</span>.axisWidth);</div><div class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="keyword">self</span>.axisColor <span class="built_in">CGColor</span>]);</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> xAxisWidth = <span class="built_in">CGRectGetWidth</span>(rect) - (_chartMarginLeft + _chartMarginRight) / <span class="number">2</span>;</div><div class="line">        <span class="built_in">CGFloat</span> yAxisHeight = _chartMarginBottom + _chartCavanHeight;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制xy轴</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset - <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset + <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight - <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight + <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">//绘制x轴和y轴的label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.showLabel) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制x轴的小分割线</span></div><div class="line">            <span class="built_in">CGPoint</span> point;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(<span class="number">2</span> * _chartMarginLeft + (i * _xLabelWidth), _chartMarginBottom + _chartCavanHeight);</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y - <span class="number">2</span>);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制y轴的小分割线</span></div><div class="line">            <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(_chartMarginBottom + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x + <span class="number">2</span>, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">11</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.yUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.yUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(_chartMarginLeft + <span class="number">10</span> + <span class="number">5</span>, <span class="number">0</span>, <span class="number">30.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.yUnit inRect:drawRect font:font color:<span class="keyword">self</span>.yLabelColor];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.xUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.xUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, _chartMarginBottom + _chartCavanHeight - height / <span class="number">2</span>, <span class="number">25.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.xUnit inRect:drawRect font:font color:<span class="keyword">self</span>.xLabelColor];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.showYGridLines) &#123;</div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = _showLabel ? <span class="number">10.</span>f : <span class="number">0.0</span>f;</div><div class="line">        <span class="built_in">CGPoint</span> point;</div><div class="line">        </div><div class="line">        <span class="comment">//每一条竖线的跨度</span></div><div class="line">        <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">        </div><div class="line">        <span class="comment">//颜色</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.yGridLinesColor) &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, <span class="keyword">self</span>.yGridLinesColor.CGColor);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> lightGrayColor].CGColor);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//绘制每一条竖线</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; _yLabelNum; i++) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//拿到起点</span></div><div class="line">            point = <span class="built_in">CGPointMake</span>(_chartMarginLeft + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">            </div><div class="line">            <span class="comment">//将画笔移动到起点</span></div><div class="line">            <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//设置线的属性</span></div><div class="line">            <span class="built_in">CGFloat</span> dash[] = &#123;<span class="number">6</span>, <span class="number">5</span>&#125;;</div><div class="line">            <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">0.5</span>);</div><div class="line">            <span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);</div><div class="line">            <span class="built_in">CGContextSetLineDash</span>(ctx, <span class="number">0.0</span>, dash, <span class="number">2</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//设置这条线的终点</span></div><div class="line">            <span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//画线</span></div><div class="line">            <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一张完整的图表就可以画出来了。但是当前绘制的图表的折线都是直线，在上面还展示了一张曲线图。那么如果想绘制带有曲线的折线图应该怎么做呢？对，就是在贝塞尔曲线上下功夫。</p>
<p>当我们获取了所有线段的端点数组后，我们可以通过他们绘制弯曲的贝塞尔曲线（注意：该方法是对应上面对第6项的下半部分:生成每一个线段对贝塞尔曲线）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_showSmoothLines是用来控制是否绘制曲线折线的开关属性</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.showSmoothLines &amp;&amp; chartData.itemCount &gt;= <span class="number">4</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP1 = [range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP2 = [range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            [currentProgressLine moveToPoint:segmentP1];</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> midPoint = [PNLineChart midPointBetweenPoint1:segmentP1 andPoint2:segmentP2];</div><div class="line">            </div><div class="line">            <span class="comment">//以每条线段以中间点为分割点，分成两组。每一组形成柔和的外凸曲线，而不是内凹</span></div><div class="line">            [currentProgressLine addQuadCurveToPoint:midPoint</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP1]];</div><div class="line">            </div><div class="line">            [currentProgressLine addQuadCurveToPoint:segmentP2</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP2]];</div><div class="line">            </div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            [progressLineColors addObject:range[<span class="string">@"color"</span>]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下生成弯曲的贝塞尔曲线的方法：<code>controlPointBetweenPoint1:andPoint2</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回的点的x：是两点的中间；返回的点的y：与第二个点保持一致</span></div><div class="line">+ (<span class="built_in">CGPoint</span>)controlPointBetweenPoint1:(<span class="built_in">CGPoint</span>)point1 andPoint2:(<span class="built_in">CGPoint</span>)point2 &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//线段两端的中间点</span></div><div class="line">    <span class="built_in">CGPoint</span> controlPoint = [<span class="keyword">self</span> midPointBetweenPoint1:point1 andPoint2:point2];</div><div class="line">    </div><div class="line">    <span class="comment">//末端点 和  中间点y的差</span></div><div class="line">    <span class="built_in">CGFloat</span> diffY = abs((<span class="keyword">int</span>) (point2.y - controlPoint.y));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (point1.y &lt; point2.y)</div><div class="line">    <span class="comment">//如果前端点更高</span></div><div class="line">        controlPoint.y += diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (point1.y &gt; point2.y)</div><div class="line">    <span class="comment">//如果后端点更高</span></div><div class="line">        controlPoint.y -= diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> controlPoint;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，这样一来，直线的曲线图还有曲线的曲线图就大概掌握了。不过还差一个东西，就是图表对点击的响应。</p>
<p>我们需要思考一下：既然一张图表里可以显示多条折线，所以，当手指点击图表上的点以后，应该同时返回两个数据：</p>
<ol>
<li>点击了哪条折线上的这个点。</li>
<li>点击了这条折线上的哪个点。</li>
</ol>
<p>该框架的作者很好地完成了这两个任务，我们来看一下他是如何实现的：</p>
<h3 id="响应点击的代理方法"><a href="#响应点击的代理方法" class="headerlink" title="响应点击的代理方法"></a>响应点击的代理方法</h3><h4 id="点击了哪条折线的判断"><a href="#点击了哪条折线的判断" class="headerlink" title="点击了哪条折线的判断"></a>点击了哪条折线的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _endPointsOfPath[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历每个端点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// Closest distance from point to line</span></div><div class="line">            <span class="comment">//触摸点到线段的距离</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) fabs(((p2.x - p1.x) * (touchPoint.y - p1.y)) - ((p1.x - touchPoint.x) * (p1.y - p2.y)));</div><div class="line">            distance /= hypot(p2.x - p1.x, p1.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="comment">//如果距离小于5，则判断为“点击了当前的线段”，剩下的工作是判断具体点击了哪一条线段</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">5.0</span>) &#123;</div><div class="line">                <span class="comment">// Conform to delegate parameters, figure out what bezier path this CGPoint belongs to.</span></div><div class="line">                <span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *paths <span class="keyword">in</span> _chartPath) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *path <span class="keyword">in</span> paths) &#123;</div><div class="line">                        <span class="comment">//如果当前点处于UIBezierPath曲线上</span></div><div class="line">                        <span class="built_in">BOOL</span> pointContainsPath = <span class="built_in">CGPathContainsPoint</span>(path.CGPath, <span class="literal">NULL</span>, p1, <span class="literal">NO</span>);</div><div class="line">                        <span class="keyword">if</span> (pointContainsPath) &#123;</div><div class="line">                            <span class="comment">//点击了某一条折线</span></div><div class="line">                            [_delegate userClickedOnLinePoint:touchPoint lineIndex:lineIndex];</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    lineIndex++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="点击了哪个点的判断"><a href="#点击了哪个点的判断" class="headerlink" title="点击了哪个点的判断"></a>点击了哪个点的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchKeyPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _pathPoints[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历所有的点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">//获取到前一点的距离和后一点的距离</span></div><div class="line">            <span class="keyword">float</span> distanceToP1 = (<span class="keyword">float</span>) fabs(hypot(touchPoint.x - p1.x, touchPoint.y - p1.y));</div><div class="line">            <span class="keyword">float</span> distanceToP2 = (<span class="keyword">float</span>) hypot(touchPoint.x - p2.x, touchPoint.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> distance = MIN(distanceToP1, distanceToP2);</div><div class="line">            </div><div class="line">            <span class="comment">//如果较小的距离小于10，则判定为点击了某个点</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">10.0</span>) &#123;</div><div class="line">                <span class="comment">//点击了某一条折线上的某个点</span></div><div class="line">                [_delegate userClickedOnLineKeyPoint:touchPoint</div><div class="line">                                           lineIndex:p</div><div class="line">                                          pointIndex:(distance == distanceToP2 ? i + <span class="number">1</span> : i)];</div><div class="line">                </div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这下就完整了，一个带有响应功能的图表就做好啦！</p>
<h3 id="关于自定义UIView"><a href="#关于自定义UIView" class="headerlink" title="关于自定义UIView"></a>关于自定义UIView</h3><p>这里只是将图表的<code>layer</code>加在了<code>UIView</code>的layer上，那如果想完全自定义view的话，只需将图表的<code>layer</code>完全赋给<code>UIView</code>的layer即可，这样一来，想要画出任意形状的<code>UIView</code>都可以。</p>
<hr>
<h2 id="三-最后的话"><a href="#三-最后的话" class="headerlink" title="三. 最后的话"></a>三. 最后的话</h2><p>关于图表的绘制，相对贝塞尔曲线与<code>CALayer</code>来说，数据的处理是一个比较麻烦的点。但是一旦学会了折线图的绘制，了解了绘图原理，那么其他类型的图表就可以触类旁通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-框架介绍&quot;&gt;&lt;a href=&quot;#一-框架介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 框架介绍&quot;&gt;&lt;/a&gt;一. 框架介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot;&gt;PNChart&lt;/a&gt;是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。&lt;/p&gt;
&lt;p&gt;该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类&lt;code&gt;PNGenericChart&lt;/code&gt;,第二层就是所有类型的图表。提供一张图来直观感受一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png&quot; alt=&quot;层级图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这张图里，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带箭头的线和不带箭头的线的区别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data&lt;/code&gt;类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有&lt;code&gt;Data&lt;/code&gt;类，因为饼状图没有多组数据，而折线图&lt;code&gt;LineChart&lt;/code&gt;是支持多组数据的，所以有&lt;code&gt;Data&lt;/code&gt;类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BarChart&lt;/code&gt;类里面的每一根柱子都是&lt;code&gt;PNBar&lt;/code&gt;的实例（该类型的图表不在本篇讲解的范围之内）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/04/MJRefresh%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/04/MJRefresh 源码解析/</id>
    <published>2017-02-04T01:30:17.000Z</published>
    <updated>2017-03-20T07:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a>是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。</p>
<p>该框架的结构设计得很清晰，使用一个基类<code>MJRefreshComponent</code>来做一些基本的设定，然后通过继承的方式，让<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png" alt="框架组织结构图"></p>
<a id="more"></a>
<p>首先来看一下该控件的基类：MJRefreshComponent：</p>
<h2 id="MJRefreshComponent"><a href="#MJRefreshComponent" class="headerlink" title="MJRefreshComponent"></a>MJRefreshComponent</h2><p>这个类作为该控件几类，涵盖了基类所具备的成份：状态，回调block等，大致分成下面这5种职能：</p>
<h3 id="有哪些职能"><a href="#有哪些职能" class="headerlink" title="有哪些职能?"></a>有哪些职能?</h3><ol>
<li>声明控件的所有状态。</li>
<li>声明控件的回调函数。</li>
<li>添加监听。</li>
<li>提供刷新，停止刷新接口。</li>
<li>提供子类需要实现的方法。</li>
</ol>
<h3 id="职能如何实现？"><a href="#职能如何实现？" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><h4 id="1-声明控件的所有状态"><a href="#1-声明控件的所有状态" class="headerlink" title="1. 声明控件的所有状态"></a>1. 声明控件的所有状态</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 刷新控件的状态 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, MJRefreshState) &#123;</div><div class="line">    <span class="comment">/** 普通闲置状态 */</span></div><div class="line">    MJRefreshStateIdle = <span class="number">1</span>,</div><div class="line">    <span class="comment">/** 松开就可以进行刷新的状态 */</span></div><div class="line">    MJRefreshStatePulling,</div><div class="line">    <span class="comment">/** 正在刷新中的状态 */</span></div><div class="line">    MJRefreshStateRefreshing,</div><div class="line">    <span class="comment">/** 即将刷新的状态 */</span></div><div class="line">    MJRefreshStateWillRefresh,</div><div class="line">    <span class="comment">/** 所有数据加载完毕，没有更多的数据了 */</span></div><div class="line">    MJRefreshStateNoMoreData</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="2-声明控件的回调函数"><a href="#2-声明控件的回调函数" class="headerlink" title="2. 声明控件的回调函数"></a>2. 声明控件的回调函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 进入刷新状态的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentRefreshingBlock)();</div><div class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentbeginRefreshingCompletionBlock)();</div><div class="line"><span class="comment">/** 结束刷新后的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)();</div></pre></td></tr></table></figure>
<h4 id="3-添加监听"><a href="#3-添加监听" class="headerlink" title="3. 添加监听"></a>3. 添加监听</h4><p>监听的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObservers</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];<span class="comment">//contentOffset属性</span></div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];<span class="comment">//contentSize属性</span></div><div class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</div><div class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];<span class="comment">//UIPanGestureRecognizer 的state属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于监听的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 遇到这些情况就直接返回</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 这个就算看不见也需要处理</span></div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 看不见</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-提供刷新，停止刷新接口"><a href="#4-提供刷新，停止刷新接口" class="headerlink" title="4. 提供刷新，停止刷新接口"></a>4. 提供刷新，停止刷新接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark 进入刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)beginRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.beginRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> beginRefreshing];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)beginRefreshing</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        <span class="keyword">self</span>.alpha = <span class="number">1.0</span>;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.pullingPercent = <span class="number">1.0</span>;</div><div class="line">    <span class="comment">// 只要正在刷新，就完全显示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.window) &#123;</div><div class="line">        <span class="comment">//将状态切换为正在刷新</span></div><div class="line">        <span class="keyword">self</span>.state = MJRefreshStateRefreshing;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 预防正在刷新中时，调用本方法使得header inset回置失败</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateRefreshing) &#123;</div><div class="line">            <span class="comment">//将状态切换为即将刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateWillRefresh;</div><div class="line">            <span class="comment">// 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span></div><div class="line">            [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 结束刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)endRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)endRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.endRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> endRefreshing];</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 是否正在刷新</span></div><div class="line">- (<span class="built_in">BOOL</span>)isRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == MJRefreshStateRefreshing || <span class="keyword">self</span>.state == MJRefreshStateWillRefresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>交给子类实现的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<h4 id="5-提供子类需要实现的方法"><a href="#5-提供子类需要实现的方法" class="headerlink" title="5. 提供子类需要实现的方法"></a>5. 提供子类需要实现的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 交给子类们去实现</span></div><div class="line"><span class="comment">/** 初始化 */</span></div><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<p>从上面等结构图可以看出，紧接着这个基类，下面分为<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>,这里顺着<code>MJRefreshHeader</code>这个分支向下展开：</p>
<h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p><code>MJRefreshHeader</code>继承于<code>MJRefreshComponent</code>，它做了这几件事：</p>
<h3 id="有哪些职能？"><a href="#有哪些职能？" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>初始化。</li>
<li>设置header高度。</li>
<li>重新调整y值。</li>
<li>根据<code>contentOffset</code>的变化，来切换状态（默认状态，可以刷新的状态，正在刷新的状态），实现方法是：<code>scrollViewContentOffsetDidChange:</code>。</li>
<li>在切换状态时，执行相应的操作。实现方法是：<code>setState:</code>。</li>
</ol>
<h3 id="职能如何实现？-1"><a href="#职能如何实现？-1" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化</p>
<p>初始化有两种方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//传入block</span></div><div class="line">    cmp.refreshingBlock = refreshingBlock;</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingTarget:(<span class="keyword">id</span>)target refreshingAction:(SEL)action</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//设置self.refreshingTarget 和 self.refreshingAction</span></div><div class="line">    [cmp setRefreshingTarget:target refreshingAction:action];</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-设置header高度"><a href="#2-设置header高度" class="headerlink" title="2. 设置header高度"></a>2. 设置header高度</h4><p>通过重写<code>prepare</code>方法来设置header的高度：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置用于在NSUserDefaults里存储时间的key</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</div><div class="line">    </div><div class="line">    <span class="comment">// 设置header的高度</span></div><div class="line">    <span class="keyword">self</span>.mj_h = MJRefreshHeaderHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-重新调整y值"><a href="#3-重新调整y值" class="headerlink" title="3. 重新调整y值"></a>3. 重新调整y值</h4><p>通过重写<code>placeSubviews</code>方法来重新调整y值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</span></div><div class="line">    <span class="keyword">self</span>.mj_y = - <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.ignoredScrollViewContentInsetTop;</div><div class="line">    <span class="comment">//self.ignoredScrollViewContentInsetTop 如果是10，那么就向上移动10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-状态切换的代码："><a href="#4-状态切换的代码：" class="headerlink" title="4. 状态切换的代码："></a>4. 状态切换的代码：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    <span class="comment">// 正在刷新的状态</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.window == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//- self.scrollView.mj_offsetY：-（-54-64）= 118 ： 刷新的时候，偏移量是不动的。偏移量 = 状态栏 + 导航栏 + header的高度</span></div><div class="line">        <span class="comment">//_scrollViewOriginalInset.top：64 （状态栏 + 导航栏）</span></div><div class="line">        <span class="comment">//insetT 取二者之间大的那一个</span></div><div class="line">        <span class="built_in">CGFloat</span> insetT = - <span class="keyword">self</span>.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - <span class="keyword">self</span>.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</div><div class="line">       </div><div class="line">        <span class="comment">//118</span></div><div class="line">        insetT = insetT &gt; <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top ? <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top : insetT;</div><div class="line">        </div><div class="line">        <span class="comment">//设置contentInset</span></div><div class="line">        <span class="keyword">self</span>.scrollView.mj_insetT = insetT;</div><div class="line">        </div><div class="line">        <span class="comment">// 记录刷新的时候的偏移量 -54 = 64 - 118</span></div><div class="line">        <span class="keyword">self</span>.insetTDelta = _scrollViewOriginalInset.top - insetT;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 跳转到下一个控制器时，contentInset可能会变</span></div><div class="line">     _scrollViewOriginalInset = <span class="keyword">self</span>.scrollView.contentInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 记录当前的contentOffset</span></div><div class="line">    <span class="built_in">CGFloat</span> offsetY = <span class="keyword">self</span>.scrollView.mj_offsetY;</div><div class="line"></div><div class="line">    <span class="comment">// 头部控件刚好全部出现的offsetY,默认是-64（20 + 44）</span></div><div class="line">    <span class="built_in">CGFloat</span> happenOffsetY = - <span class="keyword">self</span>.scrollViewOriginalInset.top;</div><div class="line">    </div><div class="line">    <span class="comment">// 向上滚动，直接返回</span></div><div class="line">    <span class="keyword">if</span> (offsetY &gt; happenOffsetY) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 从普通 到 即将刷新 的临界距离</span></div><div class="line">    <span class="built_in">CGFloat</span> normal2pullingOffsetY = happenOffsetY - <span class="keyword">self</span>.mj_h;<span class="comment">// -64 - 54 = -118</span></div><div class="line">    </div><div class="line">    <span class="comment">//下拉的百分比：下拉的距离与header高度的比值</span></div><div class="line">    <span class="built_in">CGFloat</span> pullingPercent = (happenOffsetY - offsetY) / <span class="keyword">self</span>.mj_h;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollView.isDragging) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//记录当前下拉的百分比</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前为默认状态 &amp;&amp; 下拉的距离大于临界距离（将tableview下拉得很低），则将状态切换为可以刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStatePulling;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前状态为可以刷新 &amp;&amp; 下拉的距离小于临界距离，则将状态切换为默认</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling) &#123;<span class="comment">// 即将刷新 &amp;&amp; 手松开</span></div><div class="line">        <span class="comment">// 手松开 &amp;&amp; 状态为可以刷新（MJRefreshStatePulling）时 开始刷新</span></div><div class="line">        [<span class="keyword">self</span> beginRefreshing];        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pullingPercent &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//手松开后，默认状态时，恢复self.pullingPercent</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意三点：</p>
<ol>
<li>这里的状态有三种：默认状态（MJRefreshStateIdle），可以刷新的状态（MJRefreshStatePulling）以及正在刷新的状态（MJRefreshStateRefreshing）。</li>
<li>状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。</li>
<li>注意:<strong>可以刷新的状态</strong>和<strong>正在刷新的状态</strong>是不同的。因为在手指还贴在屏幕的时候是不能进行刷新的。所以即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。一旦手指离开了屏幕，马上将状态切换为正在刷新。 </li>
</ol>
</blockquote>
<p>这里提供一张图来体现三个状态的不同：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_2.png" alt="三个状态"></p>
<h4 id="5-状态切换时的相应操作："><a href="#5-状态切换时的相应操作：" class="headerlink" title="5. 状态切换时的相应操作："></a>5. 状态切换时的相应操作：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//============== 设置状态为默认状态 =============//</span></div><div class="line">        </div><div class="line">        <span class="comment">//如果当前不是正在刷新就返回，因为这个方法主要针对从正在刷新状态（oldstate）到默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState != MJRefreshStateRefreshing) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//刷新完成后，保存刷新完成的时间</span></div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:[<span class="built_in">NSDate</span> date] forKey:<span class="keyword">self</span>.lastUpdatedTimeKey];</div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</div><div class="line">        </div><div class="line">        <span class="comment">// 恢复inset和offset</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">            </div><div class="line">            <span class="comment">//118 -&gt; 64（剪去了header的高度）</span></div><div class="line">            <span class="keyword">self</span>.scrollView.mj_insetT += <span class="keyword">self</span>.insetTDelta;</div><div class="line">            </div><div class="line">            <span class="comment">// 自动调整透明度</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.isAutomaticallyChangeAlpha) <span class="keyword">self</span>.alpha = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.pullingPercent = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.endRefreshingCompletionBlock) &#123;</div><div class="line">                <span class="comment">//调用刷新完成的block</span></div><div class="line">                <span class="keyword">self</span>.endRefreshingCompletionBlock();</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">         <span class="comment">//============== 设置状态为正在刷新状态 =============//</span></div><div class="line">         <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            </div><div class="line">             [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">               </div><div class="line">                <span class="built_in">CGFloat</span> top = <span class="keyword">self</span>.scrollViewOriginalInset.top + <span class="keyword">self</span>.mj_h;<span class="comment">//64 + 54 (都是默认的高度)</span></div><div class="line">                <span class="comment">// 重新设置contentInset，top = 118</span></div><div class="line">                <span class="keyword">self</span>.scrollView.mj_insetT = top;</div><div class="line">                <span class="comment">// 设置滚动位置</span></div><div class="line">                [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, -top) animated:<span class="literal">NO</span>];</div><div class="line">                 </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                <span class="comment">//调用进行刷新的block</span></div><div class="line">                [<span class="keyword">self</span> executeRefreshingCallback];</div><div class="line">            &#125;];</div><div class="line">         &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意两点：</p>
<ol>
<li>这里状态的切换，主要围绕着两种：默认状态和正在刷新状态。也就是针对<strong>开始刷新</strong>和<strong>结束刷新</strong>这两个切换点。</li>
<li>从正在刷新状态状态切换为默认状态时（结束刷新），需要记录刷新结束的时间。因为header里面有一个默认的label是用来显示上次刷新的时间的。</li>
</ol>
</blockquote>
<h2 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h2><p>这个类是<code>MJRefreshHeader</code>类的子类，它做了两件事：</p>
<h3 id="有哪些职能？-1"><a href="#有哪些职能？-1" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>简单布局了<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>。</li>
<li>根据控件状态的切换（默认状态，正在刷新状态），实现了这两个label显示的文字的切换。</li>
</ol>
<p>给一张图，让大家直观感受一下这两个控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_3.png" alt="两个Label"></p>
<h3 id="职能如何实现？-2"><a href="#职能如何实现？-2" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>这个类通过覆盖父类三个方法来实现上述两个实现：</p>
<h4 id="方法1：prepare方法"><a href="#方法1：prepare方法" class="headerlink" title="方法1：prepare方法"></a>方法1：prepare方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = MJRefreshLabelLeftInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化文字</span></div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，将每一个状态对应的提示文字放入一个字典里面,key是状态的NSNumber形式</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (title == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">self</span>.stateTitles[@(state)] = title;</div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(<span class="keyword">self</span>.state)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews方法"><a href="#方法2：placeSubviews方法" class="headerlink" title="方法2：placeSubviews方法"></a>方法2：placeSubviews方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> noConstrainsOnStatusLabel = <span class="keyword">self</span>.stateLabel.constraints.count == <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label是隐藏的，则让状态label撑满整个header</span></div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) <span class="keyword">self</span>.stateLabel.frame = <span class="keyword">self</span>.bounds;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label不是隐藏的，根据约束设置更新时间label和状态label（高度各占一半）</span></div><div class="line">        <span class="built_in">CGFloat</span> stateLabelH = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) &#123;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_y = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_h = stateLabelH;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 更新时间label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y = stateLabelH;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_h = <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里主要是对<code>lastUpdatedTimeLabel</code>和<code>stateLabel</code>进行布局。要注意<code>lastUpdatedTimeLabel</code>隐藏的情况。</p>
</blockquote>
<h4 id="方法3-setState-方法"><a href="#方法3-setState-方法" class="headerlink" title="方法3: setState:方法"></a>方法3: setState:方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 设置状态文字</span></div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(state)];</div><div class="line">    </div><div class="line">    <span class="comment">// 重新设置key（重新显示时间）</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = <span class="keyword">self</span>.lastUpdatedTimeKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，根据传入的state的不同，在<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>里切换相应的文字。</p>
<ul>
<li><code>stateLabel</code>里的文字直接从<code>stateTitles</code>字典里取出即可。</li>
<li><code>lastUpdatedTimeLabel</code>里的文字需要通过一个方法来取出即可：</li>
</ul>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setLastUpdatedTimeKey:(<span class="built_in">NSString</span> *)lastUpdatedTimeKey</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> setLastUpdatedTimeKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果label隐藏了，就不用再处理</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//根据key，从NSUserDefaults获取对应的NSData型时间</span></div><div class="line">    <span class="built_in">NSDate</span> *lastUpdatedTime = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果有block，从block里拿来时间，这应该是用户自定义显示时间格式的渠道</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeText) &#123;</div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = <span class="keyword">self</span>.lastUpdatedTimeText(lastUpdatedTime);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果没有block，就按照下面的默认方法显示时间格式</span></div><div class="line">    <span class="keyword">if</span> (lastUpdatedTime) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 获得了上次更新时间</span></div><div class="line">        <span class="comment">// 1.获得年月日</span></div><div class="line">        <span class="built_in">NSCalendar</span> *calendar = [<span class="keyword">self</span> currentCalendar];</div><div class="line">        <span class="built_in">NSUInteger</span> unitFlags = <span class="built_in">NSCalendarUnitYear</span>| <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitDay</span> |<span class="built_in">NSCalendarUnitHour</span> |<span class="built_in">NSCalendarUnitMinute</span>;</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp1 = [calendar components:unitFlags fromDate:lastUpdatedTime];</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp2 = [calendar components:unitFlags fromDate:[<span class="built_in">NSDate</span> date]];</div><div class="line">        </div><div class="line">        <span class="comment">// 2.格式化日期</span></div><div class="line">        <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">        <span class="built_in">BOOL</span> isToday = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> ([cmp1 day] == [cmp2 day]) &#123;</div><div class="line">            <span class="comment">//今天，省去年月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@" HH:mm"</span>;</div><div class="line">            isToday = <span class="literal">YES</span>;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([cmp1 year] == [cmp2 year]) &#123; <span class="comment">// 今年</span></div><div class="line">            <span class="comment">//今年，省去年，显示月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@"MM-dd HH:mm"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//其他，年月日都显示</span></div><div class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSString</span> *time = [formatter stringFromDate:lastUpdatedTime];</div><div class="line">        </div><div class="line">        <span class="comment">// 3.显示日期</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          isToday ? [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderDateTodayText] : <span class="string">@""</span>,</div><div class="line">                                          time];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有获得上次更新时间（应该是第一次更新或者多次更新，之前的更新都失败了）</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderNoneLastDateText]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意两点：</p>
<ol>
<li>作者通过使用block来让用户自己定义日期现实的格式，如果用户没有自定义，就使用作者提供的默认格式。</li>
<li>在默认格式的设置里，判断了是否是今日，是否是今年的情况。在以后设计显示时间的labe的时候可以借鉴一下。</li>
</ol>
</blockquote>
<h2 id="MJRefreshNormalHeader"><a href="#MJRefreshNormalHeader" class="headerlink" title="MJRefreshNormalHeader"></a>MJRefreshNormalHeader</h2><h3 id="有哪些职能？-2"><a href="#有哪些职能？-2" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>MJRefreshNormalHeader 继承于 MJRefreshStateHeader，它主要做了两件事：</p>
<ol>
<li>它在MJRefreshStateHeader上添加了<code>_arrowView</code>和<code>loadingView</code>。</li>
<li>布局了这两个view并在Refresh控件的状态切换的时候改变这两个view的样式。</li>
</ol>
<p>还是给一张图来直观感受一下这两个view：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_4.png" alt="两个view"></p>
<h3 id="职能如何实现？-3"><a href="#职能如何实现？-3" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>同MJRefreshStateHeader一样，也是重写了父类的三个方法：</p>
<h4 id="方法1：prepare"><a href="#方法1：prepare" class="headerlink" title="方法1：prepare"></a>方法1：prepare</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.activityIndicatorViewStyle = <span class="built_in">UIActivityIndicatorViewStyleGray</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews"><a href="#方法2：placeSubviews" class="headerlink" title="方法2：placeSubviews"></a>方法2：placeSubviews</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 首先将箭头的中心点x设为header宽度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterX = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.stateLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//在stateLabel里的文字宽度和更新时间里的文字宽度里取较宽的</span></div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="comment">//根据self.labelLeftInset和textWidth向左移动中心点x</span></div><div class="line">        arrowCenterX -= textWidth / <span class="number">2</span> + <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//中心点y永远设置为header的高度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterY = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//获得了最终的center，而这个center同时适用于arrowView和loadingView，因为二者是不共存的。</span></div><div class="line">    <span class="built_in">CGPoint</span> arrowCenter = <span class="built_in">CGPointMake</span>(arrowCenterX, arrowCenterY);</div><div class="line">    </div><div class="line">    <span class="comment">// 箭头</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.arrowView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//控件大小等于图片大小</span></div><div class="line">        <span class="keyword">self</span>.arrowView.mj_size = <span class="keyword">self</span>.arrowView.image.size;</div><div class="line">        <span class="keyword">self</span>.arrowView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">// 菊花</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.loadingView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.loadingView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//arrowView的色调与stateLabel的字体颜色一致</span></div><div class="line">    <span class="keyword">self</span>.arrowView.tintColor = <span class="keyword">self</span>.stateLabel.textColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意一点：因为<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>是上下并排分布的，而<code>arrowView</code>或<code>loadingView</code>是在这二者的左边，所以为了避免这两组重合，在计算<code>arrowView</code>或<code>loadingView</code>的center的时候，需要获取<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>两个控件的宽度并比较大小，将较大的一个作为两个label的‘最宽距离’，再计算center，这样一来就不会重合了。<br>而对于如何计算宽度，作者给出了一个方案，大家可以在以后的实践中使用：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)mj_textWith &#123;</div><div class="line">    <span class="built_in">CGFloat</span> stringWidth = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.text.length &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span></div><div class="line">        stringWidth =[<span class="keyword">self</span>.text</div><div class="line">                      boundingRectWithSize:size</div><div class="line">                      options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></div><div class="line">                      attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:<span class="keyword">self</span>.font&#125;</div><div class="line">                      context:<span class="literal">nil</span>].size.width;</div><div class="line"><span class="meta">#else</span></div><div class="line">        </div><div class="line">        stringWidth = [<span class="keyword">self</span>.text sizeWithFont:<span class="keyword">self</span>.font</div><div class="line">                             constrainedToSize:size</div><div class="line">                                 lineBreakMode:<span class="built_in">NSLineBreakByCharWrapping</span>].width;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stringWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法3-setState"><a href="#方法3-setState" class="headerlink" title="方法3: setState:"></a>方法3: setState:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 根据状态更新arrowView和loadingView的显示</span></div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//1. 设置为默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState == MJRefreshStateRefreshing) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//1.1 从正在刷新状态中切换过来</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            </div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">                <span class="comment">//隐藏菊花</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">0.0</span>;</div><div class="line">                </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// 如果执行完动画发现不是idle状态，就直接返回，进入其他状态</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateIdle) <span class="keyword">return</span>;</div><div class="line">                <span class="comment">//菊花停止旋转</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>;</div><div class="line">                [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">                <span class="comment">//显示箭头</span></div><div class="line">                <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 从其他状态中切换过来</span></div><div class="line">            [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">            <span class="comment">//显示箭头并设置为初始状态</span></div><div class="line">            <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStatePulling) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 设置为可以刷新状态</span></div><div class="line">        [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">            <span class="comment">//箭头倒立</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformMakeRotation</span>(<span class="number">0.000001</span> - M_PI);</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//3. 设置为正在刷新状态</span></div><div class="line">        <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>; <span class="comment">// 防止refreshing -&gt; idle的动画完毕动作没有被执行</span></div><div class="line">        <span class="comment">//菊花旋转</span></div><div class="line">        [<span class="keyword">self</span>.loadingView startAnimating];</div><div class="line">        <span class="comment">//隐藏arrowView</span></div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此为止，我们已经从<code>MJRefreshComponent</code>到<code>MJRefreshNormalHeader</code>的实现过程看了一遍。可以看出，作者将<code>prepare</code>,<code>placeSubviews</code>以及<code>setState：</code>方法作为基类的方法，让下面的子类去一层一层实现。</p>
<p>而每一层的子类，根据自身的职责，分别按照自己的方式来实现这三个方法：</p>
<ul>
<li><code>MJRefreshHeader</code>: 负责header的高度和调整header自身在外部的位置。</li>
<li><code>MJRefreshStateHeader</code>:负责header内部的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>的布局和不同状态下内部文字的显示。</li>
<li><code>MJRefreshNormalHeader</code>:负责header内部的<code>loadingView</code>以及<code>arrowView</code>的布局和不同状态下的显示。</li>
</ul>
<p>这样做的好处是，如果想要增加某种类型的header，只要在某一层上做文章即可。例如该框架里的<code>MJRefreshGifHeader</code>,它和<code>MJRefreshNormalHeader</code>属于同一级，都是继承于<code>MJRefreshStateHeader</code>。因为二者都具有相同形式的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>，唯一不同的就是左侧的部分：</p>
<ul>
<li><code>MJRefreshNormalHeader</code>的左侧是箭头。</li>
<li><code>MJRefreshGifHeader</code>的左侧则是一个gif动画。</li>
</ul>
<p>还是提供一张图来直观感受一下：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_5.png" alt="normalHeader 与 gifHeader"></p>
<p>下面我们来看一下的实现：</p>
<h2 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h2><p>它提供了两个接口，是用来设置不同状态下使用的图片数组的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images duration:(<span class="built_in">NSTimeInterval</span>)duration forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> (images == <span class="literal">nil</span>) <span class="keyword">return</span>; </div><div class="line">    </div><div class="line">    <span class="comment">//设置不同状态下的图片组和持续时间</span></div><div class="line">    <span class="keyword">self</span>.stateImages[@(state)] = images; </div><div class="line">    <span class="keyword">self</span>.stateDurations[@(state)] = @(duration); </div><div class="line">    </div><div class="line">    <span class="comment">/* 根据图片设置控件的高度 */</span> </div><div class="line">    <span class="built_in">UIImage</span> *image = [images firstObject]; </div><div class="line">    <span class="keyword">if</span> (image.size.height &gt; <span class="keyword">self</span>.mj_h) &#123; </div><div class="line">        <span class="keyword">self</span>.mj_h = image.size.height; </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">   <span class="comment">//如果没有传入duration，则根据图片的多少来计算</span></div><div class="line">    [<span class="keyword">self</span> setImages:images duration:images.count * <span class="number">0.1</span> forState:state]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="有哪些职能？-3"><a href="#有哪些职能？-3" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>然后，和<code>MJRefreshNormalHeader</code>一样，它也重写了基类提供的三个方法来实现显示gif图片的职能。</p>
<h3 id="职能如何实现？-4"><a href="#职能如何实现？-4" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化和label的间距<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = <span class="number">20</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####2. 根据label的宽度和存在与否设置gif的位置<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">//如果约束存在，就立即返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.gifView.constraints.count) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.gifView.frame = <span class="keyword">self</span>.bounds;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden &amp;&amp; <span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel都在隐藏状态，将gif剧中显示</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeCenter</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel中至少一个存在，则根据label的宽度设置gif的位置</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeRight</span>;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="keyword">self</span>.gifView.mj_w = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span> - textWidth * <span class="number">0.5</span> - <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-根据传入状态的不同来设置动画"><a href="#3-根据传入状态的不同来设置动画" class="headerlink" title="3. 根据传入状态的不同来设置动画"></a>3. 根据传入状态的不同来设置动画</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//1. 如果传进来的状态是可以刷新和正在刷新</span></div><div class="line">        <span class="built_in">NSArray</span> *images = <span class="keyword">self</span>.stateImages[@(state)];</div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">//1.1 单张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.image = [images lastObject];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 多张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.animationImages = images;</div><div class="line">            <span class="keyword">self</span>.gifView.animationDuration = [<span class="keyword">self</span>.stateDurations[@(state)] doubleValue];</div><div class="line">            [<span class="keyword">self</span>.gifView startAnimating];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">        <span class="comment">//2.如果传进来的状态是默认状态</span></div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>Footer类是用来处理上拉加载的，实现原理和下拉刷新很类似，在这里先不介绍了～</p>
<p>总的来说，该框架设计得非常工整：通过一个基类来定义一些状态和一些需要子类实现的接口。通过一层一层地继承，让每一层的子类各司其职，只完成真正属于自己的任务，提高了框架的可定制性，而且对于功能的扩展和bug的追踪也很有帮助，非常值得我们参考与借鉴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;MJRefresh&lt;/a&gt;是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。&lt;/p&gt;
&lt;p&gt;该框架的结构设计得很清晰，使用一个基类&lt;code&gt;MJRefreshComponent&lt;/code&gt;来做一些基本的设定，然后通过继承的方式，让&lt;code&gt;MJRefreshHeader&lt;/code&gt;和&lt;code&gt;MJRefreshFooter&lt;/code&gt;分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png&quot; alt=&quot;框架组织结构图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/04/SDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/04/SDWebImage源码解析/</id>
    <published>2017-02-04T01:24:37.000Z</published>
    <updated>2017-03-20T07:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信对于广大的iOS开发者，对<a href="https://github.com/rs/SDWebImage">SDWebImage</a>并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。</p>
<p>在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>] completed:^(<span class="built_in">UIImage</span> * _Nullable image, <span class="built_in">NSError</span> * _Nullable error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> * _Nullable imageURL) &#123;</div><div class="line">        </div><div class="line">        imageview.image = image;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图片加载完成"</span>);</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//图片下载完成后直接显示下载后的图片</span></div><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>]];</div></pre></td></tr></table></figure>
<p>在最开始先简单介绍这个框架：</p>
<p>这个框架的核心类是<code>SDWebImageManger</code>，在外部有<code>UIImageView+WebCache</code> 和 <code>UIButton+WebCache</code> 为下载图片的操作提供接口。内部有<code>SDWebImageManger</code>负责处理和协调 <code>SDWebImageDownloader</code> 和 <code>SDWebImageCache</code>：<code>SDWebImageDownloader</code>负责具体的下载任务，<code>SDWebImageCache</code>负责关于缓存的工作：添加，删除，查询缓存。</p>
<p>首先我们大致看一下这个框架的调用流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage"></p>
<p>从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。</p>
<p>OK～基本流程大概清楚了，我们看一下每个层具体实现吧～</p>
<a id="more"></a>
<hr>
<p>##UIKit层</p>
<p>该框架最外层的类是<code>UIImageView +WebCache</code>，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIImageView + WebCache.h ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>而这个方法里面，调用的是<code>UIView+WebCache</code>分类的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？<br>因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。</p>
</blockquote>
<p>简单看一下这个方法的实现（省略的代码用…代替）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line"></div><div class="line">   <span class="comment">//valid key：UIImageView || UIButton</span></div><div class="line">   <span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</div><div class="line">   <span class="comment">//UIView+WebCacheOperation 的 operationDictionary</span></div><div class="line">   <span class="comment">//下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突</span></div><div class="line">   [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line">   </div><div class="line"></div><div class="line">   <span class="comment">//添加临时的占位图（在不延迟添加占位图的option下）</span></div><div class="line">   <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">       &#125;);</div><div class="line">   &#125;    </div><div class="line">   <span class="comment">//如果url存在</span></div><div class="line">   <span class="keyword">if</span> (url) &#123;     </div><div class="line">      ...</div><div class="line">       __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">      <span class="comment">//SDWebImageManager下载图片</span></div><div class="line">       <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">         </div><div class="line">           ...</div><div class="line">           <span class="comment">//dispatch_main_sync_safe : 保证block能在主线程进行</span></div><div class="line">           dispatch_main_async_safe(^&#123;</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;               </div><div class="line">               <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">                    <span class="comment">//image，而且不自动替换 placeholder image</span></div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">                   <span class="keyword">return</span>;                    </div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                   <span class="comment">//存在image，需要马上替换 placeholder image</span></div><div class="line">                   [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                   [sself sd_setNeedsLayout];                </div><div class="line">               &#125; <span class="keyword">else</span> &#123;                    </div><div class="line">                   <span class="comment">//没有image，在图片下载完之后显示 placeholder image</span></div><div class="line">                   <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                       [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                       [sself sd_setNeedsLayout];</div><div class="line">                   &#125;</div><div class="line">               &#125;                </div><div class="line">               <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;];</div><div class="line">       </div><div class="line">       <span class="comment">//在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行</span></div><div class="line">       [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];        </div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">//如果url不存在，就在completedBlock里传入error（url为空）</span></div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_removeActivityIndicator];</div><div class="line">           <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">               <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">               completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，在这一层，使用一个字典<code>operationDictionary</code>专门用作存储操作的缓存，随时添加，删除操作任务。<br>而这个字典是<code>UIView+WebCacheOperation</code>分类的关联对象，它的存取方法使用运行时来操作：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIView+WebCacheOperation.m ============== //</span></div><div class="line"> <span class="comment">//获取关联对象：operations（用来存放操作的字典）</span></div><div class="line">- (SDOperationsDictionary *)operationDictionary &#123;</div><div class="line">    SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line">    <span class="comment">//存放操作的字典</span></div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//如果没有，就新建一个</span></div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];    </div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不直接在<code>UIImageView+WebCache</code>里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的<strong>单一职责原则（SRP：Single responsibility principle）</strong>，就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类<code>UIView+WebCacheOperation</code>来管理操作缓存（字典）。</p>
</blockquote>
<p>到这里，<code>UIKit</code>层上面的东西都讲完了，现在开始正式讲解工具层。</p>
<h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>上文提到过，<code>SDWebImageManager</code>同时管理<code>SDImageCache</code>和<code>SDWebImageDownloader</code>两个类，它是这一层的<strong>老大哥</strong>。在下载任务开始的时候，<code>SDWebImageManager</code>首先访问<code>SDImageCache</code>来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令<code>SDWebImageDownloader</code>来下载图片，下载成功后，存入缓存，显示图片。以上是<code>SDWebImageManager</code>大致的工作流程。</p>
<p>在详细讲解<code>SDWebImageManager</code>是如何下载图片之前，我们先看一下这个类的几个重要的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.h ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDImageCache *imageCache;<span class="comment">//管理缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDWebImageDownloader <span class="comment">//下载器*imageDownloader;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSURL</span> *&gt; *failedURLs;<span class="comment">//记录失效url的名单</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDWebImageCombinedOperation *&gt; *runningOperations;<span class="comment">//记录当前正在执行的操作</span></div></pre></td></tr></table></figure>
<p><code>SDWebImageManager</code>下载图片的方法只有一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:]</div></pre></td></tr></table></figure>
<p>看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.m ============== //</span></div><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">     ...                             </div><div class="line">    <span class="comment">//在SDImageCache里查询是否存在缓存的图片</span></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;        </div><div class="line">        ...</div><div class="line">        <span class="comment">//（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片）</span></div><div class="line">        <span class="keyword">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;            </div><div class="line">            <span class="comment">//1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片</span></div><div class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 2. 如果不存在缓存图片</span></div><div class="line">            ...            </div><div class="line">            <span class="comment">//开启下载器下载</span></div><div class="line">            <span class="comment">//subOperationToken 用来标记当前的下载任务，便于被取消</span></div><div class="line">            SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复</span></div><div class="line">                </div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//2. 如果有错误</span></div><div class="line">                    <span class="comment">//2.1 在completedBlock里传入error</span></div><div class="line">                    [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url];</div><div class="line"></div><div class="line">							<span class="comment">//2.2 在错误url名单中添加当前的url</span></div><div class="line">                    <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</div><div class="line">                        </div><div class="line">                       <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3. 下载成功</span></div><div class="line">                    <span class="comment">//3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3.2 进行缓存</span></div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);                   </div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                    </div><div class="line">                        <span class="comment">//（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作</span></div><div class="line">                                           </div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        </div><div class="line">          <span class="comment">//（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片）               dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span></div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">                                <span class="comment">//缓存图片</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//将图片传入completedBlock</span></div><div class="line">                            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                        &#125;);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//(图片下载成功并结束)</span></div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">					 <span class="comment">//如果完成，从当前运行的操作列表里移除当前操作</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">//取消的block</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">            </div><div class="line">                <span class="comment">//取消当前的token</span></div><div class="line">                [<span class="keyword">self</span>.imageDownloader cancel:subOperationToken];</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="comment">//从当前运行的操作列表里移除当前操作</span></div><div class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            &#125;;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//存在缓存图片</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;            </div><div class="line">            <span class="comment">//调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的的下载操作（线程安全）</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;            </div><div class="line">            <span class="comment">//没有缓存的图片，而且下载被代理终止了</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">           </div><div class="line">            <span class="comment">// 调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的下载操作</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;                                                             </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完了<code>SDWebImageManager</code>的回调处理，我们分别看一下<br><code>SDImageCache</code>和<code>SDWebImageDownloader</code>内部具体是如何工作的。首先看一下<code>SDImageCache</code>：</p>
<h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache;<span class="comment">//内存缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;<span class="comment">//磁盘缓存路径</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;<span class="comment">//</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> <span class="comment">//ioQueue唯一子线程;</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：查询缓存"><a href="#核心方法：查询缓存" class="headerlink" title="核心方法：查询缓存"></a>核心方法：查询缓存</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;   </div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;		</div><div class="line">    <span class="comment">//================查看内存的缓存=================//</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];    </div><div class="line">    <span class="comment">// 如果存在，直接调用block，将image，data，CaheType传进去</span></div><div class="line">    <span class="keyword">if</span> (image) &#123;    </div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;        </div><div class="line">        <span class="comment">//如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;        </div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//================查看磁盘的缓存=================//</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];    </div><div class="line">    <span class="comment">//唯一的子线程：self.ioQueue</span></div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;        </div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// 在用之前就判断operation是否被取消了，作者考虑的非常严谨</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;            </div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];            </div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                  <span class="comment">// cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);                </div><div class="line">                <span class="comment">//存入内存缓存中</span></div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;<span class="comment">//下载队列</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *lastAddedOperation;<span class="comment">//最后添加的下载操作</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) Class operationClass;<span class="comment">//操作类</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, SDWebImageDownloaderOperation *&gt; *URLOperations;<span class="comment">//操作数组</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDHTTPHeadersMutableDictionary *HTTPHeaders;<span class="comment">//HTTP请求头</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;<span class="comment">//用来阻塞前面的下载线程（串行化）</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：下载图片"><a href="#核心方法：下载图片" class="headerlink" title="核心方法：下载图片"></a>核心方法：下载图片</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        </div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">        </div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">        </div><div class="line">        <span class="comment">//创建下载请求</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类</span></div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="comment">//url证书</span></div><div class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//优先级</span></div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在下载队列里添加下载操作，执行下载操作</span></div><div class="line">        [sself.downloadQueue addOperation:operation];</div><div class="line">        </div><div class="line">        <span class="comment">//如果后进先出</span></div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            <span class="comment">//addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出</span></div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面还有一个<code>addProgressCallback: progressBlock: completedBlock: forURL: createCallback:</code>方法，用来保存<code>progressBlock</code>和<code>completedBlock</code>。我们看一下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</div><div class="line"></div><div class="line">    <span class="comment">// url 用来作为回调字典的key，如果为空，立即返回失败 </span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    __block SDWebImageDownloadToken *token = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">//串行化前面所有的操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;    </div><div class="line">        	<span class="comment">//当前下载操作中取出SDWebImageDownloaderOperation实例</span></div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];        </div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">        <span class="comment">//如果没有，就初始化它</span></div><div class="line">            operation = createCallback();</div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            </div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">              <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              &#125;;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">        <span class="comment">//这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock</span></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里真正保存两个block的方法是<code>addHandlersForProgress: completed:</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    <span class="comment">//实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock</span></div><div class="line">    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">    dispatch_barrier_async(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        <span class="comment">//添加到缓存中 self.callbackBlocks</span></div><div class="line">        [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里<code>SDWebImage</code>的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。</p>
<h2 id="最后看一下一些比较零散的知识点："><a href="#最后看一下一些比较零散的知识点：" class="headerlink" title="最后看一下一些比较零散的知识点："></a>最后看一下一些比较零散的知识点：</h2><hr>
<h4 id="1-运行时存取关联对象："><a href="#1-运行时存取关联对象：" class="headerlink" title="1. 运行时存取关联对象："></a>1. 运行时存取关联对象：</h4><p><strong>存：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"><span class="comment">//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。</span></div></pre></td></tr></table></figure>
<p><strong>取：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line"><span class="comment">//将operations对象通过地址&amp;loadOperationKey从self里取出来</span></div></pre></td></tr></table></figure>
<h4 id="2-数组的写操作需要加锁（多线程访问，避免覆写）"><a href="#2-数组的写操作需要加锁（多线程访问，避免覆写）" class="headerlink" title="2. 数组的写操作需要加锁（多线程访问，避免覆写）"></a>2. 数组的写操作需要加锁（多线程访问，避免覆写）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给self.runningOperations加锁</span></div><div class="line"><span class="comment">//self.runningOperations数组的添加操作</span></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//self.runningOperations数组的删除操作</span></div><div class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        <span class="keyword">if</span> (operation) &#123;</div><div class="line">            [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-确保在主线程的宏："><a href="#3-确保在主线程的宏：" class="headerlink" title="3. 确保在主线程的宏："></a>3. 确保在主线程的宏：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_main_async_safe(^&#123;</div><div class="line"> 				 <span class="comment">//将下面这段代码放在主线程中</span></div><div class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="comment">//宏定义：</span></div><div class="line"><span class="meta">#define dispatch_main_async_safe(block)\</span></div><div class="line">    <span class="keyword">if</span> (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == <span class="number">0</span>) &#123;\</div><div class="line">        block();\</div><div class="line">    &#125; <span class="keyword">else</span> &#123;\</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h4 id="4-设置不能为nil的参数"><a href="#4-设置不能为nil的参数" class="headerlink" title="4. 设置不能为nil的参数"></a>4. 设置不能为nil的参数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _imageCache = cache;</div><div class="line">        _imageDownloader = downloader;</div><div class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">        _runningOperations = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告</p>
</blockquote>
<h4 id="5-容错，强制转换类型"><a href="#5-容错，强制转换类型" class="headerlink" title="5. 容错，强制转换类型"></a>5. 容错，强制转换类型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL</p>
</blockquote>
<hr>
<p>貌似还有图片解码等内容没有详细看，以后会逐渐补充哒～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信对于广大的iOS开发者，对&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。&lt;/p&gt;
&lt;p&gt;在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;] placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder&quot;&lt;/span&gt;] completed:^(&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; * _Nullable image, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nullable error, SDImageCacheType cacheType, &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; * _Nullable imageURL) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        imageview.image = image;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;图片加载完成&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图片下载完成后直接显示下载后的图片&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;]];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在最开始先简单介绍这个框架：&lt;/p&gt;
&lt;p&gt;这个框架的核心类是&lt;code&gt;SDWebImageManger&lt;/code&gt;，在外部有&lt;code&gt;UIImageView+WebCache&lt;/code&gt; 和 &lt;code&gt;UIButton+WebCache&lt;/code&gt; 为下载图片的操作提供接口。内部有&lt;code&gt;SDWebImageManger&lt;/code&gt;负责处理和协调 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 和 &lt;code&gt;SDWebImageCache&lt;/code&gt;：&lt;code&gt;SDWebImageDownloader&lt;/code&gt;负责具体的下载任务，&lt;code&gt;SDWebImageCache&lt;/code&gt;负责关于缓存的工作：添加，删除，查询缓存。&lt;/p&gt;
&lt;p&gt;首先我们大致看一下这个框架的调用流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SDWebImage&quot;&gt;&lt;/p&gt;
&lt;p&gt;从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。&lt;/p&gt;
&lt;p&gt;OK～基本流程大概清楚了，我们看一下每个层具体实现吧～&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
